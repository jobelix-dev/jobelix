revoke delete on table "public"."academic" from "anon";

revoke insert on table "public"."academic" from "anon";

revoke references on table "public"."academic" from "anon";

revoke trigger on table "public"."academic" from "anon";

revoke truncate on table "public"."academic" from "anon";

revoke update on table "public"."academic" from "anon";

revoke references on table "public"."academic" from "authenticated";

revoke trigger on table "public"."academic" from "authenticated";

revoke truncate on table "public"."academic" from "authenticated";

revoke delete on table "public"."api_call_log" from "anon";

revoke insert on table "public"."api_call_log" from "anon";

revoke references on table "public"."api_call_log" from "anon";

revoke trigger on table "public"."api_call_log" from "anon";

revoke truncate on table "public"."api_call_log" from "anon";

revoke update on table "public"."api_call_log" from "anon";

revoke references on table "public"."api_call_log" from "authenticated";

revoke trigger on table "public"."api_call_log" from "authenticated";

revoke truncate on table "public"."api_call_log" from "authenticated";

revoke delete on table "public"."api_tokens" from "anon";

revoke insert on table "public"."api_tokens" from "anon";

revoke references on table "public"."api_tokens" from "anon";

revoke trigger on table "public"."api_tokens" from "anon";

revoke truncate on table "public"."api_tokens" from "anon";

revoke update on table "public"."api_tokens" from "anon";

revoke references on table "public"."api_tokens" from "authenticated";

revoke trigger on table "public"."api_tokens" from "authenticated";

revoke truncate on table "public"."api_tokens" from "authenticated";

revoke delete on table "public"."application" from "anon";

revoke insert on table "public"."application" from "anon";

revoke references on table "public"."application" from "anon";

revoke trigger on table "public"."application" from "anon";

revoke truncate on table "public"."application" from "anon";

revoke update on table "public"."application" from "anon";

revoke references on table "public"."application" from "authenticated";

revoke trigger on table "public"."application" from "authenticated";

revoke truncate on table "public"."application" from "authenticated";

revoke delete on table "public"."certification" from "anon";

revoke insert on table "public"."certification" from "anon";

revoke references on table "public"."certification" from "anon";

revoke trigger on table "public"."certification" from "anon";

revoke truncate on table "public"."certification" from "anon";

revoke update on table "public"."certification" from "anon";

revoke references on table "public"."certification" from "authenticated";

revoke trigger on table "public"."certification" from "authenticated";

revoke truncate on table "public"."certification" from "authenticated";

revoke delete on table "public"."company" from "anon";

revoke insert on table "public"."company" from "anon";

revoke references on table "public"."company" from "anon";

revoke trigger on table "public"."company" from "anon";

revoke truncate on table "public"."company" from "anon";

revoke update on table "public"."company" from "anon";

revoke references on table "public"."company" from "authenticated";

revoke trigger on table "public"."company" from "authenticated";

revoke truncate on table "public"."company" from "authenticated";

revoke delete on table "public"."company_offer" from "anon";

revoke insert on table "public"."company_offer" from "anon";

revoke references on table "public"."company_offer" from "anon";

revoke trigger on table "public"."company_offer" from "anon";

revoke truncate on table "public"."company_offer" from "anon";

revoke update on table "public"."company_offer" from "anon";

revoke references on table "public"."company_offer" from "authenticated";

revoke trigger on table "public"."company_offer" from "authenticated";

revoke truncate on table "public"."company_offer" from "authenticated";

revoke delete on table "public"."company_offer_draft" from "anon";

revoke insert on table "public"."company_offer_draft" from "anon";

revoke references on table "public"."company_offer_draft" from "anon";

revoke trigger on table "public"."company_offer_draft" from "anon";

revoke truncate on table "public"."company_offer_draft" from "anon";

revoke update on table "public"."company_offer_draft" from "anon";

revoke references on table "public"."company_offer_draft" from "authenticated";

revoke trigger on table "public"."company_offer_draft" from "authenticated";

revoke truncate on table "public"."company_offer_draft" from "authenticated";

revoke delete on table "public"."credit_purchases" from "anon";

revoke insert on table "public"."credit_purchases" from "anon";

revoke references on table "public"."credit_purchases" from "anon";

revoke trigger on table "public"."credit_purchases" from "anon";

revoke truncate on table "public"."credit_purchases" from "anon";

revoke update on table "public"."credit_purchases" from "anon";

revoke references on table "public"."credit_purchases" from "authenticated";

revoke trigger on table "public"."credit_purchases" from "authenticated";

revoke truncate on table "public"."credit_purchases" from "authenticated";

revoke delete on table "public"."daily_credit_grants" from "anon";

revoke insert on table "public"."daily_credit_grants" from "anon";

revoke references on table "public"."daily_credit_grants" from "anon";

revoke trigger on table "public"."daily_credit_grants" from "anon";

revoke truncate on table "public"."daily_credit_grants" from "anon";

revoke update on table "public"."daily_credit_grants" from "anon";

revoke references on table "public"."daily_credit_grants" from "authenticated";

revoke trigger on table "public"."daily_credit_grants" from "authenticated";

revoke truncate on table "public"."daily_credit_grants" from "authenticated";

revoke delete on table "public"."experience" from "anon";

revoke insert on table "public"."experience" from "anon";

revoke references on table "public"."experience" from "anon";

revoke trigger on table "public"."experience" from "anon";

revoke truncate on table "public"."experience" from "anon";

revoke update on table "public"."experience" from "anon";

revoke references on table "public"."experience" from "authenticated";

revoke trigger on table "public"."experience" from "authenticated";

revoke truncate on table "public"."experience" from "authenticated";

revoke delete on table "public"."language" from "anon";

revoke insert on table "public"."language" from "anon";

revoke references on table "public"."language" from "anon";

revoke trigger on table "public"."language" from "anon";

revoke truncate on table "public"."language" from "anon";

revoke update on table "public"."language" from "anon";

revoke references on table "public"."language" from "authenticated";

revoke trigger on table "public"."language" from "authenticated";

revoke truncate on table "public"."language" from "authenticated";

revoke delete on table "public"."oauth_connections" from "anon";

revoke insert on table "public"."oauth_connections" from "anon";

revoke references on table "public"."oauth_connections" from "anon";

revoke trigger on table "public"."oauth_connections" from "anon";

revoke truncate on table "public"."oauth_connections" from "anon";

revoke update on table "public"."oauth_connections" from "anon";

revoke references on table "public"."oauth_connections" from "authenticated";

revoke trigger on table "public"."oauth_connections" from "authenticated";

revoke truncate on table "public"."oauth_connections" from "authenticated";

revoke delete on table "public"."offer_capabilities" from "anon";

revoke insert on table "public"."offer_capabilities" from "anon";

revoke references on table "public"."offer_capabilities" from "anon";

revoke trigger on table "public"."offer_capabilities" from "anon";

revoke truncate on table "public"."offer_capabilities" from "anon";

revoke update on table "public"."offer_capabilities" from "anon";

revoke references on table "public"."offer_capabilities" from "authenticated";

revoke trigger on table "public"."offer_capabilities" from "authenticated";

revoke truncate on table "public"."offer_capabilities" from "authenticated";

revoke delete on table "public"."offer_locations" from "anon";

revoke insert on table "public"."offer_locations" from "anon";

revoke references on table "public"."offer_locations" from "anon";

revoke trigger on table "public"."offer_locations" from "anon";

revoke truncate on table "public"."offer_locations" from "anon";

revoke update on table "public"."offer_locations" from "anon";

revoke references on table "public"."offer_locations" from "authenticated";

revoke trigger on table "public"."offer_locations" from "authenticated";

revoke truncate on table "public"."offer_locations" from "authenticated";

revoke delete on table "public"."offer_perks" from "anon";

revoke insert on table "public"."offer_perks" from "anon";

revoke references on table "public"."offer_perks" from "anon";

revoke trigger on table "public"."offer_perks" from "anon";

revoke truncate on table "public"."offer_perks" from "anon";

revoke update on table "public"."offer_perks" from "anon";

revoke references on table "public"."offer_perks" from "authenticated";

revoke trigger on table "public"."offer_perks" from "authenticated";

revoke truncate on table "public"."offer_perks" from "authenticated";

revoke delete on table "public"."offer_questions" from "anon";

revoke insert on table "public"."offer_questions" from "anon";

revoke references on table "public"."offer_questions" from "anon";

revoke trigger on table "public"."offer_questions" from "anon";

revoke truncate on table "public"."offer_questions" from "anon";

revoke update on table "public"."offer_questions" from "anon";

revoke references on table "public"."offer_questions" from "authenticated";

revoke trigger on table "public"."offer_questions" from "authenticated";

revoke truncate on table "public"."offer_questions" from "authenticated";

revoke delete on table "public"."offer_responsibilities" from "anon";

revoke insert on table "public"."offer_responsibilities" from "anon";

revoke references on table "public"."offer_responsibilities" from "anon";

revoke trigger on table "public"."offer_responsibilities" from "anon";

revoke truncate on table "public"."offer_responsibilities" from "anon";

revoke update on table "public"."offer_responsibilities" from "anon";

revoke references on table "public"."offer_responsibilities" from "authenticated";

revoke trigger on table "public"."offer_responsibilities" from "authenticated";

revoke truncate on table "public"."offer_responsibilities" from "authenticated";

revoke delete on table "public"."offer_skills" from "anon";

revoke insert on table "public"."offer_skills" from "anon";

revoke references on table "public"."offer_skills" from "anon";

revoke trigger on table "public"."offer_skills" from "anon";

revoke truncate on table "public"."offer_skills" from "anon";

revoke update on table "public"."offer_skills" from "anon";

revoke references on table "public"."offer_skills" from "authenticated";

revoke trigger on table "public"."offer_skills" from "authenticated";

revoke truncate on table "public"."offer_skills" from "authenticated";

revoke delete on table "public"."project" from "anon";

revoke insert on table "public"."project" from "anon";

revoke references on table "public"."project" from "anon";

revoke trigger on table "public"."project" from "anon";

revoke truncate on table "public"."project" from "anon";

revoke update on table "public"."project" from "anon";

revoke references on table "public"."project" from "authenticated";

revoke trigger on table "public"."project" from "authenticated";

revoke truncate on table "public"."project" from "authenticated";

revoke delete on table "public"."publication" from "anon";

revoke insert on table "public"."publication" from "anon";

revoke references on table "public"."publication" from "anon";

revoke trigger on table "public"."publication" from "anon";

revoke truncate on table "public"."publication" from "anon";

revoke update on table "public"."publication" from "anon";

revoke references on table "public"."publication" from "authenticated";

revoke trigger on table "public"."publication" from "authenticated";

revoke truncate on table "public"."publication" from "authenticated";

revoke delete on table "public"."referral_codes" from "anon";

revoke insert on table "public"."referral_codes" from "anon";

revoke references on table "public"."referral_codes" from "anon";

revoke trigger on table "public"."referral_codes" from "anon";

revoke truncate on table "public"."referral_codes" from "anon";

revoke update on table "public"."referral_codes" from "anon";

revoke references on table "public"."referral_codes" from "authenticated";

revoke trigger on table "public"."referral_codes" from "authenticated";

revoke truncate on table "public"."referral_codes" from "authenticated";

revoke delete on table "public"."referrals" from "anon";

revoke insert on table "public"."referrals" from "anon";

revoke references on table "public"."referrals" from "anon";

revoke trigger on table "public"."referrals" from "anon";

revoke truncate on table "public"."referrals" from "anon";

revoke update on table "public"."referrals" from "anon";

revoke references on table "public"."referrals" from "authenticated";

revoke trigger on table "public"."referrals" from "authenticated";

revoke truncate on table "public"."referrals" from "authenticated";

revoke delete on table "public"."resume" from "anon";

revoke insert on table "public"."resume" from "anon";

revoke references on table "public"."resume" from "anon";

revoke trigger on table "public"."resume" from "anon";

revoke truncate on table "public"."resume" from "anon";

revoke update on table "public"."resume" from "anon";

revoke references on table "public"."resume" from "authenticated";

revoke trigger on table "public"."resume" from "authenticated";

revoke truncate on table "public"."resume" from "authenticated";

revoke delete on table "public"."signup_ip_tracking" from "anon";

revoke insert on table "public"."signup_ip_tracking" from "anon";

revoke references on table "public"."signup_ip_tracking" from "anon";

revoke trigger on table "public"."signup_ip_tracking" from "anon";

revoke truncate on table "public"."signup_ip_tracking" from "anon";

revoke update on table "public"."signup_ip_tracking" from "anon";

revoke references on table "public"."signup_ip_tracking" from "authenticated";

revoke trigger on table "public"."signup_ip_tracking" from "authenticated";

revoke truncate on table "public"."signup_ip_tracking" from "authenticated";

revoke delete on table "public"."skill" from "anon";

revoke insert on table "public"."skill" from "anon";

revoke references on table "public"."skill" from "anon";

revoke trigger on table "public"."skill" from "anon";

revoke truncate on table "public"."skill" from "anon";

revoke update on table "public"."skill" from "anon";

revoke references on table "public"."skill" from "authenticated";

revoke trigger on table "public"."skill" from "authenticated";

revoke truncate on table "public"."skill" from "authenticated";

revoke delete on table "public"."social_link" from "anon";

revoke insert on table "public"."social_link" from "anon";

revoke references on table "public"."social_link" from "anon";

revoke trigger on table "public"."social_link" from "anon";

revoke truncate on table "public"."social_link" from "anon";

revoke update on table "public"."social_link" from "anon";

revoke references on table "public"."social_link" from "authenticated";

revoke trigger on table "public"."social_link" from "authenticated";

revoke truncate on table "public"."social_link" from "authenticated";

revoke delete on table "public"."student" from "anon";

revoke insert on table "public"."student" from "anon";

revoke references on table "public"."student" from "anon";

revoke trigger on table "public"."student" from "anon";

revoke truncate on table "public"."student" from "anon";

revoke update on table "public"."student" from "anon";

revoke references on table "public"."student" from "authenticated";

revoke trigger on table "public"."student" from "authenticated";

revoke truncate on table "public"."student" from "authenticated";

revoke delete on table "public"."student_profile_draft" from "anon";

revoke insert on table "public"."student_profile_draft" from "anon";

revoke references on table "public"."student_profile_draft" from "anon";

revoke trigger on table "public"."student_profile_draft" from "anon";

revoke truncate on table "public"."student_profile_draft" from "anon";

revoke update on table "public"."student_profile_draft" from "anon";

revoke references on table "public"."student_profile_draft" from "authenticated";

revoke trigger on table "public"."student_profile_draft" from "authenticated";

revoke truncate on table "public"."student_profile_draft" from "authenticated";

revoke delete on table "public"."student_work_preferences" from "anon";

revoke insert on table "public"."student_work_preferences" from "anon";

revoke references on table "public"."student_work_preferences" from "anon";

revoke trigger on table "public"."student_work_preferences" from "anon";

revoke truncate on table "public"."student_work_preferences" from "anon";

revoke update on table "public"."student_work_preferences" from "anon";

revoke references on table "public"."student_work_preferences" from "authenticated";

revoke trigger on table "public"."student_work_preferences" from "authenticated";

revoke truncate on table "public"."student_work_preferences" from "authenticated";

revoke delete on table "public"."user_credits" from "anon";

revoke insert on table "public"."user_credits" from "anon";

revoke references on table "public"."user_credits" from "anon";

revoke trigger on table "public"."user_credits" from "anon";

revoke truncate on table "public"."user_credits" from "anon";

revoke update on table "public"."user_credits" from "anon";

revoke references on table "public"."user_credits" from "authenticated";

revoke trigger on table "public"."user_credits" from "authenticated";

revoke truncate on table "public"."user_credits" from "authenticated";

revoke delete on table "public"."user_feedback" from "anon";

revoke insert on table "public"."user_feedback" from "anon";

revoke references on table "public"."user_feedback" from "anon";

revoke trigger on table "public"."user_feedback" from "anon";

revoke truncate on table "public"."user_feedback" from "anon";

revoke update on table "public"."user_feedback" from "anon";

revoke references on table "public"."user_feedback" from "authenticated";

revoke trigger on table "public"."user_feedback" from "authenticated";

revoke truncate on table "public"."user_feedback" from "authenticated";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.add_purchased_credits(p_user_id uuid, p_credits integer, p_amount_cents integer, p_stripe_event_id text DEFAULT NULL::text, p_stripe_session_id text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- SECURITY FIX: This function should only be called from server-side (webhooks)
  IF NOT public.is_service_role() THEN
    RAISE EXCEPTION 'Unauthorized: service role required for credit purchases';
  END IF;

  -- Insert purchase record (will fail if event_id or session_id already exists)
  INSERT INTO public.credit_purchases (
    user_id, 
    credits_amount, 
    price_cents, 
    stripe_event_id, 
    stripe_checkout_session_id
  )
  VALUES (
    p_user_id, 
    p_credits, 
    p_amount_cents, 
    p_stripe_event_id, 
    p_stripe_session_id
  );

  -- Add credits to user balance
  UPDATE public.user_credits
  SET 
    balance = balance + p_credits,
    total_purchased = total_purchased + p_credits
  WHERE user_id = p_user_id;

  -- Create user_credits row if it doesn't exist
  IF NOT FOUND THEN
    INSERT INTO public.user_credits (user_id, balance, total_purchased)
    VALUES (p_user_id, p_credits, p_credits);
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_purchased_credits(p_user_id uuid, p_credits_amount integer, p_payment_intent_id text, p_stripe_event_id text, p_session_id text, p_amount_cents integer, p_currency text)
 RETURNS TABLE(success boolean, new_balance integer, error_message text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_new_balance INTEGER;
  v_purchase_id UUID;
BEGIN
  -- SECURITY FIX: This function should only be called from server-side (webhooks)
  IF NOT public.is_service_role() THEN
    RAISE EXCEPTION 'Unauthorized: service role required for credit purchases';
  END IF;

  -- SECURITY: Check if this event was already processed (idempotency)
  -- This check happens INSIDE the transaction with row lock
  SELECT id INTO v_purchase_id
  FROM public.credit_purchases
  WHERE stripe_event_id = p_stripe_event_id
  FOR UPDATE NOWAIT; -- Lock immediately or fail
  
  IF v_purchase_id IS NOT NULL THEN
    -- Event already processed
    SELECT balance INTO v_new_balance
    FROM public.user_credits
    WHERE user_id = p_user_id;
    
    RETURN QUERY SELECT TRUE, COALESCE(v_new_balance, 0), 'Already processed'::TEXT;
    RETURN;
  END IF;

  -- Check by session ID as backup
  SELECT id INTO v_purchase_id
  FROM public.credit_purchases
  WHERE stripe_checkout_session_id = p_session_id
    AND status = 'completed'
  FOR UPDATE NOWAIT;
  
  IF v_purchase_id IS NOT NULL THEN
    -- Session already completed
    SELECT balance INTO v_new_balance
    FROM public.user_credits
    WHERE user_id = p_user_id;
    
    RETURN QUERY SELECT TRUE, COALESCE(v_new_balance, 0), 'Session already completed'::TEXT;
    RETURN;
  END IF;

  -- ATOMIC OPERATION: Update purchase record AND add credits in same transaction
  
  -- Step 1: Update purchase record to completed
  UPDATE public.credit_purchases
  SET 
    stripe_payment_intent_id = p_payment_intent_id,
    stripe_event_id = p_stripe_event_id,
    price_cents = p_amount_cents,
    currency = p_currency,
    status = 'completed',
    completed_at = now()
  WHERE stripe_checkout_session_id = p_session_id
    AND status = 'pending'
  RETURNING id INTO v_purchase_id;
  
  IF v_purchase_id IS NULL THEN
    -- Purchase not found or already processed
    RETURN QUERY SELECT FALSE, 0, 'Purchase not found or already completed'::TEXT;
    RETURN;
  END IF;

  -- Step 2: Add credits to user balance
  INSERT INTO public.user_credits (user_id, balance, total_purchased, last_updated)
  VALUES (p_user_id, p_credits_amount, p_credits_amount, now())
  ON CONFLICT (user_id) DO UPDATE SET
    balance = user_credits.balance + p_credits_amount,
    total_purchased = user_credits.total_purchased + p_credits_amount,
    last_updated = now()
  RETURNING user_credits.balance INTO v_new_balance;
  
  -- Success
  RETURN QUERY SELECT TRUE, v_new_balance, 'Credits added successfully'::TEXT;
  
EXCEPTION
  WHEN lock_not_available THEN
    -- Another process is currently processing this event
    RETURN QUERY SELECT FALSE, 0, 'Event is being processed by another request'::TEXT;
  WHEN unique_violation THEN
    -- Event ID already exists (race condition caught)
    SELECT balance INTO v_new_balance
    FROM public.user_credits
    WHERE user_id = p_user_id;
    RETURN QUERY SELECT TRUE, COALESCE(v_new_balance, 0), 'Event already processed (caught by constraint)'::TEXT;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.apply_referral_code(p_code text)
 RETURNS TABLE(success boolean, error_message text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_referrer_id UUID;
  v_normalized_code TEXT;
  v_user_created_at TIMESTAMPTZ;
  v_is_student BOOLEAN;
  v_referrer_is_student BOOLEAN;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN QUERY SELECT FALSE, 'Not authenticated'::TEXT;
    RETURN;
  END IF;
  
  -- Check if user is a student
  SELECT EXISTS (SELECT 1 FROM public.student WHERE id = v_user_id) INTO v_is_student;
  IF NOT v_is_student THEN
    RETURN QUERY SELECT FALSE, 'Invalid or expired referral code'::TEXT;
    RETURN;
  END IF;
  
  -- Get user's creation timestamp for time limit check
  SELECT created_at INTO v_user_created_at
  FROM auth.users
  WHERE id = v_user_id;
  
  -- Check 7-day time limit
  IF v_user_created_at IS NULL OR (now() - v_user_created_at) > INTERVAL '7 days' THEN
    RETURN QUERY SELECT FALSE, 'Invalid or expired referral code'::TEXT;
    RETURN;
  END IF;
  
  -- Normalize code to lowercase
  v_normalized_code := lower(trim(p_code));
  
  -- Validate code format
  IF v_normalized_code !~ '^[a-z0-9]{8}$' THEN
    RETURN QUERY SELECT FALSE, 'Invalid or expired referral code'::TEXT;
    RETURN;
  END IF;
  
  -- Check if user was already referred (before attempting insert)
  IF EXISTS (SELECT 1 FROM public.referrals WHERE referee_id = v_user_id) THEN
    RETURN QUERY SELECT FALSE, 'You have already used a referral code'::TEXT;
    RETURN;
  END IF;
  
  -- Find the referrer by code
  SELECT rc.user_id INTO v_referrer_id
  FROM public.referral_codes rc
  WHERE rc.code = v_normalized_code;
  
  IF v_referrer_id IS NULL THEN
    RETURN QUERY SELECT FALSE, 'Invalid or expired referral code'::TEXT;
    RETURN;
  END IF;
  
  -- Check if referrer is a student
  SELECT EXISTS (SELECT 1 FROM public.student WHERE id = v_referrer_id) INTO v_referrer_is_student;
  IF NOT v_referrer_is_student THEN
    RETURN QUERY SELECT FALSE, 'Invalid or expired referral code'::TEXT;
    RETURN;
  END IF;
  
  -- Prevent self-referral (return same generic message)
  IF v_referrer_id = v_user_id THEN
    RETURN QUERY SELECT FALSE, 'Invalid or expired referral code'::TEXT;
    RETURN;
  END IF;
  
  -- Create the pending referral with exception handling for race condition
  BEGIN
    INSERT INTO public.referrals (referrer_id, referee_id, referral_code, status)
    VALUES (v_referrer_id, v_user_id, v_normalized_code, 'pending');
  EXCEPTION 
    WHEN unique_violation THEN
      -- Another concurrent request already inserted - return friendly message
      RETURN QUERY SELECT FALSE, 'You have already used a referral code'::TEXT;
      RETURN;
  END;
  
  RETURN QUERY SELECT TRUE, NULL::TEXT;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_api_rate_limit(p_user_id uuid, p_endpoint text, p_hourly_limit integer DEFAULT 100, p_daily_limit integer DEFAULT 500)
 RETURNS TABLE(allowed boolean, hourly_count bigint, daily_count bigint, hourly_remaining integer, daily_remaining integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_hourly_count BIGINT;
  v_daily_count BIGINT;
BEGIN
  -- Count calls in the last hour
  SELECT COUNT(*) INTO v_hourly_count
  FROM api_call_log
  WHERE user_id = p_user_id
    AND endpoint = p_endpoint
    AND created_at > NOW() - INTERVAL '1 hour';

  -- Count calls in the last 24 hours
  SELECT COUNT(*) INTO v_daily_count
  FROM api_call_log
  WHERE user_id = p_user_id
    AND endpoint = p_endpoint
    AND created_at > NOW() - INTERVAL '24 hours';

  -- Return results
  RETURN QUERY SELECT
    (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit) AS allowed,
    v_hourly_count AS hourly_count,
    v_daily_count AS daily_count,
    (p_hourly_limit - v_hourly_count::INT) AS hourly_remaining,
    (p_daily_limit - v_daily_count::INT) AS daily_remaining;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_api_logs()
 RETURNS bigint
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_deleted_count BIGINT;
BEGIN
  DELETE FROM api_call_log
  WHERE created_at < NOW() - INTERVAL '30 days';
  
  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
  RETURN v_deleted_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_ip_tracking()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    DELETE FROM signup_ip_tracking
    WHERE created_at < (now() - interval '30 days');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.complete_pending_referral(p_referee_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_referral RECORD;
BEGIN
  -- Find and lock the pending referral
  SELECT * INTO v_referral
  FROM public.referrals
  WHERE referee_id = p_referee_id
    AND status = 'pending'
  FOR UPDATE SKIP LOCKED;
  
  -- No pending referral found
  IF v_referral IS NULL THEN
    RETURN;
  END IF;
  
  -- Grant credits to referrer (200 credits)
  INSERT INTO public.user_credits (user_id, balance, total_earned)
  VALUES (v_referral.referrer_id, v_referral.referrer_credits, v_referral.referrer_credits)
  ON CONFLICT (user_id) DO UPDATE SET
    balance = user_credits.balance + v_referral.referrer_credits,
    total_earned = user_credits.total_earned + v_referral.referrer_credits,
    last_updated = now();
  
  -- Grant credits to referee (50 credits)
  INSERT INTO public.user_credits (user_id, balance, total_earned)
  VALUES (v_referral.referee_id, v_referral.referee_credits, v_referral.referee_credits)
  ON CONFLICT (user_id) DO UPDATE SET
    balance = user_credits.balance + v_referral.referee_credits,
    total_earned = user_credits.total_earned + v_referral.referee_credits,
    last_updated = now();
  
  -- Mark referral as completed
  UPDATE public.referrals
  SET status = 'completed', completed_at = now()
  WHERE id = v_referral.id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.count_recent_signups_from_ip(p_ip_address text, p_hours_ago integer DEFAULT 24)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    signup_count int;
BEGIN
    SELECT COUNT(*)
    INTO signup_count
    FROM signup_ip_tracking
    WHERE ip_address = p_ip_address
    AND created_at > (now() - (p_hours_ago || ' hours')::interval);
    
    RETURN signup_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.finalize_student_profile(p_user_id uuid, p_profile jsonb, p_education jsonb, p_experience jsonb, p_projects jsonb, p_skills jsonb, p_languages jsonb, p_publications jsonb, p_certifications jsonb, p_social_links jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_education_count int;
  v_experience_count int;
  v_projects_count int;
  v_skills_count int;
  v_languages_count int;
  v_publications_count int;
  v_certifications_count int;
  v_social_links_count int;
BEGIN
  -- SECURITY: Verify caller is the user being updated
  IF (SELECT auth.uid()) IS DISTINCT FROM p_user_id THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Unauthorized: can only update own profile'
    );
  END IF;

  -- Upsert student record (includes phone_country_code)
  INSERT INTO student (
    id, student_name, first_name, last_name, mail_adress,
    phone_number, phone_country_code, address
  )
  VALUES (
    p_user_id,
    (p_profile->>'student_name')::text,
    (p_profile->>'first_name')::text,
    (p_profile->>'last_name')::text,
    (p_profile->>'mail_adress')::text,
    (p_profile->>'phone_number')::text,
    UPPER((p_profile->>'phone_country_code')::text),
    (p_profile->>'address')::text
  )
  ON CONFLICT (id) DO UPDATE SET
    student_name = EXCLUDED.student_name,
    first_name = EXCLUDED.first_name,
    last_name = EXCLUDED.last_name,
    mail_adress = EXCLUDED.mail_adress,
    phone_number = EXCLUDED.phone_number,
    phone_country_code = EXCLUDED.phone_country_code,
    address = EXCLUDED.address;
  
  DELETE FROM academic WHERE student_id = p_user_id;
  DELETE FROM experience WHERE student_id = p_user_id;
  DELETE FROM project WHERE student_id = p_user_id;
  DELETE FROM skill WHERE student_id = p_user_id;
  DELETE FROM language WHERE student_id = p_user_id;
  DELETE FROM publication WHERE student_id = p_user_id;
  DELETE FROM certification WHERE student_id = p_user_id;
  DELETE FROM social_link WHERE student_id = p_user_id;
  
  INSERT INTO academic (student_id, school_name, degree, description, start_year, start_month, end_year, end_month)
  SELECT p_user_id, (elem->>'school_name')::text, (elem->>'degree')::text, (elem->>'description')::text,
    (elem->>'start_year')::int, (elem->>'start_month')::int, (elem->>'end_year')::int, (elem->>'end_month')::int
  FROM jsonb_array_elements(p_education) AS elem
  WHERE (elem->>'school_name')::text IS NOT NULL AND (elem->>'school_name')::text != ''
    AND (elem->>'degree')::text IS NOT NULL AND (elem->>'degree')::text != '';
  GET DIAGNOSTICS v_education_count = ROW_COUNT;
  
  INSERT INTO experience (student_id, organisation_name, position_name, description, start_year, start_month, end_year, end_month)
  SELECT p_user_id, (elem->>'organisation_name')::text, (elem->>'position_name')::text, (elem->>'description')::text,
    (elem->>'start_year')::int, (elem->>'start_month')::int, (elem->>'end_year')::int, (elem->>'end_month')::int
  FROM jsonb_array_elements(p_experience) AS elem
  WHERE (elem->>'organisation_name')::text IS NOT NULL AND (elem->>'organisation_name')::text != ''
    AND (elem->>'position_name')::text IS NOT NULL AND (elem->>'position_name')::text != '';
  GET DIAGNOSTICS v_experience_count = ROW_COUNT;
  
  INSERT INTO project (student_id, project_name, description, link)
  SELECT p_user_id, (elem->>'project_name')::text, (elem->>'description')::text, (elem->>'link')::text
  FROM jsonb_array_elements(p_projects) AS elem
  WHERE (elem->>'project_name')::text IS NOT NULL AND (elem->>'project_name')::text != '';
  GET DIAGNOSTICS v_projects_count = ROW_COUNT;
  
  INSERT INTO skill (student_id, skill_name, skill_slug)
  SELECT p_user_id, (elem->>'skill_name')::text, (elem->>'skill_slug')::text
  FROM jsonb_array_elements(p_skills) AS elem
  WHERE (elem->>'skill_name')::text IS NOT NULL AND (elem->>'skill_name')::text != ''
    AND (elem->>'skill_slug')::text IS NOT NULL AND (elem->>'skill_slug')::text != '';
  GET DIAGNOSTICS v_skills_count = ROW_COUNT;
  
  INSERT INTO language (student_id, language_name, proficiency_level)
  SELECT p_user_id, (elem->>'language_name')::text, (elem->>'proficiency_level')::text
  FROM jsonb_array_elements(p_languages) AS elem
  WHERE (elem->>'language_name')::text IS NOT NULL AND (elem->>'language_name')::text != ''
    AND (elem->>'proficiency_level')::text IS NOT NULL AND (elem->>'proficiency_level')::text != '';
  GET DIAGNOSTICS v_languages_count = ROW_COUNT;
  
  INSERT INTO publication (student_id, title, journal_name, description, publication_year, publication_month, link)
  SELECT p_user_id, (elem->>'title')::text, (elem->>'journal_name')::text, (elem->>'description')::text,
    (elem->>'publication_year')::int, (elem->>'publication_month')::int, (elem->>'link')::text
  FROM jsonb_array_elements(p_publications) AS elem
  WHERE (elem->>'title')::text IS NOT NULL AND (elem->>'title')::text != '';
  GET DIAGNOSTICS v_publications_count = ROW_COUNT;
  
  INSERT INTO certification (student_id, name, issuing_organization, url)
  SELECT p_user_id, (elem->>'name')::text, (elem->>'issuing_organization')::text, (elem->>'url')::text
  FROM jsonb_array_elements(p_certifications) AS elem
  WHERE (elem->>'name')::text IS NOT NULL AND (elem->>'name')::text != '';
  GET DIAGNOSTICS v_certifications_count = ROW_COUNT;
  
  IF p_social_links IS NOT NULL AND jsonb_typeof(p_social_links) = 'object' THEN
    IF (p_social_links->>'github') IS NOT NULL 
       OR (p_social_links->>'linkedin') IS NOT NULL
       OR (p_social_links->>'stackoverflow') IS NOT NULL
       OR (p_social_links->>'kaggle') IS NOT NULL
       OR (p_social_links->>'leetcode') IS NOT NULL
    THEN
      INSERT INTO social_link (student_id, github, linkedin, stackoverflow, kaggle, leetcode)
      VALUES (
        p_user_id,
        NULLIF(TRIM(p_social_links->>'github'), ''),
        NULLIF(TRIM(p_social_links->>'linkedin'), ''),
        NULLIF(TRIM(p_social_links->>'stackoverflow'), ''),
        NULLIF(TRIM(p_social_links->>'kaggle'), ''),
        NULLIF(TRIM(p_social_links->>'leetcode'), '')
      );
      v_social_links_count := 1;
    ELSE
      v_social_links_count := 0;
    END IF;
  ELSE
    v_social_links_count := 0;
  END IF;
  
  RETURN jsonb_build_object(
    'success', true,
    'education_count', v_education_count,
    'experience_count', v_experience_count,
    'projects_count', v_projects_count,
    'skills_count', v_skills_count,
    'languages_count', v_languages_count,
    'publications_count', v_publications_count,
    'certifications_count', v_certifications_count,
    'social_links_count', v_social_links_count
  );
  
EXCEPTION
  WHEN OTHERS THEN
    -- Log the actual error server-side but return generic message to client
    RAISE WARNING 'finalize_student_profile failed for user %: % (SQLSTATE: %)', p_user_id, SQLERRM, SQLSTATE;
    RETURN jsonb_build_object(
      'success', false,
      'error', 'An error occurred while saving your profile. Please try again.'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_leaderboard_rank()
 RETURNS TABLE(rank integer, completed_count integer, total_credits_earned integer, total_participants integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_total_participants INTEGER;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Calculate total participants first
  SELECT COUNT(DISTINCT referrer_id)::INTEGER INTO v_total_participants
  FROM public.referrals 
  WHERE status = 'completed';

  RETURN QUERY
  WITH referrer_stats AS (
    SELECT 
      r.referrer_id,
      COUNT(*) FILTER (WHERE r.status = 'completed') AS completed,
      COALESCE(SUM(r.referrer_credits) FILTER (WHERE r.status = 'completed'), 0) AS credits
    FROM public.referrals r
    GROUP BY r.referrer_id
    HAVING COUNT(*) FILTER (WHERE r.status = 'completed') > 0
  ),
  ranked AS (
    SELECT 
      rs.referrer_id,
      rs.completed,
      rs.credits,
      ROW_NUMBER() OVER (ORDER BY rs.completed DESC, rs.credits DESC, rs.referrer_id) AS rn
    FROM referrer_stats rs
  )
  SELECT 
    rn::INTEGER AS rank,
    completed::INTEGER AS completed_count,
    credits::INTEGER AS total_credits_earned,
    v_total_participants AS total_participants
  FROM ranked
  WHERE referrer_id = v_user_id;

  -- If user has no completed referrals, return NULL rank with total participants
  IF NOT FOUND THEN
    RETURN QUERY SELECT NULL::INTEGER, 0, 0, v_total_participants;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_referral_status()
 RETURNS TABLE(is_referred boolean, status text, bonus_credits integer, referrer_first_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  RETURN QUERY
  SELECT 
    TRUE AS is_referred,
    r.status,
    r.referee_credits AS bonus_credits,
    s.first_name AS referrer_first_name
  FROM public.referrals r
  LEFT JOIN public.student s ON s.id = r.referrer_id
  WHERE r.referee_id = v_user_id
  LIMIT 1;

  -- If no rows returned, return default "not referred" state
  IF NOT FOUND THEN
    RETURN QUERY SELECT FALSE, NULL::TEXT, NULL::INTEGER, NULL::TEXT;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_referrals()
 RETURNS TABLE(id uuid, first_name text, status text, created_at timestamp with time zone, completed_at timestamp with time zone, credits_earned integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Check if user is a student (only students can have referrals)
  IF NOT EXISTS (SELECT 1 FROM public.student WHERE student.id = v_user_id) THEN
    RAISE EXCEPTION 'Referrals are only available for talent accounts';
  END IF;

  RETURN QUERY
  SELECT 
    r.id,
    COALESCE(s.first_name, 'Friend') AS first_name,
    r.status,
    r.created_at,
    r.completed_at,
    CASE WHEN r.status = 'completed' THEN r.referrer_credits ELSE 0 END AS credits_earned
  FROM public.referrals r
  LEFT JOIN public.student s ON s.id = r.referee_id
  WHERE r.referrer_id = v_user_id
  ORDER BY 
    -- Pending first, then by date (newest first)
    CASE WHEN r.status = 'pending' THEN 0 ELSE 1 END,
    r.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_or_create_referral_code()
 RETURNS TABLE(code text, created boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_code TEXT;
  v_attempts INTEGER := 0;
  v_max_attempts INTEGER := 10;
  v_is_student BOOLEAN;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Check if user is a student
  SELECT EXISTS (SELECT 1 FROM public.student WHERE id = v_user_id) INTO v_is_student;
  IF NOT v_is_student THEN
    RAISE EXCEPTION 'Referral codes are only available for talent accounts';
  END IF;
  
  -- Check if user already has a code
  SELECT rc.code INTO v_code
  FROM public.referral_codes rc
  WHERE rc.user_id = v_user_id;
  
  IF v_code IS NOT NULL THEN
    RETURN QUERY SELECT v_code, FALSE;
    RETURN;
  END IF;
  
  -- Generate a unique code (retry on collision)
  LOOP
    v_code := generate_referral_code();
    v_attempts := v_attempts + 1;
    
    BEGIN
      INSERT INTO public.referral_codes (user_id, code)
      VALUES (v_user_id, v_code);
      
      RETURN QUERY SELECT v_code, TRUE;
      RETURN;
    EXCEPTION WHEN unique_violation THEN
      IF v_attempts >= v_max_attempts THEN
        RAISE EXCEPTION 'Failed to generate unique referral code after % attempts', v_max_attempts;
      END IF;
      -- Continue loop to try again
    END;
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_referral_leaderboard(p_limit integer DEFAULT 10)
 RETURNS TABLE(rank integer, first_name text, completed_count integer, total_credits_earned integer, is_current_user boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_safe_limit INTEGER;
BEGIN
  v_user_id := auth.uid();
  
  -- Validate and cap the limit (1-100)
  v_safe_limit := GREATEST(1, LEAST(COALESCE(p_limit, 10), 100));
  
  -- Return top referrers with their stats
  RETURN QUERY
  WITH referrer_stats AS (
    SELECT 
      r.referrer_id,
      COUNT(*) FILTER (WHERE r.status = 'completed') AS completed,
      COALESCE(SUM(r.referrer_credits) FILTER (WHERE r.status = 'completed'), 0) AS credits
    FROM public.referrals r
    GROUP BY r.referrer_id
    HAVING COUNT(*) FILTER (WHERE r.status = 'completed') > 0
  ),
  ranked AS (
    SELECT 
      rs.referrer_id,
      rs.completed,
      rs.credits,
      COALESCE(s.first_name, 'Anonymous') AS fname,
      ROW_NUMBER() OVER (ORDER BY rs.completed DESC, rs.credits DESC, rs.referrer_id) AS rn
    FROM referrer_stats rs
    LEFT JOIN public.student s ON s.id = rs.referrer_id
  )
  SELECT 
    rn::INTEGER AS rank,
    fname AS first_name,
    completed::INTEGER AS completed_count,
    credits::INTEGER AS total_credits_earned,
    (referrer_id = v_user_id) AS is_current_user
  FROM ranked
  WHERE rn <= v_safe_limit
  ORDER BY rn;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_referral_stats()
 RETURNS TABLE(referral_code text, total_referrals integer, pending_referrals integer, completed_referrals integer, total_credits_earned integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_code TEXT;
  v_is_student BOOLEAN;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Check if user is a student
  SELECT EXISTS (SELECT 1 FROM public.student WHERE id = v_user_id) INTO v_is_student;
  IF NOT v_is_student THEN
    RAISE EXCEPTION 'Referral stats are only available for talent accounts';
  END IF;
  
  -- Get user's referral code (create if doesn't exist)
  SELECT rc.code INTO v_code FROM public.referral_codes rc WHERE rc.user_id = v_user_id;
  
  -- Calculate stats
  RETURN QUERY
  SELECT
    v_code,
    COALESCE((SELECT COUNT(*)::INTEGER FROM public.referrals WHERE referrer_id = v_user_id), 0),
    COALESCE((SELECT COUNT(*)::INTEGER FROM public.referrals WHERE referrer_id = v_user_id AND status = 'pending'), 0),
    COALESCE((SELECT COUNT(*)::INTEGER FROM public.referrals WHERE referrer_id = v_user_id AND status = 'completed'), 0),
    COALESCE((SELECT SUM(referrer_credits)::INTEGER FROM public.referrals WHERE referrer_id = v_user_id AND status = 'completed'), 0);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_total_cost(user_uuid uuid)
 RETURNS numeric
 LANGUAGE sql
 STABLE
 SET search_path TO 'public'
AS $function$
  SELECT COALESCE(SUM(total_cost), 0.00)
  FROM gpt_tokens
  WHERE user_id = user_uuid;
$function$
;

CREATE OR REPLACE FUNCTION public.grant_daily_credits(p_user_id uuid)
 RETURNS TABLE(success boolean, credits_granted integer, new_balance integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_credits_amount INTEGER := 50;
  v_new_balance INTEGER;
BEGIN
  -- SECURITY FIX: Verify user can only grant credits to themselves
  IF p_user_id != auth.uid() THEN
    RAISE EXCEPTION 'Unauthorized: can only grant daily credits to yourself';
  END IF;

  -- Try to insert daily grant (will fail if already claimed today)
  INSERT INTO public.daily_credit_grants (user_id, granted_date, credits_amount)
  VALUES (p_user_id, CURRENT_DATE, v_credits_amount)
  ON CONFLICT (user_id, granted_date) DO NOTHING;
  
  -- Check if we actually inserted (granted credits today)
  IF NOT FOUND THEN
    -- Already claimed today
    SELECT balance INTO v_new_balance
    FROM public.user_credits
    WHERE user_id = p_user_id;
    
    RETURN QUERY SELECT FALSE, 0, COALESCE(v_new_balance, 0);
    RETURN;
  END IF;
  
  -- Add credits to balance
  INSERT INTO public.user_credits (user_id, balance, total_earned, last_updated)
  VALUES (p_user_id, v_credits_amount, v_credits_amount, now())
  ON CONFLICT (user_id) DO UPDATE SET
    balance = user_credits.balance + v_credits_amount,
    total_earned = user_credits.total_earned + v_credits_amount,
    last_updated = now()
  RETURNING user_credits.balance INTO v_new_balance;
  
  RETURN QUERY SELECT TRUE, v_credits_amount, v_new_balance;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth', 'extensions'
AS $function$
DECLARE
  user_role TEXT;
  v_token TEXT;
BEGIN
  user_role := NEW.raw_user_meta_data ->> 'role';

  -- Create student or company record based on role
  IF user_role = 'student' THEN
    INSERT INTO public.student (id, mail_adress)
    VALUES (NEW.id, NEW.email);
  ELSIF user_role = 'company' THEN
    INSERT INTO public.company (id, mail_adress)
    VALUES (NEW.id, NEW.email);
  END IF;

  -- Generate API token for external bot access (64-char hex for Python app)
  v_token := encode(extensions.gen_random_bytes(32), 'hex');
  INSERT INTO public.api_tokens (user_id, token)
  VALUES (NEW.id, v_token);

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_api_call(p_user_id uuid, p_endpoint text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_log_id UUID;
BEGIN
  -- SECURITY FIX: Verify user can only log calls for themselves
  -- Allow service_role to log for any user (needed for server-side operations)
  IF NOT public.is_service_role() AND p_user_id != auth.uid() THEN
    RAISE EXCEPTION 'Unauthorized: can only log API calls for yourself';
  END IF;

  INSERT INTO api_call_log (user_id, endpoint)
  VALUES (p_user_id, p_endpoint)
  RETURNING id INTO v_log_id;

  RETURN v_log_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.protect_immutable_columns()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Protect primary key (id) - skip tables with composite keys or special cases
  -- resume table uses student_id as PK, not id
  IF TG_TABLE_NAME NOT IN ('credit_purchases', 'user_credits', 'daily_credit_grants', 'resume') THEN
    IF OLD.id IS DISTINCT FROM NEW.id THEN
      RAISE EXCEPTION 'Cannot update primary key column: id';
    END IF;
  END IF;
  
  -- Protect created_at timestamp (skip tables that don't have this column)
  IF TG_TABLE_NAME NOT IN ('signup_ip_tracking', 'api_call_log', 'credit_purchases', 
                            'user_credits', 'daily_credit_grants') THEN
    IF OLD.created_at IS DISTINCT FROM NEW.created_at THEN
      RAISE EXCEPTION 'Cannot update immutable column: created_at';
    END IF;
  END IF;
  
  -- Protect foreign keys based on column existence
  IF TG_TABLE_NAME IN ('academic', 'experience', 'project', 'skill', 'language', 
                        'publication', 'certification', 'social_link', 'resume',
                        'student_profile_draft', 'student_work_preferences') THEN
    IF OLD.student_id IS DISTINCT FROM NEW.student_id THEN
      RAISE EXCEPTION 'Cannot update foreign key column: student_id';
    END IF;
  END IF;
  
  IF TG_TABLE_NAME IN ('company_offer', 'company_offer_draft') THEN
    IF OLD.company_id IS DISTINCT FROM NEW.company_id THEN
      RAISE EXCEPTION 'Cannot update foreign key column: company_id';
    END IF;
  END IF;
  
  IF TG_TABLE_NAME IN ('offer_skills', 'offer_locations', 'offer_responsibilities',
                        'offer_capabilities', 'offer_questions', 'offer_perks') THEN
    IF OLD.offer_id IS DISTINCT FROM NEW.offer_id THEN
      RAISE EXCEPTION 'Cannot update foreign key column: offer_id';
    END IF;
  END IF;
  
  IF TG_TABLE_NAME = 'application' THEN
    IF OLD.student_id IS DISTINCT FROM NEW.student_id THEN
      RAISE EXCEPTION 'Cannot update foreign key column: student_id';
    END IF;
    IF OLD.offer_id IS DISTINCT FROM NEW.offer_id THEN
      RAISE EXCEPTION 'Cannot update foreign key column: offer_id';
    END IF;
  END IF;
  
  IF TG_TABLE_NAME IN ('api_tokens', 'api_call_log', 'user_credits', 
                        'daily_credit_grants', 'credit_purchases') THEN
    IF OLD.user_id IS DISTINCT FROM NEW.user_id THEN
      RAISE EXCEPTION 'Cannot update foreign key column: user_id';
    END IF;
  END IF;
  
  -- Protect Stripe idempotency keys (allow NULL  value once, but not value  different value)
  IF TG_TABLE_NAME = 'credit_purchases' THEN
    -- stripe_event_id: Allow NULL  value, block value  different value
    IF OLD.stripe_event_id IS NOT NULL AND OLD.stripe_event_id IS DISTINCT FROM NEW.stripe_event_id THEN
      RAISE EXCEPTION 'Cannot update idempotency key: stripe_event_id (already set)';
    END IF;
    -- stripe_payment_intent_id: Allow NULL  value, block value  different value
    IF OLD.stripe_payment_intent_id IS NOT NULL AND OLD.stripe_payment_intent_id IS DISTINCT FROM NEW.stripe_payment_intent_id THEN
      RAISE EXCEPTION 'Cannot update idempotency key: stripe_payment_intent_id (already set)';
    END IF;
    -- stripe_checkout_session_id: Allow NULL  value, block value  different value
    IF OLD.stripe_checkout_session_id IS NOT NULL AND OLD.stripe_checkout_session_id IS DISTINCT FROM NEW.stripe_checkout_session_id THEN
      RAISE EXCEPTION 'Cannot update idempotency key: stripe_checkout_session_id (already set)';
    END IF;
  END IF;
  
  -- Protect daily grant composite key
  IF TG_TABLE_NAME = 'daily_credit_grants' THEN
    IF OLD.granted_date IS DISTINCT FROM NEW.granted_date THEN
      RAISE EXCEPTION 'Cannot update composite key column: granted_date';
    END IF;
  END IF;
  
  -- Protect API token
  IF TG_TABLE_NAME = 'api_tokens' THEN
    IF OLD.token IS DISTINCT FROM NEW.token THEN
      RAISE EXCEPTION 'Cannot update immutable column: token';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.publish_offer_draft(p_draft_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_draft company_offer_draft%ROWTYPE;
  v_offer_id UUID;
  v_company_id UUID;
  v_skill JSONB;
  v_location JSONB;
  v_responsibility JSONB;
  v_capability JSONB;
  v_question JSONB;
  v_perk JSONB;
BEGIN
  -- Get the draft data and verify ownership
  SELECT * INTO v_draft
  FROM company_offer_draft
  WHERE id = p_draft_id AND company_id = (SELECT auth.uid());

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Draft not found or access denied';
  END IF;

  -- Validate required fields
  IF v_draft.basic_info->>'position_name' IS NULL OR v_draft.basic_info->>'position_name' = '' THEN
    RAISE EXCEPTION 'Position name is required';
  END IF;

  v_company_id := v_draft.company_id;

  -- Determine if this is an update or new offer
  IF v_draft.offer_id IS NOT NULL THEN
    -- Updating existing offer
    v_offer_id := v_draft.offer_id;
    
    -- Update main offer record
    UPDATE company_offer SET
      position_name = v_draft.basic_info->>'position_name',
      description = v_draft.basic_info->>'description',
      salary_min = NULLIF(v_draft.compensation->>'salary_min', '')::integer,
      salary_max = NULLIF(v_draft.compensation->>'salary_max', '')::integer,
      salary_currency = COALESCE(v_draft.compensation->>'salary_currency', 'EUR'),
      salary_period = v_draft.compensation->>'salary_period',
      equity = COALESCE((v_draft.compensation->>'equity')::boolean, false),
      equity_range = NULLIF(v_draft.compensation->>'equity_range', ''),
      remote_mode = v_draft.work_config->>'remote_mode',
      employment_type = v_draft.work_config->>'employment_type',
      availability = v_draft.work_config->>'availability',
      seniority = v_draft.seniority,
      status = 'published',
      published_at = now()
    WHERE id = v_offer_id AND company_id = v_company_id;

  ELSE
    -- Creating new offer
    INSERT INTO company_offer (
      company_id,
      position_name,
      description,
      salary_min,
      salary_max,
      salary_currency,
      salary_period,
      equity,
      equity_range,
      remote_mode,
      employment_type,
      availability,
      seniority,
      status,
      published_at
    ) VALUES (
      v_company_id,
      v_draft.basic_info->>'position_name',
      v_draft.basic_info->>'description',
      NULLIF(v_draft.compensation->>'salary_min', '')::integer,
      NULLIF(v_draft.compensation->>'salary_max', '')::integer,
      COALESCE(v_draft.compensation->>'salary_currency', 'EUR'),
      v_draft.compensation->>'salary_period',
      COALESCE((v_draft.compensation->>'equity')::boolean, false),
      NULLIF(v_draft.compensation->>'equity_range', ''),
      v_draft.work_config->>'remote_mode',
      v_draft.work_config->>'employment_type',
      v_draft.work_config->>'availability',
      v_draft.seniority,
      'published',
      now()
    )
    RETURNING id INTO v_offer_id;
  END IF;

  -- Delete existing child records (for both new and update scenarios)
  DELETE FROM offer_skills WHERE offer_id = v_offer_id;
  DELETE FROM offer_locations WHERE offer_id = v_offer_id;
  DELETE FROM offer_responsibilities WHERE offer_id = v_offer_id;
  DELETE FROM offer_capabilities WHERE offer_id = v_offer_id;
  DELETE FROM offer_questions WHERE offer_id = v_offer_id;
  DELETE FROM offer_perks WHERE offer_id = v_offer_id;

  -- Insert skills
  FOR v_skill IN SELECT * FROM jsonb_array_elements(v_draft.skills)
  LOOP
    -- Only insert non-empty skills
    IF v_skill->>'skill_text' IS NOT NULL AND v_skill->>'skill_text' != '' THEN
      INSERT INTO offer_skills (
        offer_id,
        skill_slug,
        skill_text,
        importance,
        level,
        years
      ) VALUES (
        v_offer_id,
        COALESCE(v_skill->>'skill_slug', ''),
        v_skill->>'skill_text',
        COALESCE(v_skill->>'importance', 'must'),
        NULLIF(v_skill->>'level', ''),
        NULLIF(v_skill->>'years', '')::integer
      );
    END IF;
  END LOOP;

  -- Insert locations
  FOR v_location IN SELECT * FROM jsonb_array_elements(v_draft.locations)
  LOOP
    -- Only insert locations with at least city or country
    IF v_location->>'city' IS NOT NULL OR v_location->>'country' IS NOT NULL THEN
      INSERT INTO offer_locations (
        offer_id,
        city,
        country
      ) VALUES (
        v_offer_id,
        NULLIF(v_location->>'city', ''),
        NULLIF(v_location->>'country', '')
      );
    END IF;
  END LOOP;

  -- Insert responsibilities
  FOR v_responsibility IN SELECT * FROM jsonb_array_elements(v_draft.responsibilities)
  LOOP
    -- Only insert non-empty responsibilities
    IF v_responsibility->>'text' IS NOT NULL AND v_responsibility->>'text' != '' THEN
      INSERT INTO offer_responsibilities (
        offer_id,
        text
      ) VALUES (
        v_offer_id,
        v_responsibility->>'text'
      );
    END IF;
  END LOOP;

  -- Insert capabilities
  FOR v_capability IN SELECT * FROM jsonb_array_elements(v_draft.capabilities)
  LOOP
    -- Only insert non-empty capabilities
    IF v_capability->>'text' IS NOT NULL AND v_capability->>'text' != '' THEN
      INSERT INTO offer_capabilities (
        offer_id,
        text,
        importance
      ) VALUES (
        v_offer_id,
        v_capability->>'text',
        COALESCE(v_capability->>'importance', 'must')
      );
    END IF;
  END LOOP;

  -- Insert questions
  FOR v_question IN SELECT * FROM jsonb_array_elements(v_draft.questions)
  LOOP
    -- Only insert non-empty questions
    IF v_question->>'question' IS NOT NULL AND v_question->>'question' != '' THEN
      INSERT INTO offer_questions (
        offer_id,
        question
      ) VALUES (
        v_offer_id,
        v_question->>'question'
      );
    END IF;
  END LOOP;

  -- Insert perks
  FOR v_perk IN SELECT * FROM jsonb_array_elements(v_draft.perks)
  LOOP
    -- Only insert non-empty perks
    IF v_perk->>'text' IS NOT NULL AND v_perk->>'text' != '' THEN
      INSERT INTO offer_perks (
        offer_id,
        text
      ) VALUES (
        v_offer_id,
        v_perk->>'text'
      );
    END IF;
  END LOOP;

  -- Link draft to published offer (for future edits)
  UPDATE company_offer_draft
  SET offer_id = v_offer_id,
      status = 'ready_to_publish'
  WHERE id = p_draft_id;

  -- Return the published offer ID
  RETURN v_offer_id;

EXCEPTION
  WHEN OTHERS THEN
    -- Rollback happens automatically in PostgreSQL functions
    RAISE EXCEPTION 'Failed to publish offer: %', SQLERRM;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
begin
  new.updated_at = now();
  return new;
end; 
$function$
;

CREATE OR REPLACE FUNCTION public.update_feedback_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_token_last_used(p_token text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- SECURITY FIX: This function should only be called from server-side
  IF NOT public.is_service_role() THEN
    RAISE EXCEPTION 'Unauthorized: service role required for token operations';
  END IF;

  UPDATE public.api_tokens
  SET last_used_at = now()
  WHERE token = p_token;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_token_usage(p_token text, p_tokens_used integer, p_cost_usd numeric)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- SECURITY FIX: This function should only be called from server-side
  IF NOT public.is_service_role() THEN
    RAISE EXCEPTION 'Unauthorized: service role required for token operations';
  END IF;

  UPDATE public.api_tokens
  SET 
    total_tokens_used = total_tokens_used + p_tokens_used,
    total_cost_usd = total_cost_usd + p_cost_usd,
    last_used_at = now()
  WHERE token = p_token;
END;
$function$
;

drop trigger if exists "objects_delete_delete_prefix" on "storage"."objects";

drop trigger if exists "objects_insert_create_prefix" on "storage"."objects";

drop trigger if exists "objects_update_create_prefix" on "storage"."objects";

drop trigger if exists "prefixes_create_hierarchy" on "storage"."prefixes";

drop trigger if exists "prefixes_delete_hierarchy" on "storage"."prefixes";

CREATE TRIGGER protect_buckets_delete BEFORE DELETE ON storage.buckets FOR EACH STATEMENT EXECUTE FUNCTION storage.protect_delete();

CREATE TRIGGER protect_objects_delete BEFORE DELETE ON storage.objects FOR EACH STATEMENT EXECUTE FUNCTION storage.protect_delete();


