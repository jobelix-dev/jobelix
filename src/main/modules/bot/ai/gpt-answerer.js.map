{
  "version": 3,
  "sources": ["gpt-answerer.ts"],
  "sourcesContent": ["/**\n * GPT Answerer - AI-powered form response generator\n * \n * Uses the backend API to generate contextually appropriate responses\n * to LinkedIn Easy Apply form questions.\n * \n * Mirrors the Python GPTAnswerer class.\n */\n\nimport type { \n  Resume, \n  Job, \n  ChatMessage, \n  ChatCompletionRequest, \n  ChatCompletionResponse \n} from '../types';\nimport { getResumeSection, resumeToNarrative } from '../models/resume';\nimport { tailorResumePipeline } from './resume-tailoring';\nimport { createLogger } from '../utils/logger';\nimport { StatusReporter } from '../utils/status-reporter';\nimport { BackendAPIClient } from './backend-client';\nimport { llmLogger } from '../utils/llm-logger';\nimport { stripMarkdownCodeBlock, findBestMatch, extractNumber } from '../utils/string-utils';\nimport * as prompts from './prompts';\n\nconst log = createLogger('GPTAnswerer');\n\nexport class GPTAnswerer {\n  // Public resume field - accessed by field handlers for smart matching\n  public resume: Resume | null = null;\n  private job: Job | null = null;\n  private client: BackendAPIClient;\n\n\n  constructor(\n    private apiToken: string,\n    private apiUrl: string,\n    private reporter?: StatusReporter\n  ) {\n    this.client = new BackendAPIClient({\n      token: apiToken,\n      apiUrl: apiUrl,\n      logRequests: true,\n    });\n    log.info('GPTAnswerer initialized with backend API client');\n  }\n\n  /**\n   * Set the resume for context\n   */\n  setResume(resume: Resume): void {\n    this.resume = resume;\n    log.debug(`Resume set: ${resume.personalInformation.name} ${resume.personalInformation.surname}`);\n  }\n\n  /**\n   * Set the current job being applied to\n   */\n  setJob(job: Job): void {\n    this.job = job;\n    log.debug(`Job set: ${job.title} at ${job.company}`);\n  }\n\n  /**\n   * Get the current job description\n   */\n  get jobDescription(): string {\n    return this.job?.description || '';\n  }\n\n  /** Make a chat completion request with automatic retry */\n  private async chatCompletion(messages: ChatMessage[], temperature = 0.8): Promise<string> {\n    const maxRetries = 2;\n    let lastErr: unknown = null;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const response = await this.client.chatCompletion(messages, 'gpt-4o-mini', temperature);\n        \n        llmLogger.logRequest(messages, response.content, response.usage, response.model, response.finish_reason);\n        if (this.reporter) this.reporter.incrementCreditsUsed();\n\n        return response.content;\n      } catch (err) {\n        lastErr = err;\n        log.error(`Chat completion attempt ${attempt + 1} failed: ${String(err)}`);\n        if (attempt === 0) log.error(`Backend URL: ${this.apiUrl}`);\n        if (attempt < maxRetries) await new Promise(r => setTimeout(r, 500 * (attempt + 1)));\n      }\n    }\n\n    log.error(`All chat completion attempts failed. Verify backend at: ${this.apiUrl}`);\n    throw lastErr;\n  }\n\n  /** Generic JSON retry helper for GPT responses */\n  private async chatCompletionWithJsonValidation<T>(\n    prompt: string,\n    validator: (json: T) => boolean,\n    temperature = 0.3,\n    maxRetries = 2\n  ): Promise<T> {\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const response = await this.chatCompletion([{ role: 'user', content: prompt }], temperature);\n        const parsed = JSON.parse(response) as T;\n        if (validator(parsed)) return parsed;\n        throw new Error('Validation failed');\n      } catch (e) {\n        log.warn(`JSON attempt ${attempt + 1}/${maxRetries + 1} failed: ${e}`);\n        if (attempt >= maxRetries) throw new Error(`Failed after ${maxRetries + 1} attempts: ${e}`);\n      }\n    }\n    throw new Error('Unexpected failure');\n  }\n\n  /** Answer from multiple choice options */\n  async answerFromOptions(question: string, options: string[]): Promise<string> {\n    log.debug(`Answering from options: ${question}`);\n\n    const prompt = prompts.optionsTemplate\n      .replace('{resume}', resumeToNarrative(this.resume!))\n      .replace('{question}', question)\n      .replace('{options}', options.join('\\n'));\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }]);\n    const answer = response.trim();\n\n    // Find best match from options (handles slight variations)\n    const bestMatch = findBestMatch(answer, options);\n    log.info(`Answer: ${bestMatch}`);\n    return bestMatch;\n  }\n\n  /**\n   * Answer a question from options with retry after error (MATCHES PYTHON)\n   */\n  async answerFromOptionsWithRetry(\n    question: string,\n    options: string[],\n    previousAnswer: string,\n    errorMessage: string\n  ): Promise<string> {\n    log.debug(`Retrying answer: previous=\"${previousAnswer}\", error=\"${errorMessage}\"`);\n\n    // Enhanced prompt with error context - matches Python\n    const prompt = `You previously answered a job application question incorrectly.\n\nQuestion: ${question}\n\nYour previous answer: ${previousAnswer}\nError received: ${errorMessage}\n\nAvailable options:\n${options.join('\\n')}\n\nBased on my resume:\n${resumeToNarrative(this.resume!)}\n\nPlease select a DIFFERENT option that addresses the error. Respond with ONLY the exact text of the chosen option.`;\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }]);\n    const answer = response.trim();\n\n    return findBestMatch(answer, options);\n  }\n\n  /**\n   * Answer a checkbox/multiple-choice question directly (no section routing)\n   * \n   * Used for questions like \"How did you hear about us?\" where the answer\n   * is NOT based on resume content but rather a simple selection.\n   * \n   * MATCHES PYTHON: answer_question_textual_wide_range with direct prompt\n   */\n  async answerCheckboxQuestion(prompt: string): Promise<string> {\n    log.debug(`Answering checkbox question: ${prompt.substring(0, 50)}...`);\n    \n    const response = await this.chatCompletion([{ role: 'user', content: prompt }]);\n    log.info(`Checkbox answer: ${response.trim()}`);\n    return response.trim();\n  }\n\n  /**\n   * Answer a textual/open-ended question\n   */\n  async answerTextual(question: string): Promise<string> {\n    log.debug(`Answering textual: ${question.substring(0, 50)}...`);\n\n    // Determine which resume section is relevant\n    const section = await this.determineResumeSection(question);\n    log.debug(`Selected section: ${section}`);\n\n    // Handle cover letter specially\n    if (section === 'cover_letter') {\n      return this.generateCoverLetter();\n    }\n\n    const resumeSection = getResumeSection(this.resume!, section);\n    const template = this.getTemplateForSection(section);\n\n    const prompt = template\n      .replace('{resume_section}', resumeSection)\n      .replace('{question}', question)\n      .replace('{resume}', resumeToNarrative(this.resume!))\n      .replace('{job_description}', this.jobDescription)\n      .replace('{pronouns}', this.resume!.selfIdentification.pronouns)\n      .replace('{experience_summary}', this.getExperienceSummary());\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }]);\n    log.info(`Textual answer length: ${response.length} chars`);\n    return response.trim();\n  }\n\n  /**\n   * Answer a textual question with retry after error\n   */\n  async answerTextualWithRetry(\n    question: string,\n    previousAnswer: string,\n    errorMessage: string\n  ): Promise<string> {\n    log.debug(`Retrying textual: previous answer failed with \"${errorMessage}\"`);\n\n    const prompt = `I previously answered a job application question incorrectly.\n\nQuestion: \"${question}\"\n\nMy previous answer: \"${previousAnswer}\"\nError received: \"${errorMessage}\"\n\nBased on my resume:\n${resumeToNarrative(this.resume!)}\n\nYour previous answer was REJECTED. Please provide a corrected answer that addresses the error.\nRespond with only the answer (no explanation, just the text).`;\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }]);\n    return response.trim();\n  }\n\n  /**\n   * Answer a numeric question (e.g., years of experience)\n   */\n  async answerNumeric(question: string, defaultValue = 3): Promise<number> {\n    log.debug(`Answering numeric: ${question}`);\n\n    const prompt = prompts.numericQuestionTemplate\n      .replace('{resume}', resumeToNarrative(this.resume!))\n      .replace('{question}', question)\n      .replace('{default_experience}', String(defaultValue));\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }], 0.3);\n    \n    const result = extractNumber(response) ?? defaultValue;\n    log.info(`Numeric answer: ${result}`);\n    return result;\n  }\n\n  /**\n   * Answer a numeric question with retry after error (MATCHES PYTHON)\n   */\n  async answerNumericWithRetry(\n    question: string,\n    previousAnswer: string,\n    errorMessage: string,\n    defaultValue = 3\n  ): Promise<number> {\n    log.debug(`Retrying numeric: previous=\"${previousAnswer}\", error=\"${errorMessage}\"`);\n\n    const prompt = `You previously answered a numeric job application question incorrectly.\n\nQuestion: ${question}\n\nYour previous answer: ${previousAnswer}\nError received: ${errorMessage}\n\nBased on my resume:\n${resumeToNarrative(this.resume!)}\n\nYour previous answer was REJECTED. Please provide a corrected numeric answer that addresses the error message.\nRespond with ONLY a number (no explanation, no text, just the number).`;\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }], 0.3);\n    \n    const match = response.match(/\\d+/);\n    const result = match ? parseInt(match[0], 10) : defaultValue;\n    \n    log.info(`Numeric retry answer: ${result}`);\n    return result;\n  }\n\n  /**\n   * Tailor resume to a specific job using 4-stage pipeline (MATCHES PYTHON)\n   * \n   * Pipeline stages:\n   * 1. Extract keywords from job description\n   * 2. Score all resume items by relevance\n   * 3. Filter top items with dynamic thresholds\n   * 4. Optimize keywords in filtered resume\n   * \n   * Falls back to old single-prompt method if any stage fails.\n   */\n  async tailorResumeToJob(jobDescription: string, baseResumeYaml: string): Promise<string> {\n    const result = await tailorResumePipeline(this, jobDescription, baseResumeYaml);\n    \n    if (result.success) {\n      return result.tailoredYaml;\n    }\n    \n    // Pipeline failed - use fallback\n    log.info('\u26A0\uFE0F  Falling back to old single-prompt tailoring method');\n    return this.tailorResumeOldMethod(jobDescription, baseResumeYaml);\n  }\n\n  /**\n   * Legacy single-prompt resume tailoring (fallback only)\n   */\n  private async tailorResumeOldMethod(jobDescription: string, baseConfig: string): Promise<string> {\n    log.info('Using legacy single-prompt tailoring');\n\n    const prompt = prompts.resumeTailoringTemplate\n      .replace('{job_description}', jobDescription)\n      .replace('{base_config}', baseConfig);\n\n    try {\n      const response = await this.chatCompletion([{ role: 'user', content: prompt }], 0.5);\n      const tailoredConfig = stripMarkdownCodeBlock(response);\n      \n      log.info('Resume tailoring completed successfully');\n      return tailoredConfig;\n      \n    } catch (e) {\n      log.warn(`Failed to tailor resume config: ${e}`);\n      log.debug('Returning original config as fallback');\n      return baseConfig;\n    }\n  }\n\n  /** Extract key terms from job description (Stage 1) */\n  async extractJobKeywords(jobDescription: string): Promise<string> {\n    log.info('Extracting keywords from job description');\n\n    const prompt = prompts.jobKeywordExtractionTemplate.replace('{job_description}', jobDescription);\n    const requiredKeys = ['technical_skills', 'soft_skills', 'domain_terms', 'action_verbs'];\n\n    const result = await this.chatCompletionWithJsonValidation<Record<string, string[]>>(\n      prompt,\n      (dict) => requiredKeys.every(key => key in dict),\n      0.3\n    );\n\n    // Deduplicate keywords\n    for (const key of Object.keys(result)) {\n      if (Array.isArray(result[key])) result[key] = [...new Set(result[key])];\n    }\n\n    log.info('Keyword extraction completed');\n    return JSON.stringify(result, null, 2);\n  }\n\n  /** Score resume items by job relevance (Stage 2) */\n  async scoreResumeForJob(jobDescription: string, resumeYaml: string): Promise<string> {\n    log.info('Scoring resume items for job relevance');\n\n    const prompt = prompts.resumeScoringTemplate\n      .replace('{job_description}', jobDescription)\n      .replace('{resume_yaml}', resumeYaml);\n\n    const result = await this.chatCompletionWithJsonValidation<Record<string, unknown>>(\n      prompt,\n      () => true,  // Any valid JSON is acceptable\n      0.3\n    );\n\n    log.info('Resume scoring completed');\n    return JSON.stringify(result);\n  }\n\n  /** Optimize resume keywords for job (Stage 4) */\n  async optimizeResumeKeywords(\n    jobDescription: string,\n    filteredConfig: string,\n    extractedKeywords = ''\n  ): Promise<string> {\n    log.info('Optimizing resume keywords');\n\n    const prompt = prompts.resumeKeywordOptimizationTemplate\n      .replace('{job_description}', jobDescription)\n      .replace('{filtered_config}', filteredConfig)\n      .replace('{extracted_keywords}', extractedKeywords || '(none)');\n\n    try {\n      // Temperature 0.8 matches Python for creative rewriting\n      const response = await this.chatCompletion([{ role: 'user', content: prompt }], 0.8);\n      return stripMarkdownCodeBlock(response);\n    } catch (e) {\n      log.warn(`Keyword optimization failed: ${e}`);\n      return filteredConfig;\n    }\n  }\n\n  /** Determine which resume section is relevant for a question */\n  private async determineResumeSection(question: string): Promise<string> {\n    const prompt = `For the question: \"${question}\", which resume section is relevant?\n\nSections: Personal information, Self Identification, Legal Authorization, Work Preferences,\nEducation Details, Experience Details, Projects, Availability, Salary Expectations,\nCertifications, Languages, Interests, Cover letter\n\nRouting: 'why interested' \u2192 Interests | technical experience \u2192 Experience Details | \n'about yourself' \u2192 Personal information | remote/office \u2192 Work Preferences\n\nRespond with ONLY the section name.`;\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }], 0.3);\n    let section = response.trim().toLowerCase().replace(/\\*\\*/g, '').replace(/ /g, '_');\n\n    const validSections = [\n      'personal_information', 'self_identification', 'legal_authorization',\n      'work_preferences', 'education_details', 'experience_details',\n      'projects', 'availability', 'salary_expectations', 'certifications',\n      'languages', 'interests', 'cover_letter'\n    ];\n\n    if (!validSections.includes(section)) {\n      section = validSections.find(s => section.includes(s) || s.includes(section)) || 'personal_information';\n    }\n    return section;\n  }\n\n  /** Get prompt template for a resume section */\n  private getTemplateForSection(section: string): string {\n    const templates: Record<string, string> = {\n      personal_information: prompts.personalInformationTemplate,\n      self_identification: prompts.selfIdentificationTemplate,\n      legal_authorization: prompts.legalAuthorizationTemplate,\n      work_preferences: prompts.workPreferencesTemplate,\n      education_details: prompts.educationDetailsTemplate,\n      experience_details: prompts.experienceDetailsTemplate,\n      projects: prompts.projectsTemplate,\n      availability: prompts.availabilityTemplate,\n      salary_expectations: prompts.salaryExpectationsTemplate,\n      certifications: prompts.certificationsTemplate,\n      languages: prompts.languagesTemplate,\n      interests: prompts.interestsTemplate,\n    };\n    return templates[section] || prompts.personalInformationTemplate;\n  }\n\n  /** Generate a cover letter */\n  private async generateCoverLetter(): Promise<string> {\n    const prompt = prompts.coverLetterTemplate\n      .replace('{resume}', resumeToNarrative(this.resume!))\n      .replace('{job_description}', this.jobDescription);\n    return this.chatCompletion([{ role: 'user', content: prompt }]);\n  }\n\n  /** Get brief experience summary */\n  private getExperienceSummary(): string {\n    if (!this.resume?.experienceDetails?.length) return '';\n    const recent = this.resume.experienceDetails[0];\n    return `${recent.position} at ${recent.company}`;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
