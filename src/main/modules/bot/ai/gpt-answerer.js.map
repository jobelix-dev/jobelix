{
  "version": 3,
  "sources": ["gpt-answerer.ts"],
  "sourcesContent": ["/**\n * GPT Answerer - AI-powered form response generator\n * \n * Uses the backend API to generate contextually appropriate responses\n * to LinkedIn Easy Apply form questions.\n * \n * Mirrors the Python GPTAnswerer class.\n */\n\nimport type { \n  Resume, \n  Job, \n  ChatMessage, \n  ChatCompletionRequest, \n  ChatCompletionResponse \n} from '../types';\nimport { getResumeSection, resumeToNarrative } from '../models/resume';\nimport { createLogger } from '../utils/logger';\nimport { StatusReporter } from '../utils/status-reporter';\nimport * as prompts from './prompts/templates';\n\nconst log = createLogger('GPTAnswerer');\n\nexport class GPTAnswerer {\n  private resume: Resume | null = null;\n  private job: Job | null = null;\n\n  constructor(\n    private apiToken: string,\n    private apiUrl: string,\n    private reporter?: StatusReporter\n  ) {\n    log.info('GPTAnswerer initialized with backend API');\n  }\n\n  /**\n   * Set the resume for context\n   */\n  setResume(resume: Resume): void {\n    this.resume = resume;\n    log.debug(`Resume set: ${resume.personalInformation.name} ${resume.personalInformation.surname}`);\n  }\n\n  /**\n   * Set the current job being applied to\n   */\n  setJob(job: Job): void {\n    this.job = job;\n    log.debug(`Job set: ${job.title} at ${job.company}`);\n  }\n\n  /**\n   * Get the current job description\n   */\n  get jobDescription(): string {\n    return this.job?.description || '';\n  }\n\n  /**\n   * Make a chat completion request to the backend API\n   */\n  private async chatCompletion(messages: ChatMessage[], temperature = 0.8): Promise<string> {\n     // Build two possible request shapes depending on backend endpoint\n     // - Next.js route (/api/autoapply/gpt4) expects { token, messages, temperature }\n     // - Generic backend proxy expects { messages, model, temperature } and Authorization header\n \n     // Use global fetch if available. Runtime (Electron main) must provide a fetch implementation\n     // (Node 18+ includes fetch, or install 'undici' and polyfill). If not present, fail early with clear error.\n     const fetchFn: any = (globalThis as any).fetch;\n     if (!fetchFn) {\n      const msg = 'Global fetch is not available in this runtime. Run on Node 18+ or install & polyfill undici.';\n      log.error(msg);\n      throw new Error(msg);\n     }\n \n     const isNextJsApi = this.apiUrl.includes('/api/autoapply/gpt4') || this.apiUrl.endsWith('/gpt4');\n \n     const maxRetries = 2;\n     let lastErr: any = null;\n \n     for (let attempt = 0; attempt <= maxRetries; attempt++) {\n       try {\n         const headers: Record<string, string> = { 'Content-Type': 'application/json' };\n         let body: any;\n \n         if (isNextJsApi) {\n           // Server route expects token in body\n           body = { token: this.apiToken, messages, temperature };\n         } else {\n           body = { messages, model: 'gpt-4o-mini', temperature };\n           headers['Authorization'] = `Bearer ${this.apiToken}`;\n         }\n \n        const resp = await fetchFn(this.apiUrl, {\n           method: 'POST',\n           headers,\n           body: JSON.stringify(body),\n           // keep a longer timeout controlled by environment if needed\n         } as any);\n \n         if (!resp.ok) {\n           const text = await resp.text().catch(() => '<failed to read body>');\n           const errMsg = `API request failed: ${resp.status} - ${text}`;\n           throw new Error(errMsg);\n         }\n \n         const data = await resp.json() as ChatCompletionResponse;\n \n         // Track credit usage\n         if (this.reporter) this.reporter.incrementCreditsUsed();\n \n         // Expect response shape: { content: '...' } from our backend route\n         if (typeof data.content === 'string') return data.content;\n \n         // Fallback: if backend returns raw string\n         if (typeof (data as any) === 'string') return (data as any);\n \n         // If unexpected shape, stringify for debugging\n         return JSON.stringify(data);\n       } catch (err) {\n         lastErr = err;\n        log.error(`Chat completion attempt ${attempt + 1} failed: ${String(err)}`);\n         // small backoff before retry\n         if (attempt < maxRetries) await new Promise((r) => setTimeout(r, 500 * (attempt + 1)));\n       }\n     }\n \n     log.error('All chat completion attempts failed');\n     throw lastErr;\n   }\n\n  /**\n   * Answer a question by selecting from multiple choice options (MATCHES PYTHON)\n   */\n  async answerFromOptions(question: string, options: string[]): Promise<string> {\n    log.debug(`Answering from options: ${question}`);\n    log.debug(`Options: ${options.join(', ')}`);\n\n    // Use the proper options template that matches Python\n    const prompt = prompts.optionsTemplate\n      .replace('{resume}', resumeToNarrative(this.resume!))\n      .replace('{question}', question)\n      .replace('{options}', options.join('\\n'));\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }]);\n    const answer = response.trim();\n\n    // Find best match from options (handles slight variations)\n    const bestMatch = this.findBestMatch(answer, options);\n    log.info(`Answer: ${bestMatch}`);\n    return bestMatch;\n  }\n\n  /**\n   * Answer a question from options with retry after error (MATCHES PYTHON)\n   */\n  async answerFromOptionsWithRetry(\n    question: string,\n    options: string[],\n    previousAnswer: string,\n    errorMessage: string\n  ): Promise<string> {\n    log.debug(`Retrying answer: previous=\"${previousAnswer}\", error=\"${errorMessage}\"`);\n\n    // Enhanced prompt with error context - matches Python\n    const prompt = `You previously answered a job application question incorrectly.\n\nQuestion: ${question}\n\nYour previous answer: ${previousAnswer}\nError received: ${errorMessage}\n\nAvailable options:\n${options.join('\\n')}\n\nBased on my resume:\n${resumeToNarrative(this.resume!)}\n\nPlease select a DIFFERENT option that addresses the error. Respond with ONLY the exact text of the chosen option.`;\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }]);\n    const answer = response.trim();\n\n    return this.findBestMatch(answer, options);\n  }\n\n  /**\n   * Answer a textual/open-ended question\n   */\n  async answerTextual(question: string): Promise<string> {\n    log.debug(`Answering textual: ${question.substring(0, 50)}...`);\n\n    // Determine which resume section is relevant\n    const section = await this.determineResumeSection(question);\n    log.debug(`Selected section: ${section}`);\n\n    // Handle cover letter specially\n    if (section === 'cover_letter') {\n      return this.generateCoverLetter();\n    }\n\n    const resumeSection = getResumeSection(this.resume!, section);\n    const template = this.getTemplateForSection(section);\n\n    const prompt = template\n      .replace('{resume_section}', resumeSection)\n      .replace('{question}', question)\n      .replace('{resume}', resumeToNarrative(this.resume!))\n      .replace('{job_description}', this.jobDescription)\n      .replace('{pronouns}', this.resume!.selfIdentification.pronouns)\n      .replace('{experience_summary}', this.getExperienceSummary());\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }]);\n    log.info(`Textual answer length: ${response.length} chars`);\n    return response.trim();\n  }\n\n  /**\n   * Answer a textual question with retry after error\n   */\n  async answerTextualWithRetry(\n    question: string,\n    previousAnswer: string,\n    errorMessage: string\n  ): Promise<string> {\n    log.debug(`Retrying textual: previous answer failed with \"${errorMessage}\"`);\n\n    const prompt = `I previously answered a job application question incorrectly.\n\nQuestion: \"${question}\"\n\nMy previous answer: \"${previousAnswer}\"\nError received: \"${errorMessage}\"\n\nBased on my resume:\n${resumeToNarrative(this.resume!)}\n\nYour previous answer was REJECTED. Please provide a corrected answer that addresses the error.\nRespond with only the answer (no explanation, just the text).`;\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }]);\n    return response.trim();\n  }\n\n  /**\n   * Answer a numeric question (e.g., years of experience)\n   */\n  async answerNumeric(question: string, defaultValue = 3): Promise<number> {\n    log.debug(`Answering numeric: ${question}`);\n\n    const prompt = prompts.numericQuestionTemplate\n      .replace('{resume}', resumeToNarrative(this.resume!))\n      .replace('{question}', question)\n      .replace('{default_experience}', String(defaultValue));\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }], 0.3);\n    \n    // Extract number from response\n    const match = response.match(/\\d+/);\n    const result = match ? parseInt(match[0], 10) : defaultValue;\n    \n    log.info(`Numeric answer: ${result}`);\n    return result;\n  }\n\n  /**\n   * Answer a numeric question with retry after error (MATCHES PYTHON)\n   */\n  async answerNumericWithRetry(\n    question: string,\n    previousAnswer: string,\n    errorMessage: string,\n    defaultValue = 3\n  ): Promise<number> {\n    log.debug(`Retrying numeric: previous=\"${previousAnswer}\", error=\"${errorMessage}\"`);\n\n    const prompt = `You previously answered a numeric job application question incorrectly.\n\nQuestion: ${question}\n\nYour previous answer: ${previousAnswer}\nError received: ${errorMessage}\n\nBased on my resume:\n${resumeToNarrative(this.resume!)}\n\nYour previous answer was REJECTED. Please provide a corrected numeric answer that addresses the error message.\nRespond with ONLY a number (no explanation, no text, just the number).`;\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }], 0.3);\n    \n    const match = response.match(/\\d+/);\n    const result = match ? parseInt(match[0], 10) : defaultValue;\n    \n    log.info(`Numeric retry answer: ${result}`);\n    return result;\n  }\n\n  /**\n   * Tailor resume to a specific job using 4-stage pipeline (MATCHES PYTHON)\n   * \n   * Pipeline stages:\n   * 1. Extract keywords from job description\n   * 2. Score all resume items by relevance\n   * 3. Filter top items with dynamic thresholds\n   * 4. Optimize keywords in filtered resume\n   * \n   * Falls back to old single-prompt method if any stage fails.\n   */\n  async tailorResumeToJob(jobDescription: string, baseResumeYaml: string): Promise<string> {\n    log.info('=== Starting 4-Stage Resume Tailoring Pipeline ===');\n    log.debug(`Job description length: ${jobDescription.length} chars`);\n    log.debug(`Base resume YAML size: ${baseResumeYaml.length} bytes`);\n\n    try {\n      const stage1Start = Date.now();\n      \n      // === STAGE 1: Extract keywords from job description ===\n      log.info('\uD83D\uDD0D Stage 1: Extracting keywords from job description');\n      const keywordsJson = await this.extractJobKeywords(jobDescription);\n      const keywordsDict = JSON.parse(keywordsJson);\n      \n      const stage1Duration = (Date.now() - stage1Start) / 1000;\n      log.info(`\u2713 Stage 1 completed in ${stage1Duration.toFixed(2)}s`);\n      \n      const totalKeywords = Object.values(keywordsDict).reduce(\n        (sum: number, arr: any) => sum + (Array.isArray(arr) ? arr.length : 0), 0\n      );\n      log.info(`Extracted ${totalKeywords} keywords: ${keywordsDict.technical_skills?.length || 0} technical, ${keywordsDict.soft_skills?.length || 0} soft skills`);\n\n      const stage2Start = Date.now();\n      \n      // === STAGE 2: Score all resume items ===\n      log.info('\uD83C\uDFAF Stage 2: Scoring resume items by relevance');\n      const scoresJson = await this.scoreResumeForJob(jobDescription, baseResumeYaml);\n      \n      const stage2Duration = (Date.now() - stage2Start) / 1000;\n      log.info(`\u2713 Stage 2 completed in ${stage2Duration.toFixed(2)}s`);\n\n      const stage4Start = Date.now();\n      \n      // === STAGE 4: Optimize keywords using extracted terms ===\n      // (Stage 3 filtering is simplified in Node.js version - we optimize the full resume)\n      log.info('\u270D\uFE0F  Stage 4: Optimizing keywords and descriptions with target terms');\n      \n      const keywordsFormatted = `Technical Skills: ${keywordsDict.technical_skills?.join(', ') || ''}\nSoft Skills: ${keywordsDict.soft_skills?.join(', ') || ''}\nDomain Terms: ${keywordsDict.domain_terms?.join(', ') || ''}\nAction Verbs: ${keywordsDict.action_verbs?.join(', ') || ''}`;\n\n      const optimizedConfig = await this.optimizeResumeKeywords(\n        jobDescription,\n        baseResumeYaml,\n        keywordsFormatted\n      );\n      \n      const stage4Duration = (Date.now() - stage4Start) / 1000;\n      log.info(`\u2713 Stage 4 completed in ${stage4Duration.toFixed(2)}s`);\n      \n      const totalDuration = stage1Duration + stage2Duration + stage4Duration;\n      log.info(`=== Pipeline completed in ${totalDuration.toFixed(2)}s ===`);\n      \n      return optimizedConfig;\n      \n    } catch (e) {\n      log.warn(`New pipeline failed: ${e}`);\n      log.info('\u26A0\uFE0F  Falling back to old single-prompt tailoring method');\n      \n      return this.tailorResumeOldMethod(jobDescription, baseResumeYaml);\n    }\n  }\n\n  /**\n   * Legacy single-prompt resume tailoring (fallback only)\n   */\n  private async tailorResumeOldMethod(jobDescription: string, baseConfig: string): Promise<string> {\n    log.info('Using legacy single-prompt tailoring');\n\n    const prompt = prompts.resumeTailoringTemplate\n      .replace('{job_description}', jobDescription)\n      .replace('{base_config}', baseConfig);\n\n    try {\n      let tailoredConfig = await this.chatCompletion([{ role: 'user', content: prompt }], 0.5);\n      \n      // Clean up markdown code blocks if present\n      if (tailoredConfig.trim().startsWith('```yaml')) {\n        const lines = tailoredConfig.split('\\n');\n        let startIdx = 0;\n        let endIdx = lines.length;\n        \n        for (let i = 0; i < lines.length; i++) {\n          if (lines[i].trim().startsWith('```yaml')) {\n            startIdx = i + 1;\n          } else if (lines[i].trim() === '```' && i > startIdx) {\n            endIdx = i;\n            break;\n          }\n        }\n        tailoredConfig = lines.slice(startIdx, endIdx).join('\\n');\n      } else if (tailoredConfig.trim().startsWith('```')) {\n        const lines = tailoredConfig.split('\\n');\n        let startIdx = 0;\n        let endIdx = lines.length;\n        \n        for (let i = 0; i < lines.length; i++) {\n          if (lines[i].trim().startsWith('```')) {\n            if (startIdx === 0) {\n              startIdx = i + 1;\n            } else {\n              endIdx = i;\n              break;\n            }\n          }\n        }\n        tailoredConfig = lines.slice(startIdx, endIdx).join('\\n');\n      }\n      \n      log.info('Resume tailoring completed successfully');\n      return tailoredConfig;\n      \n    } catch (e) {\n      log.warn(`Failed to tailor resume config: ${e}`);\n      log.debug('Returning original config as fallback');\n      return baseConfig;\n    }\n  }\n\n  /**\n   * Extract key terms from job description for resume optimization (Stage 1)\n   * \n   * Identifies technical skills, soft skills, domain terms, and action verbs\n   * for ATS optimization.\n   */\n  async extractJobKeywords(jobDescription: string, maxRetries = 2): Promise<string> {\n    log.info('Extracting keywords from job description');\n    log.debug(`Job description length: ${jobDescription.length} chars`);\n\n    const prompt = prompts.jobKeywordExtractionTemplate\n      .replace('{job_description}', jobDescription);\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        if (attempt > 0) {\n          log.info(`Keyword extraction attempt ${attempt + 1}/${maxRetries + 1}`);\n        }\n\n        const keywordsJson = await this.chatCompletion([{ role: 'user', content: prompt }], 0.3);\n        \n        // Validate it's parseable JSON and has expected structure\n        const keywordsDict = JSON.parse(keywordsJson);\n        \n        const requiredKeys = ['technical_skills', 'soft_skills', 'domain_terms', 'action_verbs'];\n        for (const key of requiredKeys) {\n          if (!(key in keywordsDict)) {\n            throw new Error(`Missing required key: ${key}`);\n          }\n        }\n        \n        // Deduplicate keywords within each category\n        for (const key of Object.keys(keywordsDict)) {\n          if (Array.isArray(keywordsDict[key])) {\n            keywordsDict[key] = [...new Set(keywordsDict[key])];\n          }\n        }\n        \n        log.info('Keyword extraction completed successfully');\n        return JSON.stringify(keywordsDict, null, 2);\n        \n      } catch (e) {\n        log.warn(`Attempt ${attempt + 1}: Invalid JSON in keyword response: ${e}`);\n        \n        if (attempt < maxRetries) {\n          log.info(`Retrying keyword extraction (attempt ${attempt + 2}/${maxRetries + 1})`);\n          continue;\n        } else {\n          log.error('All keyword extraction retry attempts failed');\n          throw new Error(`Failed to extract valid keywords after ${maxRetries + 1} attempts: ${e}`);\n        }\n      }\n    }\n    \n    throw new Error('Keyword extraction failed unexpectedly');\n  }\n\n  /**\n   * Score all resume items by relevance to job description (Stage 2)\n   * \n   * Uses lower temperature (0.3) for consistent scoring.\n   * Returns JSON string with scores for all categories.\n   */\n  async scoreResumeForJob(jobDescription: string, resumeYaml: string, maxRetries = 2): Promise<string> {\n    log.info('Scoring resume items for job relevance');\n    log.debug(`Job description length: ${jobDescription.length} chars`);\n    log.debug(`Resume YAML size: ${resumeYaml.length} bytes`);\n\n    const prompt = prompts.resumeScoringTemplate\n      .replace('{job_description}', jobDescription)\n      .replace('{resume_yaml}', resumeYaml);\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        if (attempt > 0) {\n          log.info(`Scoring attempt ${attempt + 1}/${maxRetries + 1}`);\n        }\n\n        const scoresJson = await this.chatCompletion([{ role: 'user', content: prompt }], 0.3);\n        \n        // Validate it's parseable JSON\n        JSON.parse(scoresJson);\n        \n        log.info('Resume scoring completed successfully');\n        return scoresJson;\n        \n      } catch (e) {\n        log.warn(`Attempt ${attempt + 1}: Invalid JSON in scoring response: ${e}`);\n        \n        if (attempt < maxRetries) {\n          log.info(`Retrying scoring (attempt ${attempt + 2}/${maxRetries + 1})`);\n          continue;\n        } else {\n          log.error('All scoring retry attempts failed');\n          throw new Error(`Failed to get valid JSON scores after ${maxRetries + 1} attempts: ${e}`);\n        }\n      }\n    }\n    \n    throw new Error('Resume scoring failed unexpectedly');\n  }\n\n  /**\n   * Optimize resume keywords and descriptions to match job description (Stage 4)\n   * \n   * Adapts filtered resume to use job-specific terminology without changing\n   * structure or facts. Integrates extracted keywords from Stage 1.\n   */\n  async optimizeResumeKeywords(\n    jobDescription: string,\n    filteredConfig: string,\n    extractedKeywords: string = ''\n  ): Promise<string> {\n    log.info('Optimizing resume keywords for job');\n    log.debug(`Job description length: ${jobDescription.length} chars`);\n    log.debug(`Filtered config size: ${filteredConfig.length} bytes`);\n\n    const prompt = prompts.resumeKeywordOptimizationTemplate\n      .replace('{job_description}', jobDescription)\n      .replace('{filtered_config}', filteredConfig)\n      .replace('{extracted_keywords}', extractedKeywords || '(No extracted keywords provided)');\n\n    try {\n      let optimizedConfig = await this.chatCompletion([{ role: 'user', content: prompt }], 0.5);\n      \n      // Clean up markdown code blocks if present\n      if (optimizedConfig.trim().startsWith('```yaml')) {\n        const lines = optimizedConfig.split('\\n');\n        let startIdx = 0;\n        let endIdx = lines.length;\n        \n        for (let i = 0; i < lines.length; i++) {\n          if (lines[i].trim().startsWith('```yaml')) {\n            startIdx = i + 1;\n          } else if (lines[i].trim() === '```' && i > startIdx) {\n            endIdx = i;\n            break;\n          }\n        }\n        optimizedConfig = lines.slice(startIdx, endIdx).join('\\n');\n      } else if (optimizedConfig.trim().startsWith('```')) {\n        const lines = optimizedConfig.split('\\n');\n        let startIdx = 0;\n        let endIdx = lines.length;\n        \n        for (let i = 0; i < lines.length; i++) {\n          if (lines[i].trim().startsWith('```')) {\n            if (startIdx === 0) {\n              startIdx = i + 1;\n            } else {\n              endIdx = i;\n              break;\n            }\n          }\n        }\n        optimizedConfig = lines.slice(startIdx, endIdx).join('\\n');\n      }\n      \n      log.info('Keyword optimization completed successfully');\n      return optimizedConfig;\n      \n    } catch (e) {\n      log.warn(`Failed to optimize resume keywords: ${e}`);\n      log.debug('Returning filtered config as fallback');\n      return filteredConfig;\n    }\n  }\n\n  /**\n   * Determine which resume section is relevant for a question\n   */\n  private async determineResumeSection(question: string): Promise<string> {\n    const prompt = `For the following question: \"${question}\", which section of the resume is relevant?\n\nSection Descriptions:\n- Personal information: Name, location, contact details, professional title/headline\n- Self Identification: Gender, pronouns, veteran status, disability status\n- Legal Authorization: Work authorization, visa requirements, citizenship\n- Work Preferences: Remote vs in-person, relocation willingness\n- Education Details: Degrees, universities, academic background\n- Experience Details: Work history, job titles, responsibilities, achievements\n- Projects: Personal or professional projects, portfolio items\n- Availability: Start date, notice period\n- Salary Expectations: Expected compensation\n- Certifications: Professional certifications, licenses\n- Languages: Spoken/written languages and proficiency\n- Interests: Career motivations, why interested in roles/companies\n- Cover letter: Full narrative introduction for a job application\n\nSpecial Routing Rules:\n- Questions about 'why interested in this position/role/company' \u2192 Interests\n- Questions about specific technical experience \u2192 Experience Details\n- Questions about 'tell us about yourself' \u2192 Personal information\n- Questions about remote work or office location \u2192 Work Preferences\n\nRespond with ONLY ONE of these exact options (no markdown, no explanation):\nPersonal information\nSelf Identification\nLegal Authorization\nWork Preferences\nEducation Details\nExperience Details\nProjects\nAvailability\nSalary Expectations\nCertifications\nLanguages\nInterests\nCover letter`;\n\n    const response = await this.chatCompletion([{ role: 'user', content: prompt }], 0.3);\n    \n    // Clean up and normalize the response\n    let section = response.trim().toLowerCase()\n      .replace(/\\*\\*/g, '')\n      .replace(/\\*/g, '')\n      .replace(/ /g, '_');\n\n    // Validate section name\n    const validSections = [\n      'personal_information', 'self_identification', 'legal_authorization',\n      'work_preferences', 'education_details', 'experience_details',\n      'projects', 'availability', 'salary_expectations', 'certifications',\n      'languages', 'interests', 'cover_letter'\n    ];\n\n    if (!validSections.includes(section)) {\n      // Try to find a partial match\n      const match = validSections.find(s => section.includes(s) || s.includes(section));\n      section = match || 'personal_information';\n    }\n\n    return section;\n  }\n\n  /**\n   * Get the prompt template for a resume section\n   */\n  private getTemplateForSection(section: string): string {\n    const templates: Record<string, string> = {\n      personal_information: prompts.personalInformationTemplate,\n      self_identification: prompts.selfIdentificationTemplate,\n      legal_authorization: prompts.legalAuthorizationTemplate,\n      work_preferences: prompts.workPreferencesTemplate,\n      education_details: prompts.educationDetailsTemplate,\n      experience_details: prompts.experienceDetailsTemplate,\n      projects: prompts.projectsTemplate,\n      availability: prompts.availabilityTemplate,\n      salary_expectations: prompts.salaryExpectationsTemplate,\n      certifications: prompts.certificationsTemplate,\n      languages: prompts.languagesTemplate,\n      interests: prompts.interestsTemplate,\n    };\n\n    return templates[section] || prompts.personalInformationTemplate;\n  }\n\n  /**\n   * Generate a cover letter\n   */\n  private async generateCoverLetter(): Promise<string> {\n    const prompt = prompts.coverLetterTemplate\n      .replace('{resume}', resumeToNarrative(this.resume!))\n      .replace('{job_description}', this.jobDescription);\n\n    return this.chatCompletion([{ role: 'user', content: prompt }]);\n  }\n\n  /**\n   * Get a brief experience summary\n   */\n  private getExperienceSummary(): string {\n    if (!this.resume?.experienceDetails?.length) {\n      return '';\n    }\n    const recent = this.resume.experienceDetails[0];\n    return `${recent.position} at ${recent.company}`;\n  }\n\n  /**\n   * Find the best matching option using string similarity\n   */\n  private findBestMatch(text: string, options: string[]): string {\n    const textLower = text.toLowerCase().trim();\n    \n    // Exact match\n    const exact = options.find(o => o.toLowerCase() === textLower);\n    if (exact) return exact;\n\n    // Contains match\n    const contains = options.find(o => \n      textLower.includes(o.toLowerCase()) || o.toLowerCase().includes(textLower)\n    );\n    if (contains) return contains;\n\n    // Levenshtein distance (simple implementation)\n    let bestOption = options[0];\n    let bestDistance = Infinity;\n\n    for (const option of options) {\n      const distance = this.levenshteinDistance(textLower, option.toLowerCase());\n      if (distance < bestDistance) {\n        bestDistance = distance;\n        bestOption = option;\n      }\n    }\n\n    return bestOption;\n  }\n\n  /**\n   * Calculate Levenshtein distance between two strings\n   */\n  private levenshteinDistance(a: string, b: string): number {\n    const matrix: number[][] = [];\n\n    for (let i = 0; i <= b.length; i++) {\n      matrix[i] = [i];\n    }\n    for (let j = 0; j <= a.length; j++) {\n      matrix[0][j] = j;\n    }\n\n    for (let i = 1; i <= b.length; i++) {\n      for (let j = 1; j <= a.length; j++) {\n        if (b.charAt(i - 1) === a.charAt(j - 1)) {\n          matrix[i][j] = matrix[i - 1][j - 1];\n        } else {\n          matrix[i][j] = Math.min(\n            matrix[i - 1][j - 1] + 1,\n            matrix[i][j - 1] + 1,\n            matrix[i - 1][j] + 1\n          );\n        }\n      }\n    }\n\n    return matrix[b.length][a.length];\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
