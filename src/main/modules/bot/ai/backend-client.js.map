{
  "version": 3,
  "sources": ["backend-client.ts"],
  "sourcesContent": ["/**\n * Backend API Client for GPT Requests\n * \n * Client for communicating with custom backend API that proxies GPT-4 requests.\n * Port of Python's src/ai/backend_client.py\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { createLogger } from '../utils/logger';\nimport { getDataFolderPath } from '../utils/paths';\n\nconst log = createLogger('BackendClient');\n\n/**\n * Message format for chat completion\n */\nexport interface ChatMessage {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n}\n\n/**\n * Token usage information\n */\nexport interface TokenUsage {\n  input_tokens: number;\n  output_tokens: number;\n  total_tokens: number;\n  total_cost?: number;\n}\n\n/**\n * Chat completion response from backend\n */\nexport interface ChatCompletionResponse {\n  content: string;\n  usage: TokenUsage;\n  model: string;\n  finish_reason: string;\n}\n\n/**\n * Backend API client options\n */\nexport interface BackendClientOptions {\n  token: string;\n  apiUrl: string;\n  timeout?: number;\n  logRequests?: boolean;\n}\n\n/**\n * Client for backend API that proxies GPT requests\n */\nexport class BackendAPIClient {\n  private token: string;\n  private apiUrl: string;\n  private timeout: number;\n  private logRequests: boolean;\n\n  constructor(options: BackendClientOptions) {\n    this.token = options.token;\n    this.apiUrl = options.apiUrl;\n    this.timeout = options.timeout || 120000; // 120 seconds (resume scoring can take 60-90s)\n    this.logRequests = options.logRequests ?? true;\n\n    log.info(`Initialized with endpoint: ${this.apiUrl}`);\n    log.debug(`Token: ${this.token.substring(0, 8)}...${this.token.substring(this.token.length - 8)}`);\n  }\n\n  /**\n   * Send a chat completion request to the backend API\n   */\n  async chatCompletion(\n    messages: ChatMessage[],\n    model: string = 'gpt-4o-mini',\n    temperature: number = 0.8\n  ): Promise<ChatCompletionResponse> {\n    const payload = {\n      token: this.token,\n      messages,\n      model,\n      temperature,\n    };\n\n    log.debug(`Sending request: model=${model}, messages=${messages.length}`);\n    if (messages.length > 0) {\n      log.debug(`First message: ${messages[0].content.substring(0, 100)}...`);\n    }\n\n    try {\n      // Use global fetch (Node 18+)\n      const fetchFn = (globalThis as any).fetch;\n      if (!fetchFn) {\n        throw new Error('Global fetch is not available. Requires Node.js 18+ or polyfill.');\n      }\n\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n      const response = await fetchFn(this.apiUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'User-Agent': 'LinkedInAutoApply/2.0',\n        },\n        body: JSON.stringify(payload),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        log.error(`HTTP error ${response.status}: ${errorText}`);\n        throw new Error(`Backend API error: ${response.status} ${errorText}`);\n      }\n\n      const data = await response.json();\n\n      // DEBUG: Log full response for troubleshooting\n      log.info('========== RAW BACKEND RESPONSE ==========');\n      log.info(`Full response: ${JSON.stringify(data, null, 2)}`);\n      log.info('==========================================');\n      log.debug(`Response keys: ${Object.keys(data).join(', ')}`);\n\n      // Validate response structure\n      if (!data.content) {\n        log.error('\u274C INVALID RESPONSE FORMAT!');\n        log.error(`Expected: {content: string, usage: object, model: string, finish_reason: string}`);\n        log.error(`Received keys: ${Object.keys(data).join(', ')}`);\n        log.error(`Full response: ${JSON.stringify(data, null, 2)}`);\n\n        // Detect wrong format\n        if ('result' in data || 'success' in data) {\n          log.error('\u26A0\uFE0F  DETECTED WRONG FORMAT: Backend is returning {success, result} format');\n          log.error('\u26A0\uFE0F  Backend must transform OpenAI response BEFORE returning');\n          log.error('\u26A0\uFE0F  See BACKEND_FIX_URGENT.md for fix instructions');\n        }\n\n        throw new Error('Invalid response: missing content field. Backend must return transformed format.');\n      }\n\n      log.debug(`\u2705 Valid response: ${data.content?.length || 0} chars`);\n\n      const response_data: ChatCompletionResponse = {\n        content: data.content,\n        usage: data.usage || { input_tokens: 0, output_tokens: 0, total_tokens: 0 },\n        model: data.model || model,\n        finish_reason: data.finish_reason || 'unknown',\n      };\n\n      // Log the request/response if enabled\n      if (this.logRequests) {\n        await this.logRequest(messages, response_data);\n      }\n\n      return response_data;\n    } catch (error: any) {\n      if (error.name === 'AbortError') {\n        log.error(`Request timeout after ${this.timeout / 1000} seconds`);\n        throw new Error('Backend API request timeout');\n      }\n\n      // Enhanced error diagnostics\n      log.error(`\u274C Request failed to ${this.apiUrl}`);\n      log.error(`Error type: ${error.constructor.name}`);\n      log.error(`Error message: ${error.message || error}`);\n      \n      if (error.cause) {\n        log.error(`Underlying cause: ${error.cause.message || error.cause}`);\n        log.error(`Cause code: ${error.cause.code}`);\n      }\n      \n      // Common issues\n      if (error.message?.includes('ECONNREFUSED')) {\n        log.error('');\n        log.error('\uD83D\uDD34 CONNECTION REFUSED - Backend is not running!');\n        log.error(`Make sure your Next.js backend is running at: ${this.apiUrl}`);\n        log.error('Run: cd jobelix && npm run dev');\n        log.error('');\n      } else if (error.message?.includes('ENOTFOUND') || error.message?.includes('getaddrinfo')) {\n        log.error('');\n        log.error('\uD83D\uDD34 DNS/HOST NOT FOUND - Cannot resolve backend URL');\n        log.error(`Check if ${this.apiUrl} is accessible`);\n        log.error('');\n      } else if (error.message?.includes('certificate') || error.message?.includes('TLS')) {\n        log.error('');\n        log.error('\uD83D\uDD34 SSL/TLS ERROR - Certificate validation failed');\n        log.error('For local development, use http:// instead of https://');\n        log.error('');\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Log API request and response to JSON file\n   */\n  private async logRequest(messages: ChatMessage[], response: ChatCompletionResponse): Promise<void> {\n    const dataFolder = getDataFolderPath();\n    const logsPath = path.join(dataFolder, 'output');\n    \n    // Ensure logs directory exists\n    if (!fs.existsSync(logsPath)) {\n      fs.mkdirSync(logsPath, { recursive: true });\n    }\n\n    const callsLog = path.join(logsPath, 'backend_api_calls.json');\n\n    const logEntry = {\n      model: response.model,\n      time: new Date().toISOString(),\n      messages,\n      response: response.content,\n      total_tokens: response.usage.total_tokens,\n      input_tokens: response.usage.input_tokens,\n      output_tokens: response.usage.output_tokens,\n      total_cost: response.usage.total_cost || 0,\n      finish_reason: response.finish_reason,\n    };\n\n    try {\n      // Append to log file\n      const logLine = JSON.stringify(logEntry, null, 2) + '\\n';\n      fs.appendFileSync(callsLog, logLine, 'utf-8');\n      log.debug(`Call logged to ${callsLog}`);\n    } catch (error) {\n      log.warn(`Failed to write to ${callsLog}: ${error}`);\n    }\n  }\n\n  /**\n   * Test connection to backend API\n   */\n  async testConnection(): Promise<boolean> {\n    try {\n      const testMessages: ChatMessage[] = [\n        { role: 'user', content: 'Hello, this is a connection test.' }\n      ];\n      \n      await this.chatCompletion(testMessages, 'gpt-4o-mini', 0.5);\n      log.info('\u2705 Backend API connection test successful');\n      return true;\n    } catch (error) {\n      log.error(`\u274C Backend API connection test failed: ${error}`);\n      return false;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
