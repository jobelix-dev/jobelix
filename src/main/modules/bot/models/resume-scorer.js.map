{
  "version": 3,
  "sources": ["resume-scorer.ts"],
  "sourcesContent": ["/**\n * Resume Scoring and Filtering Module\n * \n * Implements intelligent resume item scoring and selection based on\n * job description relevance. Uses LLM-powered analysis to rank resume items.\n * \n * Port of Python's src/resume/scorer.py\n */\n\nimport * as yaml from 'js-yaml';\nimport { createLogger } from '../utils/logger';\n\nconst log = createLogger('ResumeScorer');\n\n/**\n * Container for a scored resume item\n */\nexport interface ScoredItem {\n  category: 'work' | 'projects' | 'education' | 'certificates' | 'skills';\n  index: number;\n  score: number;\n  reasoning: string;\n  originalData: Record<string, any>;\n  name?: string; // For skills only\n}\n\n/**\n * Metrics for resume selection process\n */\nexport interface SelectionMetrics {\n  totalItemsScored: number;\n  itemsSelected: number;\n  itemsRejected: number;\n  minScore: number;\n  maxScore: number;\n  avgScore: number;\n  selectionByCategory: Record<string, number>;\n}\n\n/**\n * Raw scores from LLM\n */\nexport interface RawScores {\n  work: RawScoreItem[];\n  projects: RawScoreItem[];\n  education: RawScoreItem[];\n  certificates: RawScoreItem[];\n  skills: RawScoreItem[];\n}\n\nexport interface RawScoreItem {\n  index: number;\n  score: number;\n  reasoning?: string;\n  name?: string; // For skills\n}\n\n/**\n * Scores and filters resume items based on job description relevance\n */\nexport class ResumeSectionScorer {\n  private resumeYaml: string;\n  private jobDescription: string;\n  private resumeData: Record<string, any>;\n  private scoredItems: ScoredItem[] = [];\n  private scoresDict: RawScores | null = null;\n\n  constructor(resumeYaml: string, jobDescription: string) {\n    this.resumeYaml = resumeYaml;\n    this.jobDescription = jobDescription;\n    this.resumeData = yaml.load(resumeYaml) as Record<string, any>;\n    log.debug('ResumeScorer initialized');\n  }\n\n  /**\n   * Parse LLM's JSON scores response\n   */\n  parseScoresJson(scoresJson: string): RawScores {\n    try {\n      // Clean up potential markdown wrappers\n      let cleaned = scoresJson.trim();\n      if (cleaned.startsWith('```json')) {\n        cleaned = cleaned.split('```json')[1];\n      }\n      if (cleaned.startsWith('```')) {\n        cleaned = cleaned.split('```')[1];\n      }\n      if (cleaned.endsWith('```')) {\n        cleaned = cleaned.split('```')[0];\n      }\n      cleaned = cleaned.trim();\n\n      const scoresDict = JSON.parse(cleaned) as RawScores;\n\n      // Validate structure\n      const expectedCategories: (keyof RawScores)[] = ['work', 'projects', 'education', 'certificates', 'skills'];\n      for (const category of expectedCategories) {\n        if (!scoresDict[category]) {\n          log.warn(`Category '${category}' missing from scores, using empty array`);\n          scoresDict[category] = [];\n        }\n\n        // Validate each item has required fields\n        for (const item of scoresDict[category]) {\n          if (typeof item.index !== 'number' || typeof item.score !== 'number') {\n            throw new Error(`Item in '${category}' missing 'index' or 'score' field: ${JSON.stringify(item)}`);\n          }\n        }\n      }\n\n      this.scoresDict = scoresDict;\n      return scoresDict;\n    } catch (error) {\n      if (error instanceof SyntaxError) {\n        log.error(`Failed to parse scores JSON: ${error.message}`);\n        log.debug(`Raw JSON: ${scoresJson.substring(0, 500)}...`);\n      } else {\n        log.error(`Error processing scores: ${error}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Convert raw scores dictionary to ScoredItem objects\n   */\n  convertToScoredItems(scoresDict: RawScores): ScoredItem[] {\n    const scoredItems: ScoredItem[] = [];\n\n    for (const [category, items] of Object.entries(scoresDict)) {\n      // Get original data from resume\n      let originalItems: any[];\n      \n      if (category === 'skills') {\n        // Skills are nested in resume structure\n        originalItems = [];\n        const skillSections = this.resumeData.skills || [];\n        for (const skillSection of skillSections) {\n          if (skillSection.name === 'Languages') {\n            // Skip languages section\n            continue;\n          }\n          originalItems.push(...(skillSection.keywords || []));\n        }\n      } else {\n        originalItems = this.resumeData[category] || [];\n      }\n\n      for (const scoreItem of items) {\n        const idx = scoreItem.index;\n\n        // Validate index\n        if (idx >= originalItems.length) {\n          log.warn(`Index ${idx} out of range for '${category}' (max: ${originalItems.length - 1}), skipping`);\n          continue;\n        }\n\n        const originalData = originalItems[idx];\n\n        scoredItems.push({\n          category: category as any,\n          index: idx,\n          score: scoreItem.score,\n          reasoning: scoreItem.reasoning || 'No reasoning provided',\n          originalData: typeof originalData === 'object' ? originalData : { value: originalData },\n          name: scoreItem.name,\n        });\n      }\n    }\n\n    this.scoredItems = scoredItems;\n    return scoredItems;\n  }\n\n  /**\n   * Select top resume items using dynamic thresholds and proportional allocation\n   */\n  filterTopItems(options: {\n    minScore?: number;\n    minItems?: number;\n    maxItems?: number;\n    proportions?: Record<string, number>;\n    minWorkItems?: number;\n    maxEducationItems?: number;\n    educationMinScore?: number;\n  } = {}): { items: ScoredItem[]; metrics: SelectionMetrics } {\n    const {\n      minScore = 40,\n      minItems = 10,\n      maxItems = 15,\n      proportions = { work: 0.65, projects: 0.30, certificates: 0.05 },\n      minWorkItems = 2,\n      maxEducationItems = 5,\n      educationMinScore = 50,\n    } = options;\n\n    log.info(`Filtering items: minScore=${minScore}, min=${minItems}, max=${maxItems}`);\n    log.info(`Special rules: minWork=${minWorkItems}, maxEducation=${maxEducationItems}, educationThreshold=${educationMinScore}`);\n\n    // Separate skills and education from other categories\n    const nonSkillItems = this.scoredItems.filter(item => item.category !== 'skills');\n    const educationItems = nonSkillItems.filter(item => item.category === 'education');\n    const otherItems = nonSkillItems.filter(item => item.category !== 'education');\n\n    // Step 1: Handle education with chronological filtering\n    const selectedEducation = this.filterEducationChronological(\n      educationItems,\n      maxEducationItems,\n      educationMinScore\n    );\n    log.info(`Selected ${selectedEducation.length} education items (chronological + score-based)`);\n\n    // Step 2: Sort other items by score (descending)\n    const otherItemsSorted = [...otherItems].sort((a, b) => b.score - a.score);\n\n    // Step 3: Apply min_score threshold\n    let aboveThreshold = otherItemsSorted.filter(item => item.score >= minScore);\n    let belowThreshold = otherItemsSorted.filter(item => item.score < minScore);\n\n    log.debug(`Non-education items above threshold (${minScore}): ${aboveThreshold.length}`);\n    log.debug(`Non-education items below threshold: ${belowThreshold.length}`);\n\n    // Step 4: Enforce minimum work items (graceful degradation)\n    const workItemsAbove = aboveThreshold.filter(item => item.category === 'work');\n    const workItemsBelow = belowThreshold.filter(item => item.category === 'work');\n    const workItemsTotal = [...workItemsAbove, ...workItemsBelow];\n\n    if (workItemsAbove.length < minWorkItems && workItemsTotal.length >= minWorkItems) {\n      const deficit = minWorkItems - workItemsAbove.length;\n      log.info(`Enforcing min ${minWorkItems} work items: adding ${deficit} below-threshold items`);\n      const forcedWork = workItemsBelow.slice(0, deficit);\n      aboveThreshold.push(...forcedWork);\n      belowThreshold = belowThreshold.filter(item => !forcedWork.includes(item));\n    } else if (workItemsTotal.length < minWorkItems) {\n      log.warn(`Only ${workItemsTotal.length} work items available, cannot reach min ${minWorkItems} - using all available`);\n    }\n\n    // Step 5: Ensure minimum total items (excluding education)\n    const targetMin = minItems - selectedEducation.length;\n    let selectedItems: ScoredItem[];\n    \n    if (aboveThreshold.length < targetMin) {\n      const deficit = targetMin - aboveThreshold.length;\n      log.info(`Need ${deficit} more items to reach minimum of ${minItems} total`);\n      selectedItems = [...aboveThreshold, ...belowThreshold.slice(0, deficit)];\n    } else {\n      selectedItems = aboveThreshold;\n    }\n\n    // Step 6: Apply maximum limit with proportional allocation\n    const targetMax = maxItems - selectedEducation.length;\n    if (selectedItems.length > targetMax) {\n      log.info(`Applying proportional allocation to limit to ${targetMax} non-education items`);\n      selectedItems = this.applyProportionalAllocation(selectedItems, targetMax, proportions);\n    }\n\n    // Combine education with other selected items\n    const allSelected = [...selectedItems, ...selectedEducation];\n\n    // Calculate metrics\n    const scores = allSelected.map(item => item.score);\n    const categoryCount: Record<string, number> = {};\n    for (const item of allSelected) {\n      categoryCount[item.category] = (categoryCount[item.category] || 0) + 1;\n    }\n\n    const metrics: SelectionMetrics = {\n      totalItemsScored: nonSkillItems.length,\n      itemsSelected: allSelected.length,\n      itemsRejected: nonSkillItems.length - allSelected.length,\n      minScore: scores.length > 0 ? Math.min(...scores) : 0,\n      maxScore: scores.length > 0 ? Math.max(...scores) : 0,\n      avgScore: scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0,\n      selectionByCategory: categoryCount,\n    };\n\n    log.info(`Selected ${allSelected.length} items total: ${JSON.stringify(categoryCount)}`);\n    log.info(`Score range: ${metrics.minScore}-${metrics.maxScore} (avg: ${metrics.avgScore.toFixed(1)})`);\n\n    return { items: allSelected, metrics };\n  }\n\n  /**\n   * Filter education items chronologically with score threshold\n   */\n  private filterEducationChronological(\n    educationItems: ScoredItem[],\n    maxItems: number,\n    minScore: number\n  ): ScoredItem[] {\n    if (educationItems.length === 0) {\n      log.debug('No education items to filter');\n      return [];\n    }\n\n    // Sort by score first (highest to lowest)\n    let sortedItems = [...educationItems].sort((a, b) => b.score - a.score);\n\n    // Try to parse dates and sort chronologically\n    try {\n      const getEndDate = (item: ScoredItem): string => {\n        const data = item.originalData;\n        const endDate = data.endDate || '';\n        if (!endDate || ['present', 'current', 'ongoing'].includes(endDate.toLowerCase())) {\n          return '9999-12'; // Sort current education first\n        }\n        return endDate;\n      };\n\n      sortedItems = [...educationItems].sort((a, b) => {\n        const dateA = getEndDate(a);\n        const dateB = getEndDate(b);\n        return dateB.localeCompare(dateA); // Descending (newest first)\n      });\n      log.debug('Education sorted chronologically (newest first)');\n    } catch (error) {\n      log.debug(`Could not sort education by date (${error}), using score-based order`);\n    }\n\n    // Select items up to maxItems, stopping when score drops below threshold\n    const selected: ScoredItem[] = [];\n    for (const item of sortedItems) {\n      if (selected.length >= maxItems) {\n        log.debug(`Reached max ${maxItems} education items`);\n        break;\n      }\n\n      if (item.score < minScore && selected.length > 0) {\n        log.debug(`Education item score ${item.score} below threshold ${minScore}, stopping`);\n        break;\n      }\n\n      selected.push(item);\n      log.debug(`Keeping education item (index=${item.index}, score=${item.score})`);\n    }\n\n    // Ensure at least 1 education if any exist\n    if (selected.length === 0 && educationItems.length > 0) {\n      selected.push(sortedItems[0]);\n      log.info(`All education below threshold, keeping highest-scored item (score=${selected[0].score})`);\n    }\n\n    return selected;\n  }\n\n  /**\n   * Apply proportional allocation to limit items\n   */\n  private applyProportionalAllocation(\n    items: ScoredItem[],\n    maxItems: number,\n    proportions: Record<string, number>\n  ): ScoredItem[] {\n    // Group by category\n    const byCategory: Record<string, ScoredItem[]> = {};\n    for (const item of items) {\n      if (!byCategory[item.category]) {\n        byCategory[item.category] = [];\n      }\n      byCategory[item.category].push(item);\n    }\n\n    // Sort within each category by score\n    for (const category in byCategory) {\n      byCategory[category].sort((a, b) => b.score - a.score);\n    }\n\n    // Calculate allocations\n    const allocations: Record<string, number> = {};\n    let remainingSlots = maxItems;\n\n    for (const [category, proportion] of Object.entries(proportions)) {\n      if (!byCategory[category]) continue;\n\n      let allocatedSlots = Math.floor(maxItems * proportion);\n      // Don't allocate more than available\n      allocatedSlots = Math.min(allocatedSlots, byCategory[category].length);\n      allocations[category] = allocatedSlots;\n      remainingSlots -= allocatedSlots;\n    }\n\n    // Distribute remaining slots to categories with available items\n    while (remainingSlots > 0) {\n      let bestCategory: string | null = null;\n      let bestScore = -1;\n\n      for (const [category, itemsInCat] of Object.entries(byCategory)) {\n        const currentAllocation = allocations[category] || 0;\n        if (currentAllocation < itemsInCat.length) {\n          const nextItemScore = itemsInCat[currentAllocation].score;\n          if (nextItemScore > bestScore) {\n            bestScore = nextItemScore;\n            bestCategory = category;\n          }\n        }\n      }\n\n      if (!bestCategory) break;\n\n      allocations[bestCategory] = (allocations[bestCategory] || 0) + 1;\n      remainingSlots--;\n    }\n\n    // Select items according to allocations\n    const selected: ScoredItem[] = [];\n    for (const [category, allocation] of Object.entries(allocations)) {\n      selected.push(...byCategory[category].slice(0, allocation));\n    }\n\n    log.debug(`Proportional allocation: ${JSON.stringify(allocations)}`);\n    return selected;\n  }\n\n  /**\n   * Select top N skills based on scores\n   */\n  getTopSkills(limit: number = 20): ScoredItem[] {\n    const skillItems = this.scoredItems.filter(item => item.category === 'skills');\n    const sorted = [...skillItems].sort((a, b) => b.score - a.score);\n    const selected = sorted.slice(0, limit);\n\n    log.info(`Selected top ${selected.length} skills (limit: ${limit})`);\n    if (selected.length > 0) {\n      const scoreRange = `${selected[selected.length - 1].score}-${selected[0].score}`;\n      log.debug(`Skill score range: ${scoreRange}`);\n    }\n\n    return selected;\n  }\n\n  /**\n   * Construct filtered YAML with only selected items\n   */\n  filterResumeYaml(selectedItems: ScoredItem[], selectedSkills: ScoredItem[]): string {\n    log.info('Building filtered resume YAML');\n\n    // Deep copy original resume data\n    const filteredData = yaml.load(this.resumeYaml) as Record<string, any>;\n\n    // Group selected items by category\n    const byCategory: Record<string, ScoredItem[]> = {};\n    for (const item of selectedItems) {\n      if (!byCategory[item.category]) {\n        byCategory[item.category] = [];\n      }\n      byCategory[item.category].push(item);\n    }\n\n    // Filter each category\n    for (const category of ['work', 'projects', 'education', 'certificates']) {\n      if (byCategory[category]) {\n        // Sort by original index to maintain chronological order\n        const itemsInCat = byCategory[category].sort((a, b) => a.index - b.index);\n        const selectedIndices = new Set(itemsInCat.map(item => item.index));\n\n        // Keep only selected items\n        const originalItems = filteredData[category] || [];\n        const filtered = originalItems.filter((_: any, i: number) => selectedIndices.has(i));\n        filteredData[category] = filtered;\n\n        log.debug(`Filtered '${category}': ${originalItems.length} \u2192 ${filtered.length} items`);\n      } else {\n        // No items selected from this category\n        filteredData[category] = [];\n        log.debug(`No items selected from '${category}'`);\n      }\n    }\n\n    // Filter skills\n    if (selectedSkills.length > 0) {\n      const selectedSkillNames = selectedSkills.map(\n        item => item.name || item.originalData.value || ''\n      );\n\n      if (filteredData.skills) {\n        for (const skillSection of filteredData.skills) {\n          if (skillSection.name === 'Languages') {\n            // Don't filter language skills\n            continue;\n          }\n          const originalKeywords = skillSection.keywords || [];\n          const filtered = originalKeywords.filter((kw: string) => selectedSkillNames.includes(kw));\n          skillSection.keywords = filtered;\n        }\n\n        log.debug(`Filtered skills: ${selectedSkillNames.length} keywords`);\n      }\n    }\n\n    // Convert back to YAML\n    const filteredYaml = yaml.dump(filteredData, { noRefs: true, sortKeys: false });\n    log.info(`Filtered YAML generated: ${filteredYaml.length} bytes`);\n\n    return filteredYaml;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
