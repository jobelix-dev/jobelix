{
  "version": 3,
  "sources": ["job-manager.ts"],
  "sourcesContent": ["/**\n * LinkedIn Job Manager - Manages job search and application flow\n * \n * Mirrors the Python LinkedInJobManager class.\n */\n\nimport type { Page, Locator } from 'playwright';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport type { Job, JobSearchConfig, SavedAnswer } from '../types';\nimport { createJob, isBlacklisted, setJobDescription } from '../models/job';\nimport { createLogger } from '../utils/logger';\nimport { StatusReporter } from '../utils/status-reporter';\nimport { getOutputFolderPath, getOldQuestionsPath, getDebugHtmlPath } from '../utils/paths';\nimport { buildSearchUrl } from '../core/config-validator';\nimport { LinkedInEasyApplier } from './easy-apply/easy-applier';\nimport type { GPTAnswerer } from '../ai/gpt-answerer';\n\nconst log = createLogger('JobManager');\n\nexport class LinkedInJobManager {\n  private seenJobs = new Set<string>();\n  private oldAnswers: SavedAnswer[] = [];\n  private baseSearchUrl = '';\n  private companyBlacklist: string[] = [];\n  private titleBlacklist: string[] = [];\n  private positions: string[] = [];\n  private locations: string[] = [];\n  private outputDir = '';\n  private easyApplier: LinkedInEasyApplier | null = null;\n  private gptAnswerer: GPTAnswerer | null = null;\n  private lastHeartbeat = Date.now();\n  private resumePath?: string;\n\n  constructor(\n    private page: Page,\n    private reporter?: StatusReporter\n  ) {\n    this.outputDir = getOutputFolderPath();\n    this.loadOldAnswers();\n  }\n\n  /**\n   * Configure job search parameters\n   */\n  setParameters(config: JobSearchConfig, resumePath?: string): void {\n    this.companyBlacklist = config.companyBlacklist;\n    this.titleBlacklist = config.titleBlacklist;\n    this.positions = config.positions;\n    this.locations = config.locations;\n    this.baseSearchUrl = buildSearchUrl(config);\n    this.resumePath = resumePath;\n\n    log.info(`Parameters set: ${this.positions.length} positions, ${this.locations.length} locations`);\n  }\n\n  /**\n   * Set the GPT answerer for AI-powered form filling\n   */\n  setGptAnswerer(gptAnswerer: GPTAnswerer): void {\n    this.gptAnswerer = gptAnswerer;\n  }\n\n  /**\n   * Start the job application process\n   */\n  async startApplying(): Promise<void> {\n    if (!this.gptAnswerer) {\n      throw new Error('GPT Answerer must be set before applying');\n    }\n\n    // Initialize Easy Applier\n    log.info('Initializing Easy Applier');\n    this.easyApplier = new LinkedInEasyApplier(\n      this.page,\n      this.gptAnswerer,\n      this.oldAnswers,\n      this.resumePath,\n      (type, question, answer) => this.recordAnswer(type, question, answer),\n      this.reporter\n    );\n\n    // Generate search combinations\n    const searches = this.generateSearchCombinations();\n    log.info(`Generated ${searches.length} search combinations`);\n\n    for (const { position, location } of searches) {\n      log.info(`Starting search for ${position} in ${location}`);\n\n      // Send heartbeat for searching\n      if (this.reporter) {\n        const shouldContinue = this.reporter.sendHeartbeat('searching_jobs', {\n          query: position,\n          location,\n        });\n        if (!shouldContinue) {\n          log.warn('Session stopped by user during job search');\n          this.reporter.completeSession(false, 'Stopped by user during search');\n          return;\n        }\n      }\n\n      let page = 0;\n      let emptyPages = 0;\n      const maxEmptyPages = 3;\n\n      try {\n        while (emptyPages < maxEmptyPages) {\n          log.info(`Going to job page ${page}`);\n          await this.navigateToSearchPage(position, location, page);\n          await this.page.waitForTimeout(Math.random() * 800 + 200);\n\n          log.info('Starting the application process for this page...');\n\n          // Check if user stopped the bot (every 45 seconds)\n          if (this.reporter && Date.now() - this.lastHeartbeat > 45000) {\n            const shouldContinue = this.reporter.sendHeartbeat('applying_jobs', {\n              position,\n              location,\n              page,\n            });\n            this.lastHeartbeat = Date.now();\n\n            if (!shouldContinue) {\n              log.warn('Session stopped by user during job application');\n              this.reporter.completeSession(false, 'Stopped by user');\n              return;\n            }\n          }\n\n          const jobsFound = await this.applyToJobs();\n\n          if (jobsFound === 0) {\n            emptyPages++;\n            log.warn(`No jobs found on page ${page} (${emptyPages}/${maxEmptyPages} empty pages)`);\n\n            if (emptyPages >= maxEmptyPages) {\n              log.info(`Stopping search: ${maxEmptyPages} consecutive empty pages reached`);\n              break;\n            }\n          } else {\n            emptyPages = 0;\n          }\n\n          log.info('Applications on this page completed \u2714');\n          page++;\n\n          // Human-like delay between pages\n          await this.page.waitForTimeout(9000 + Math.random() * 3000);\n        }\n      } catch (error) {\n        if (this.isBrowserClosed(error)) {\n          log.error('Browser was closed by user or crashed');\n          throw new Error('Browser closed - stopping bot');\n        }\n        log.error(`Error on page ${page}: ${error}`);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Apply to all jobs on the current page\n   */\n  private async applyToJobs(): Promise<number> {\n    try {\n      // Check for \"no results found\" message\n      const noResultsElement = this.page.locator('.artdeco-empty-state__headline');\n      const noResultsElements = await noResultsElement.all();\n      \n      for (const el of noResultsElements) {\n        const text = await el.textContent();\n        if (text?.toLowerCase().includes('no results found')) {\n          log.warn('No jobs found - LinkedIn shows \"no results found\" message');\n          return 0;\n        }\n      }\n\n      log.info('Fetching job results');\n\n      // Wait for job tiles to load with multiple selector strategies\n      // LinkedIn uses different selectors depending on the page state\n      const jobTileSelectors = [\n        'li[data-occludable-job-id]',\n        '.jobs-search-results__list-item',\n        '.job-card-container',\n        '.scaffold-layout__list-container li',\n      ];\n\n      let tiles: Locator[] = [];\n      \n      for (const selector of jobTileSelectors) {\n        try {\n          await this.page.waitForSelector(selector, { timeout: 5000 });\n          tiles = await this.page.locator(selector).all();\n          if (tiles.length > 0) {\n            log.debug(`Found ${tiles.length} jobs using selector: ${selector}`);\n            break;\n          }\n        } catch {\n          log.debug(`No jobs found with selector: ${selector}`);\n        }\n      }\n\n      if (tiles.length === 0) {\n        log.info('\u26A0\uFE0F No job tiles found on this page - likely reached end of results');\n        \n        // Save debug HTML to understand the page structure\n        await this.saveDebugHtml('no_jobs_found');\n        return 0;\n      }\n\n      log.info(`Found ${tiles.length} job tiles`);\n\n      // Report jobs found\n      if (this.reporter) {\n        this.reporter.incrementJobsFound(tiles.length);\n        const shouldContinue = this.reporter.sendHeartbeat('jobs_found', { count: tiles.length });\n        if (!shouldContinue) {\n          log.warn('Session stopped by user after finding jobs');\n          this.reporter.completeSession(false, 'Stopped by user');\n          return 0;\n        }\n      }\n\n      // Scroll each tile into view\n      for (const tile of tiles) {\n        try {\n          await tile.scrollIntoViewIfNeeded();\n        } catch (error) {\n          log.warn(`Failed to scroll tile into view: ${error}`);\n        }\n      }\n\n      // Extract job information\n      const jobs: Job[] = [];\n      for (const tile of tiles) {\n        const job = await this.extractJobFromTile(tile);\n        jobs.push(job);\n      }\n\n      log.debug(`Extracted ${jobs.length} jobs`);\n\n      // Process each job\n      for (const job of jobs) {\n        if (isBlacklisted(job, this.companyBlacklist, this.titleBlacklist, this.seenJobs)) {\n          log.warn(`Blacklisted ${job.title} at ${job.company}, skipping...`);\n          this.writeToFile(job, 'skipped');\n          continue;\n        }\n\n        try {\n          if (!['Continue', 'Applied', 'Apply'].includes(job.applyMethod)) {\n            await this.easyApplier!.apply(job);\n          }\n          this.writeToFile(job, 'success');\n          this.seenJobs.add(job.link);\n        } catch (error) {\n          await this.saveDebugHtml(`job_apply_error_${job.company.replace(/\\s+/g, '_')}`);\n          this.writeToFile(job, 'failed');\n          log.error(`apply_jobs failed for ${job.title} at ${job.company}: ${error}`);\n        }\n      }\n\n      return jobs.length;\n\n    } catch (error) {\n      await this.saveDebugHtml('apply_jobs_exception');\n      throw error;\n    }\n  }\n\n  /**\n   * Extract job information from a tile element\n   */\n  private async extractJobFromTile(tile: Locator): Promise<Job> {\n    let title = '';\n    let company = '';\n    let location = '';\n    let link = '';\n    let applyMethod = '';\n\n    // 1) Title & link\n    try {\n      const aTag = tile.locator('a.job-card-container__link');\n      title = (await aTag.textContent() || '').trim();\n      const href = await aTag.getAttribute('href');\n      if (href) {\n        const cleanHref = href.split('?')[0];\n        link = cleanHref.startsWith('/') \n          ? `https://www.linkedin.com${cleanHref}` \n          : cleanHref;\n      }\n    } catch (error) {\n      log.error(`[extract] title/link failed: ${error}`);\n    }\n\n    // 2) Company\n    try {\n      const companySpan = tile.locator('.artdeco-entity-lockup__subtitle span').first();\n      company = (await companySpan.textContent() || '').trim();\n    } catch (error) {\n      log.error(`[extract] company failed: ${error}`);\n    }\n\n    // 3) Location\n    try {\n      const locationSpan = tile.locator('ul.job-card-container__metadata-wrapper li span').first();\n      location = (await locationSpan.textContent() || '').trim();\n    } catch (error) {\n      log.error(`[extract] location failed: ${error}`);\n    }\n\n    // 4) Apply method\n    try {\n      const footerItems = await tile.locator('ul.job-card-list__footer-wrapper li').all();\n      for (const li of footerItems) {\n        const text = (await li.textContent() || '').trim();\n        if (text && !['ago', 'viewed', 'promoted'].some(kw => text.toLowerCase().includes(kw))) {\n          applyMethod = text;\n          break;\n        }\n      }\n    } catch {\n      applyMethod = 'Applied';\n    }\n\n    return createJob(title, company, location, link, applyMethod);\n  }\n\n  /**\n   * Navigate to a job search page\n   */\n  private async navigateToSearchPage(position: string, location: string, page: number): Promise<void> {\n    const encodedPosition = encodeURIComponent(position);\n    const encodedLocation = encodeURIComponent(location);\n    const url = `https://www.linkedin.com/jobs/search/${this.baseSearchUrl}&keywords=${encodedPosition}&location=${encodedLocation}&start=${page * 25}`;\n    \n    log.debug(`Navigating to: ${url}`);\n    \n    try {\n      await this.page.goto(url, { waitUntil: 'domcontentloaded', timeout: 60000 });\n      \n      // Wait for page to fully render - LinkedIn uses lazy loading\n      await this.page.waitForLoadState('networkidle', { timeout: 15000 }).catch(() => {\n        log.debug('Network idle timeout - continuing anyway');\n      });\n      \n      // Extra wait for JavaScript to render job tiles\n      await this.page.waitForTimeout(2000);\n      \n    } catch (error) {\n      if (this.isBrowserClosed(error)) {\n        log.error('Browser was closed during navigation');\n        throw new Error('Browser closed - stopping bot');\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Generate all position/location search combinations\n   */\n  private generateSearchCombinations(): Array<{ position: string; location: string }> {\n    const combinations: Array<{ position: string; location: string }> = [];\n    for (const position of this.positions) {\n      for (const location of this.locations) {\n        combinations.push({ position, location });\n      }\n    }\n    // Shuffle for variety\n    return combinations.sort(() => Math.random() - 0.5);\n  }\n\n  /**\n   * Load previously answered questions from CSV\n   */\n  private loadOldAnswers(): void {\n    const filePath = getOldQuestionsPath();\n    \n    if (!fs.existsSync(filePath)) {\n      return;\n    }\n\n    try {\n      const content = fs.readFileSync(filePath, 'utf-8');\n      const lines = content.split('\\n').filter(line => line.trim());\n\n      for (const line of lines) {\n        // Simple CSV parsing (handles basic cases)\n        const parts = this.parseCSVLine(line);\n        if (parts.length >= 3) {\n          const [questionType, questionText, answer] = parts;\n          \n          // Skip invalid placeholder answers\n          if (!answer || answer.length <= 2) continue;\n          const answerLower = answer.toLowerCase();\n          if (answerLower.startsWith('select') || answerLower.startsWith('choose')) continue;\n          if (['option', 'n/a', 'none', 'null'].includes(answerLower)) continue;\n\n          this.oldAnswers.push({ questionType, questionText, answer });\n        }\n      }\n\n      log.info(`Loaded ${this.oldAnswers.length} saved answers`);\n    } catch (error) {\n      log.error(`Failed to load old answers: ${error}`);\n    }\n  }\n\n  /**\n   * Record a new GPT answer to CSV\n   */\n  private recordAnswer(questionType: string, questionText: string, answer: string): void {\n    const filePath = getOldQuestionsPath();\n\n    // Check for duplicates\n    const exists = this.oldAnswers.some(\n      a => a.questionType.toLowerCase() === questionType.toLowerCase() &&\n           a.questionText.toLowerCase() === questionText.toLowerCase()\n    );\n\n    if (exists) return;\n\n    // Append to CSV\n    const line = `\"${questionType}\",\"${questionText}\",\"${answer}\"\\n`;\n    fs.appendFileSync(filePath, line, 'utf-8');\n\n    this.oldAnswers.push({ questionType, questionText, answer });\n  }\n\n  /**\n   * Write job result to CSV file\n   */\n  private writeToFile(job: Job, status: string): void {\n    const filePath = path.join(this.outputDir, `${status}.csv`);\n    const line = `\"${job.company}\",\"${job.title}\",\"${job.link}\",\"${job.location}\"\\n`;\n    fs.appendFileSync(filePath, line, 'utf-8');\n  }\n\n  /**\n   * Save debug HTML snapshot\n   */\n  private async saveDebugHtml(context: string): Promise<void> {\n    try {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const filename = `${context}_${timestamp}.html`;\n      const filePath = path.join(getDebugHtmlPath(), filename);\n      const content = await this.page.content();\n      fs.writeFileSync(filePath, content, 'utf-8');\n      log.info(`Saved debug HTML: ${filename}`);\n    } catch (error) {\n      log.error(`Failed to save debug HTML: ${error}`);\n    }\n  }\n\n  /**\n   * Parse a CSV line into parts\n   */\n  private parseCSVLine(line: string): string[] {\n    const result: string[] = [];\n    let current = '';\n    let inQuotes = false;\n\n    for (const char of line) {\n      if (char === '\"') {\n        inQuotes = !inQuotes;\n      } else if (char === ',' && !inQuotes) {\n        result.push(current);\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n    result.push(current);\n\n    return result.map(s => s.trim());\n  }\n\n  /**\n   * Check if error indicates browser was closed\n   */\n  private isBrowserClosed(error: unknown): boolean {\n    const message = error instanceof Error ? error.message : String(error);\n    return message.includes('Target page, context or browser has been closed') ||\n           message.includes('Target closed') ||\n           message.includes('Browser closed');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
