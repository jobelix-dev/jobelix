{
  "version": 3,
  "sources": ["job-manager.ts"],
  "sourcesContent": ["/**\n * LinkedIn Job Manager - Manages job search and application flow\n * \n * Coordinates the job search process:\n * 1. Navigates to LinkedIn job search pages\n * 2. Extracts job listings from search results\n * 3. Filters jobs based on blacklist criteria\n * 4. Delegates applications to EasyApplier\n * 5. Tracks progress and reports status\n */\n\nimport type { Page, Locator } from 'playwright';\nimport * as path from 'path';\nimport type { Job, JobSearchConfig, SavedAnswer } from '../types';\nimport { createJob, isBlacklisted, setJobDescription } from '../models/job';\nimport { createLogger } from '../utils/logger';\nimport { StatusReporter } from '../utils/status-reporter';\nimport { getOutputFolderPath, getOldQuestionsPath } from '../utils/paths';\nimport { saveDebugHtml } from '../utils/debug-html';\nimport { waitRandom, DELAYS } from '../utils/delays';\nimport { buildSearchUrl } from '../core/config-validator';\nimport { LinkedInEasyApplier } from './easy-apply/easy-applier';\nimport { loadSavedAnswers, saveAnswer, appendJobResult } from '../utils/csv-utils';\nimport type { GPTAnswerer } from '../ai/gpt-answerer';\n\nconst log = createLogger('JobManager');\n\nexport class LinkedInJobManager {\n  private seenJobs = new Set<string>();\n  private oldAnswers: SavedAnswer[] = [];\n  private baseSearchUrl = '';\n  private companyBlacklist: string[] = [];\n  private titleBlacklist: string[] = [];\n  private positions: string[] = [];\n  private locations: string[] = [];\n  private outputDir = '';\n  private easyApplier: LinkedInEasyApplier | null = null;\n  private gptAnswerer: GPTAnswerer | null = null;\n  private lastHeartbeat = Date.now();\n  private resumePath?: string;\n\n  constructor(\n    private page: Page,\n    private reporter?: StatusReporter\n  ) {\n    this.outputDir = getOutputFolderPath();\n    this.loadOldAnswers();\n  }\n\n  /**\n   * Configure job search parameters\n   */\n  setParameters(config: JobSearchConfig, resumePath?: string): void {\n    this.companyBlacklist = config.companyBlacklist;\n    this.titleBlacklist = config.titleBlacklist;\n    this.positions = config.positions;\n    this.locations = config.locations;\n    this.baseSearchUrl = buildSearchUrl(config);\n    this.resumePath = resumePath;\n\n    log.info(`Parameters set: ${this.positions.length} positions, ${this.locations.length} locations`);\n  }\n\n  /**\n   * Set the GPT answerer for AI-powered form filling\n   */\n  setGptAnswerer(gptAnswerer: GPTAnswerer): void {\n    this.gptAnswerer = gptAnswerer;\n  }\n\n  /**\n   * Start the job application process\n   */\n  async startApplying(): Promise<void> {\n    if (!this.gptAnswerer) {\n      throw new Error('GPT Answerer must be set before applying');\n    }\n\n    // Initialize Easy Applier\n    log.info('Initializing Easy Applier');\n    this.easyApplier = new LinkedInEasyApplier(\n      this.page,\n      this.gptAnswerer,\n      this.oldAnswers,\n      this.resumePath,\n      (type, question, answer) => this.recordAnswer(type, question, answer),\n      this.reporter\n    );\n\n    // Generate search combinations\n    const searches = this.generateSearchCombinations();\n    log.info(`Generated ${searches.length} search combinations`);\n\n    let totalJobsFound = 0;\n\n    for (const { position, location } of searches) {\n      log.info(`Starting search for ${position} in ${location}`);\n\n      // Send heartbeat for searching\n      if (this.reporter) {\n        const shouldContinue = this.reporter.sendHeartbeat('searching_jobs', {\n          query: position,\n          location,\n        });\n        if (!shouldContinue) {\n          log.warn('Session stopped by user during job search');\n          this.reporter.completeSession(false, 'Stopped by user during search');\n          return;\n        }\n      }\n\n      let page = 0;\n      let emptyPages = 0;\n      const maxEmptyPages = 3;\n\n      try {\n        while (emptyPages < maxEmptyPages) {\n          log.info(`Going to job page ${page}`);\n          await this.navigateToSearchPage(position, location, page);\n          await waitRandom(this.page, DELAYS.CLICK);\n\n          log.info('Starting the application process for this page...');\n\n          // Check if user stopped the bot (every 45 seconds)\n          if (this.reporter && Date.now() - this.lastHeartbeat > 45000) {\n            const shouldContinue = this.reporter.sendHeartbeat('applying_jobs', {\n              position,\n              location,\n              page,\n            });\n            this.lastHeartbeat = Date.now();\n\n            if (!shouldContinue) {\n              log.warn('Session stopped by user during job application');\n              this.reporter.completeSession(false, 'Stopped by user');\n              return;\n            }\n          }\n\n          const jobsFound = await this.applyToJobs();\n          totalJobsFound += jobsFound;\n\n          if (jobsFound === 0) {\n            emptyPages++;\n            log.warn(`No jobs found on page ${page} (${emptyPages}/${maxEmptyPages} empty pages)`);\n\n            if (emptyPages >= maxEmptyPages) {\n              log.info(`Stopping search: ${maxEmptyPages} consecutive empty pages reached`);\n              break;\n            }\n          } else {\n            emptyPages = 0;\n          }\n\n          log.info('Applications on this page completed \u2714');\n          page++;\n\n          // Human-like delay between pages\n          await waitRandom(this.page, DELAYS.BETWEEN_PAGES);\n        }\n      } catch (error) {\n        if (this.isBrowserClosed(error)) {\n          log.error('Browser was closed by user or crashed');\n          throw new Error('Browser closed - stopping bot');\n        }\n        log.error(`Error on page ${page}: ${error}`);\n        break;\n      }\n    }\n\n    // Complete session based on results\n    if (this.reporter) {\n      if (totalJobsFound === 0) {\n        log.info('No matching jobs found - completing session');\n        this.reporter.completeSession(true, 'No matching jobs found');\n      } else {\n        log.info(`Session complete - processed ${totalJobsFound} jobs`);\n        this.reporter.completeSession(true, `Processed ${totalJobsFound} jobs`);\n      }\n    }\n  }\n\n  /**\n   * Apply to all jobs on the current page\n   */\n  private async applyToJobs(): Promise<number> {\n    try {\n      // Check for \"no results found\" message\n      const noResultsElement = this.page.locator('.artdeco-empty-state__headline');\n      const noResultsElements = await noResultsElement.all();\n      \n      for (const el of noResultsElements) {\n        const text = await el.textContent();\n        if (text?.toLowerCase().includes('no results found')) {\n          log.warn('No jobs found - LinkedIn shows \"no results found\" message');\n          return 0;\n        }\n      }\n\n      log.info('Fetching job results');\n\n      // Wait for job tiles to load with multiple selector strategies\n      // LinkedIn uses different selectors depending on the page state\n      const jobTileSelectors = [\n        'li[data-occludable-job-id]',\n        '.jobs-search-results__list-item',\n        '.job-card-container',\n        '.scaffold-layout__list-container li',\n      ];\n\n      let tiles: Locator[] = [];\n      \n      for (const selector of jobTileSelectors) {\n        try {\n          await this.page.waitForSelector(selector, { timeout: 5000 });\n          tiles = await this.page.locator(selector).all();\n          if (tiles.length > 0) {\n            log.debug(`Found ${tiles.length} jobs using selector: ${selector}`);\n            break;\n          }\n        } catch {\n          log.debug(`No jobs found with selector: ${selector}`);\n        }\n      }\n\n      if (tiles.length === 0) {\n        log.info('\u26A0\uFE0F No job tiles found on this page - likely reached end of results');\n        \n        // Save debug HTML to understand the page structure\n        await saveDebugHtml(this.page, 'no_jobs_found');\n        return 0;\n      }\n\n      log.info(`Found ${tiles.length} job tiles`);\n\n      // Report jobs found\n      if (this.reporter) {\n        this.reporter.incrementJobsFound(tiles.length);\n        const shouldContinue = this.reporter.sendHeartbeat('jobs_found', { count: tiles.length });\n        if (!shouldContinue) {\n          log.warn('Session stopped by user after finding jobs');\n          this.reporter.completeSession(false, 'Stopped by user');\n          return 0;\n        }\n      }\n\n      // Scroll each tile into view\n      for (const tile of tiles) {\n        try {\n          await tile.scrollIntoViewIfNeeded();\n        } catch (error) {\n          log.warn(`Failed to scroll tile into view: ${error}`);\n        }\n      }\n\n      // Extract job information\n      const jobs: Job[] = [];\n      for (const tile of tiles) {\n        const job = await this.extractJobFromTile(tile);\n        jobs.push(job);\n      }\n\n      log.debug(`Extracted ${jobs.length} jobs`);\n\n      // Process each job\n      for (const job of jobs) {\n        if (isBlacklisted(job, this.companyBlacklist, this.titleBlacklist, this.seenJobs)) {\n          log.warn(`Blacklisted ${job.title} at ${job.company}, skipping...`);\n          this.writeToFile(job, 'skipped');\n          continue;\n        }\n\n        try {\n          if (!['Continue', 'Applied', 'Apply'].includes(job.applyMethod)) {\n            const result = await this.easyApplier!.apply(job);\n            \n            // If already applied, skip gracefully\n            if (result.alreadyApplied) {\n              log.info(`Already applied to ${job.title} at ${job.company}, skipping`);\n              this.writeToFile(job, 'skipped');\n              this.seenJobs.add(job.link);\n              continue;\n            }\n            \n            // If modal didn't open (no Easy Apply button), skip and don't count as failure\n            if (!result.success && result.error?.includes('Could not open Easy Apply modal')) {\n              log.warn(`No Easy Apply available for ${job.title} at ${job.company}, skipping`);\n              this.writeToFile(job, 'skipped');\n              continue;\n            }\n            \n            // If application failed for other reasons\n            if (!result.success) {\n              throw new Error(result.error || 'Application failed');\n            }\n          }\n          this.writeToFile(job, 'success');\n          this.seenJobs.add(job.link);\n        } catch (error) {\n          await saveDebugHtml(this.page, `job_apply_error_${job.company.replace(/\\s+/g, '_')}`);\n          this.writeToFile(job, 'failed');\n          log.error(`apply_jobs failed for ${job.title} at ${job.company}: ${error}`);\n          \n          // Wait before continuing to next job (like Python: random.uniform(3, 5))\n          await this.page.waitForTimeout(3000 + Math.random() * 2000);\n        }\n      }\n\n      return jobs.length;\n\n    } catch (error) {\n      await saveDebugHtml(this.page, 'apply_jobs_exception');\n      throw error;\n    }\n  }\n\n  /**\n   * Extract job information from a tile element\n   */\n  private async extractJobFromTile(tile: Locator): Promise<Job> {\n    let title = '';\n    let company = '';\n    let location = '';\n    let link = '';\n    let applyMethod = '';\n\n    // 1) Title & link\n    try {\n      const aTag = tile.locator('a.job-card-container__link');\n      title = (await aTag.textContent() || '').trim();\n      const href = await aTag.getAttribute('href');\n      if (href) {\n        const cleanHref = href.split('?')[0];\n        link = cleanHref.startsWith('/') \n          ? `https://www.linkedin.com${cleanHref}` \n          : cleanHref;\n      }\n    } catch (error) {\n      log.error(`[extract] title/link failed: ${error}`);\n    }\n\n    // 2) Company\n    try {\n      const companySpan = tile.locator('.artdeco-entity-lockup__subtitle span').first();\n      company = (await companySpan.textContent() || '').trim();\n    } catch (error) {\n      log.error(`[extract] company failed: ${error}`);\n    }\n\n    // 3) Location\n    try {\n      const locationSpan = tile.locator('ul.job-card-container__metadata-wrapper li span').first();\n      location = (await locationSpan.textContent() || '').trim();\n    } catch (error) {\n      log.error(`[extract] location failed: ${error}`);\n    }\n\n    // 4) Apply method\n    try {\n      const footerItems = await tile.locator('ul.job-card-list__footer-wrapper li').all();\n      for (const li of footerItems) {\n        const text = (await li.textContent() || '').trim();\n        if (text && !['ago', 'viewed', 'promoted'].some(kw => text.toLowerCase().includes(kw))) {\n          applyMethod = text;\n          break;\n        }\n      }\n    } catch {\n      applyMethod = 'Applied';\n    }\n\n    return createJob(title, company, location, link, applyMethod);\n  }\n\n  /**\n   * Navigate to a job search page\n   */\n  private async navigateToSearchPage(position: string, location: string, page: number): Promise<void> {\n    const encodedPosition = encodeURIComponent(position);\n    const encodedLocation = encodeURIComponent(location);\n    const url = `https://www.linkedin.com/jobs/search/${this.baseSearchUrl}&keywords=${encodedPosition}&location=${encodedLocation}&start=${page * 25}`;\n    \n    log.debug(`Navigating to: ${url}`);\n    \n    try {\n      await this.page.goto(url, { waitUntil: 'domcontentloaded', timeout: 60000 });\n      \n      // Wait for page to fully render - LinkedIn uses lazy loading\n      await this.page.waitForLoadState('networkidle', { timeout: 15000 }).catch(() => {\n        log.debug('Network idle timeout - continuing anyway');\n      });\n      \n      // Extra wait for JavaScript to render job tiles\n      await this.page.waitForTimeout(2000);\n      \n    } catch (error) {\n      if (this.isBrowserClosed(error)) {\n        log.error('Browser was closed during navigation');\n        throw new Error('Browser closed - stopping bot');\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Generate all position/location search combinations\n   */\n  private generateSearchCombinations(): Array<{ position: string; location: string }> {\n    const combinations: Array<{ position: string; location: string }> = [];\n    for (const position of this.positions) {\n      for (const location of this.locations) {\n        combinations.push({ position, location });\n      }\n    }\n    // Shuffle for variety\n    return combinations.sort(() => Math.random() - 0.5);\n  }\n\n  /**\n   * Load previously answered questions from CSV\n   */\n  private loadOldAnswers(): void {\n    const filePath = getOldQuestionsPath();\n    this.oldAnswers = loadSavedAnswers(filePath);\n  }\n\n  /**\n   * Record a new GPT answer to CSV\n   */\n  private recordAnswer(questionType: string, questionText: string, answer: string): void {\n    const filePath = getOldQuestionsPath();\n    \n    if (saveAnswer(filePath, this.oldAnswers, questionType, questionText, answer)) {\n      this.oldAnswers.push({ questionType, questionText, answer });\n    }\n  }\n\n  /**\n   * Write job result to CSV file\n   */\n  private writeToFile(job: Job, status: string): void {\n    const filePath = path.join(this.outputDir, `${status}.csv`);\n    appendJobResult(filePath, job.company, job.title, job.link, job.location);\n  }\n\n\n  /**\n   * Check if error indicates browser was closed\n   */\n  private isBrowserClosed(error: unknown): boolean {\n    const message = error instanceof Error ? error.message : String(error);\n    return message.includes('Target page, context or browser has been closed') ||\n           message.includes('Target closed') ||\n           message.includes('Browser closed');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
