{
  "version": 3,
  "sources": ["form-handler.ts"],
  "sourcesContent": ["/**\n * Form Handler - Orchestrates field handlers to fill LinkedIn Easy Apply forms\n * \n * This is the main coordinator that:\n * 1. Finds all form fields on the current page\n * 2. Determines the appropriate handler for each field\n * 3. Fills fields in order using the strategy pattern\n * 4. Handles errors and retries\n */\n\nimport type { Page, Locator } from 'playwright';\nimport type { SavedAnswer } from '../../types';\nimport { createLogger } from '../../utils/logger';\nimport { FormUtils } from './form-utils';\nimport { \n  BaseFieldHandler,\n  TextInputHandler,\n  TextareaHandler,\n  RadioButtonHandler,\n  DropdownHandler,\n  CheckboxHandler,\n  TypeaheadHandler,\n  DateHandler,\n  FileUploadHandler\n} from './field-handlers';\n\nconst log = createLogger('FormHandler');\n\n/**\n * Result of handling a single form page\n */\nexport interface FormPageResult {\n  success: boolean;\n  fieldsProcessed: number;\n  fieldsFailed: number;\n  errors: string[];\n}\n\n/**\n * Callback for recording answered questions\n */\nexport type AnswerRecordCallback = (type: string, question: string, answer: string) => void;\n\nexport class FormHandler {\n  private page: Page;\n  private gptAnswerer: any;\n  private formUtils: FormUtils;\n  private handlers: BaseFieldHandler[];\n  private fileUploadHandler: FileUploadHandler;\n\n  /**\n   * Create a new form handler\n   * \n   * @param page - Playwright page instance\n   * @param gptAnswerer - GPT answerer for generating responses\n   * @param savedAnswers - Previously saved Q&A pairs for reuse\n   * @param recordCallback - Callback to persist new answers\n   * @param resumePath - Optional path to resume file\n   * @param coverLetterPath - Optional path to cover letter file\n   */\n  constructor(\n    page: Page, \n    gptAnswerer: any,\n    savedAnswers: SavedAnswer[] = [],\n    recordCallback?: AnswerRecordCallback,\n    resumePath?: string,\n    coverLetterPath?: string\n  ) {\n    this.page = page;\n    this.gptAnswerer = gptAnswerer;\n    this.formUtils = new FormUtils(page, savedAnswers, recordCallback);\n\n    // Create file upload handler separately (needs file paths)\n    this.fileUploadHandler = new FileUploadHandler(\n      page, \n      gptAnswerer, \n      this.formUtils,\n      resumePath || null,\n      coverLetterPath || null\n    );\n\n    // Initialize handlers in priority order\n    // More specific handlers should come before generic ones\n    this.handlers = [\n      this.fileUploadHandler,                                    // File uploads first (most specific)\n      new RadioButtonHandler(page, gptAnswerer, this.formUtils), // Radio buttons\n      new DropdownHandler(page, gptAnswerer, this.formUtils),    // Dropdowns/selects\n      new CheckboxHandler(page, gptAnswerer, this.formUtils),    // Checkboxes\n      new TypeaheadHandler(page, gptAnswerer, this.formUtils),   // Autocomplete fields\n      new DateHandler(page, gptAnswerer, this.formUtils),        // Date fields\n      new TextareaHandler(page, gptAnswerer, this.formUtils),    // Textareas\n      new TextInputHandler(page, gptAnswerer, this.formUtils),   // Text inputs (most generic)\n    ];\n  }\n\n  /**\n   * Fill all form fields on the current Easy Apply page\n   * \n   * MATCHES PYTHON _answer_visible_form:\n   * Uses multi-pass approach with scrolling to handle virtualized lists.\n   * \n   * This method:\n   * 1. Finds all form groups/sections\n   * 2. For each, determines the appropriate handler\n   * 3. Fills the field using that handler\n   * 4. Scrolls and repeats until no new elements found\n   * 5. Tracks success/failure\n   */\n  async fillCurrentPage(): Promise<FormPageResult> {\n    const result: FormPageResult = {\n      success: true,\n      fieldsProcessed: 0,\n      fieldsFailed: 0,\n      errors: [],\n    };\n\n    try {\n      // Wait for form to be ready\n      await this.page.waitForTimeout(500);\n\n      // Track processed elements to avoid re-processing (like Python's processed set)\n      const processedKeys = new Set<string>();\n      let passIndex = 0;\n\n      // Multi-pass loop (matches Python's while True loop)\n      while (true) {\n        passIndex++;\n        let newlyHandled = 0;\n\n        // Find all form field sections\n        const formSections = await this.findFormSections();\n        \n        if (passIndex === 1) {\n          log.info(`Found ${formSections.length} form section(s) on this page`);\n        }\n\n        // Process each section\n        for (const section of formSections) {\n          try {\n            // Generate stable key to track processed elements\n            const key = await this.formUtils.stableKey(section);\n            if (processedKeys.has(key)) {\n              continue; // Already processed\n            }\n\n            // Check if section is visible\n            if (!(await section.isVisible())) {\n              continue;\n            }\n\n            // Find appropriate handler\n            const handler = await this.findHandler(section);\n            \n            if (handler) {\n              const success = await handler.handle(section);\n              result.fieldsProcessed++;\n              processedKeys.add(key);\n              newlyHandled++;\n              \n              if (!success) {\n                result.fieldsFailed++;\n                log.warn('Failed to handle a form field');\n              }\n            } else {\n              // No handler found - might be a label-only section\n              log.debug('No handler found for section (might be non-input)');\n            }\n          } catch (error) {\n            result.fieldsProcessed++;\n            result.fieldsFailed++;\n            result.errors.push(String(error));\n            log.error(`Error processing section: ${error}`);\n          }\n        }\n\n        log.debug(`Pass ${passIndex}: handled ${newlyHandled} new elements`);\n\n        // Exit if no new elements were handled (matches Python's if newly_handled == 0: break)\n        if (newlyHandled === 0) {\n          break;\n        }\n\n        // Scroll to load more elements (virtualized lists) - matches Python's form_el.evaluate scroll\n        try {\n          const form = this.page.locator('form').first();\n          await form.evaluate((el) => el.scrollBy(0, 300));\n          await this.page.waitForTimeout(300);\n        } catch {\n          // Scroll failed - form might not exist or be scrollable\n        }\n      }\n\n      // Overall success if majority of fields worked\n      result.success = result.fieldsFailed < result.fieldsProcessed / 2;\n\n      log.info(`Page complete: ${result.fieldsProcessed - result.fieldsFailed}/${result.fieldsProcessed} fields filled`);\n\n    } catch (error) {\n      result.success = false;\n      result.errors.push(String(error));\n      log.error(`Error filling page: ${error}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Find all form sections on the current page\n   * \n   * LinkedIn Easy Apply uses .jobs-easy-apply-form-section__grouping\n   * for each form field grouping.\n   */\n  private async findFormSections(): Promise<Locator[]> {\n    // LinkedIn form section selectors\n    const sectionSelectors = [\n      '.jobs-easy-apply-form-section__grouping',\n      '.fb-dash-form-element',\n      '[data-test-form-element]',\n      '.jobs-document-upload',  // Resume upload sections\n    ];\n\n    const sections: Locator[] = [];\n    const seenElements = new Set<string>();\n\n    for (const selector of sectionSelectors) {\n      const elements = await this.page.locator(selector).all();\n      \n      for (const element of elements) {\n        // Avoid duplicates by checking unique identifier\n        try {\n          const box = await element.boundingBox();\n          if (box) {\n            const id = `${box.x}-${box.y}-${box.width}-${box.height}`;\n            if (!seenElements.has(id)) {\n              seenElements.add(id);\n              sections.push(element);\n            }\n          }\n        } catch {\n          // Element might not be visible\n        }\n      }\n    }\n\n    return sections;\n  }\n\n  /**\n   * Find the appropriate handler for a form section\n   * \n   * Uses the strategy pattern - tries each handler in order\n   * until one reports it can handle this element type.\n   */\n  private async findHandler(element: Locator): Promise<BaseFieldHandler | null> {\n    for (const handler of this.handlers) {\n      try {\n        const canHandle = await handler.canHandle(element);\n        if (canHandle) {\n          return handler;\n        }\n      } catch {\n        // Handler check failed, try next\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Update resume path for file uploads\n   */\n  setResumePath(path: string): void {\n    this.fileUploadHandler.setResumePath(path);\n  }\n\n  /**\n   * Update cover letter path for file uploads\n   */\n  setCoverLetterPath(path: string): void {\n    this.fileUploadHandler.setCoverLetterPath(path);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
