{
  "version": 3,
  "sources": ["radio-handler.ts"],
  "sourcesContent": ["/**\n * Radio Button Handler - Handles radio button groups in LinkedIn forms\n * \n * Radio buttons are used for single-choice questions like:\n * - \"Do you have experience with X?\" (Yes/No)\n * - \"What is your preferred work arrangement?\" (Remote/Hybrid/On-site)\n * - \"Are you legally authorized to work?\" (Yes/No)\n */\n\nimport type { Locator } from 'playwright';\nimport { BaseFieldHandler } from './base-handler';\nimport { createLogger } from '../../../utils/logger';\nimport { normalizeText } from '../form-utils';\n\nconst log = createLogger('RadioHandler');\n\nexport class RadioButtonHandler extends BaseFieldHandler {\n  /**\n   * Check if this element contains radio buttons\n   */\n  async canHandle(element: Locator): Promise<boolean> {\n    try {\n      const count = await element.locator('input[type=radio]').count();\n      return count > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle a radio button group\n   * \n   * Process flow:\n   * 1. Find all radio buttons in the group\n   * 2. Extract the question text\n   * 3. Get all option labels\n   * 4. Check for saved answer or ask GPT\n   * 5. Click the matching option\n   * 6. Check for validation errors and retry if needed\n   */\n  async handle(element: Locator): Promise<boolean> {\n    try {\n      const radios = await element.locator('input[type=radio]').all();\n      if (radios.length === 0) return false;\n\n      // Get question text\n      const questionText = await this.extractQuestionText(element);\n      log.debug(`Question: \"${questionText}\"`);\n\n      // Extract all options by finding labels\n      const options = await this.extractOptions(element, radios);\n      if (options.length === 0) {\n        log.warn('No options found for radio group');\n        return false;\n      }\n\n      log.debug(`Options: ${options.join(', ')}`);\n\n      // Check for saved answer first\n      let answer = this.formUtils.getSavedAnswer('radio', questionText);\n      let fromGPT = false;\n\n      // Ask GPT if no saved answer\n      if (!answer) {\n        log.debug(`Asking GPT: \"${questionText}\" with options [${options.join(', ')}]`);\n        answer = await this.gptAnswerer.answerFromOptions(questionText, options);\n        fromGPT = true;\n      }\n\n      if (!answer?.trim()) {\n        log.warn('No answer available for radio question');\n        return false;\n      }\n\n      log.info(`\u2705 Q: \"${questionText}\" \u2192 \"${answer}\"`);\n\n      // Find and click the matching radio button\n      const clicked = await this.selectOption(element, radios, answer);\n      \n      if (!clicked) {\n        log.warn(`Could not find matching option for: \"${answer}\"`);\n        return false;\n      }\n\n      // Save answer if from GPT\n      if (fromGPT) {\n        this.formUtils.rememberAnswer('radio', questionText, answer);\n      }\n\n      // Check for validation errors\n      await this.page.waitForTimeout(250);\n      const errorMsg = await this.formUtils.extractFieldErrors(element);\n      \n      if (errorMsg) {\n        log.warn(`Validation error after clicking \"${answer}\": ${errorMsg}`);\n        \n        // Retry with error context\n        const retryAnswer = await this.gptAnswerer.answerFromOptionsWithRetry(\n          questionText, options, answer, errorMsg\n        );\n\n        if (retryAnswer?.trim()) {\n          log.info(`\uD83D\uDD04 Retry answer: \"${retryAnswer}\"`);\n          const retryClicked = await this.selectOption(element, radios, retryAnswer);\n          \n          if (retryClicked) {\n            this.formUtils.rememberAnswer('radio', questionText, retryAnswer);\n            \n            // Check if error cleared\n            await this.page.waitForTimeout(250);\n            const retryError = await this.formUtils.extractFieldErrors(element);\n            if (retryError) {\n              log.error(`Retry failed, error persists: ${retryError}`);\n            } else {\n              log.info('\u2705 Retry successful, error cleared');\n            }\n          }\n        }\n      }\n\n      return true;\n\n    } catch (error) {\n      log.error(`Error handling radio buttons: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Extract option labels from radio buttons\n   */\n  private async extractOptions(element: Locator, radios: Locator[]): Promise<string[]> {\n    const options: string[] = [];\n\n    for (const radio of radios) {\n      try {\n        const radioId = await radio.getAttribute('id');\n        if (!radioId) continue;\n\n        // Find label with matching \"for\" attribute\n        const label = element.locator(`label[for=\"${radioId}\"]`).first();\n        if (await label.count() > 0) {\n          const text = await label.textContent();\n          if (text?.trim()) {\n            options.push(text.trim());\n          }\n        }\n      } catch {\n        // Skip this radio if we can't get its label\n      }\n    }\n\n    return options;\n  }\n\n  /**\n   * Find and click the radio button matching the answer\n   */\n  private async selectOption(element: Locator, radios: Locator[], answer: string): Promise<boolean> {\n    const normalizedAnswer = normalizeText(answer);\n\n    for (const radio of radios) {\n      try {\n        const radioId = await radio.getAttribute('id');\n        if (!radioId) continue;\n\n        const label = element.locator(`label[for=\"${radioId}\"]`).first();\n        if (await label.count() === 0) continue;\n\n        const labelText = await label.textContent();\n        if (!labelText) continue;\n\n        const normalizedLabel = normalizeText(labelText);\n\n        if (normalizedLabel === normalizedAnswer) {\n          // Click the label (more reliable than clicking the radio input)\n          await this.formUtils.safeClick(label);\n          await this.page.waitForTimeout(250); // Let LinkedIn process\n          return true;\n        }\n      } catch {\n        // Continue to next radio\n      }\n    }\n\n    return false;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
