{
  "version": 3,
  "sources": ["base-handler.ts"],
  "sourcesContent": ["/**\n * Base Field Handler - Abstract class for form field handlers\n * \n * All field handlers inherit from this base class.\n * Each handler is responsible for detecting and filling one type of form field.\n * \n * DESIGN PATTERN: Strategy Pattern\n * ================================\n * Each handler encapsulates a specific algorithm for handling a field type.\n * The FormHandler iterates through handlers and uses the first one that\n * says it can handle the current element.\n */\n\nimport type { Page, Locator } from 'playwright';\nimport type { GPTAnswerer } from '../../ai/gpt-answerer';\nimport type { FormUtils } from '../form-utils';\n\n/**\n * Abstract base class for all field handlers\n * \n * To create a new field handler:\n * 1. Extend this class\n * 2. Implement canHandle() to detect your field type\n * 3. Implement handle() to fill the field\n */\nexport abstract class BaseFieldHandler {\n  /**\n   * Create a new field handler\n   * \n   * @param page - Playwright Page instance for DOM interactions\n   * @param gptAnswerer - AI service for generating form responses\n   * @param formUtils - Shared utilities for form processing\n   */\n  constructor(\n    protected page: Page,\n    protected gptAnswerer: GPTAnswerer,\n    protected formUtils: FormUtils\n  ) {}\n\n  /**\n   * Check if this handler can process the given element\n   * \n   * Override this in subclasses to detect specific field types.\n   * For example, RadioButtonHandler checks for input[type=radio] elements.\n   * \n   * @param element - The form element to check\n   * @returns True if this handler can process the element\n   */\n  abstract canHandle(element: Locator): Promise<boolean>;\n\n  /**\n   * Process the form field\n   * \n   * Override this in subclasses to implement field-specific logic.\n   * This typically involves:\n   * 1. Extracting the question text\n   * 2. Getting available options (if applicable)\n   * 3. Finding a saved answer or asking GPT\n   * 4. Filling in the field\n   * \n   * @param element - The form element to process\n   * @returns True if the field was handled successfully\n   */\n  abstract handle(element: Locator): Promise<boolean>;\n\n  /**\n   * Extract question text from a form element\n   * \n   * Searches for labels, legends, aria-labels, etc.\n   * This is the text that gets sent to GPT for context.\n   * \n   * @param element - The form element to search\n   * @returns The question text, or a default value\n   */\n  protected async extractQuestionText(element: Locator): Promise<string> {\n    // Try different label sources in order of preference\n    \n    // 1. Try <legend> (for fieldsets/radio groups)\n    try {\n      const legend = element.locator('legend').first();\n      if (await legend.count() > 0) {\n        const text = await legend.textContent();\n        if (text?.trim()) return text.trim();\n      }\n    } catch { /* ignore */ }\n\n    // 2. Try <label> element\n    try {\n      const label = element.locator('label').first();\n      if (await label.count() > 0) {\n        const text = await label.textContent();\n        if (text?.trim()) return text.trim();\n      }\n    } catch { /* ignore */ }\n\n    // 3. Try data-test attribute for question title\n    try {\n      const title = element.locator('[data-test-form-builder-radio-button-form-component__title]').first();\n      if (await title.count() > 0) {\n        const text = await title.textContent();\n        if (text?.trim()) return text.trim();\n      }\n    } catch { /* ignore */ }\n\n    // 4. Try aria-label attribute\n    try {\n      const ariaLabel = await element.getAttribute('aria-label');\n      if (ariaLabel?.trim()) return ariaLabel.trim();\n    } catch { /* ignore */ }\n\n    // 5. Try input name attribute as fallback\n    try {\n      const input = element.locator('input, select, textarea').first();\n      if (await input.count() > 0) {\n        const name = await input.getAttribute('name');\n        if (name) return name;\n      }\n    } catch { /* ignore */ }\n\n    return 'unknown_question';\n  }\n\n  /**\n   * Normalize text for comparison (case-insensitive, accent-insensitive)\n   * \n   * This helps match user answers to options when there are minor differences\n   * in capitalization, accents, or whitespace.\n   */\n  protected normalizeText(text: string): string {\n    return this.formUtils.normalizeText(text);\n  }\n}\n"],
  "mappings": "AAyBO,MAAe,iBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQrC,YACY,MACA,aACA,WACV;AAHU;AACA;AACA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqCH,MAAgB,oBAAoB,SAAmC;AAIrE,QAAI;AACF,YAAM,SAAS,QAAQ,QAAQ,QAAQ,EAAE,MAAM;AAC/C,UAAI,MAAM,OAAO,MAAM,IAAI,GAAG;AAC5B,cAAM,OAAO,MAAM,OAAO,YAAY;AACtC,YAAI,MAAM,KAAK,EAAG,QAAO,KAAK,KAAK;AAAA,MACrC;AAAA,IACF,QAAQ;AAAA,IAAe;AAGvB,QAAI;AACF,YAAM,QAAQ,QAAQ,QAAQ,OAAO,EAAE,MAAM;AAC7C,UAAI,MAAM,MAAM,MAAM,IAAI,GAAG;AAC3B,cAAM,OAAO,MAAM,MAAM,YAAY;AACrC,YAAI,MAAM,KAAK,EAAG,QAAO,KAAK,KAAK;AAAA,MACrC;AAAA,IACF,QAAQ;AAAA,IAAe;AAGvB,QAAI;AACF,YAAM,QAAQ,QAAQ,QAAQ,6DAA6D,EAAE,MAAM;AACnG,UAAI,MAAM,MAAM,MAAM,IAAI,GAAG;AAC3B,cAAM,OAAO,MAAM,MAAM,YAAY;AACrC,YAAI,MAAM,KAAK,EAAG,QAAO,KAAK,KAAK;AAAA,MACrC;AAAA,IACF,QAAQ;AAAA,IAAe;AAGvB,QAAI;AACF,YAAM,YAAY,MAAM,QAAQ,aAAa,YAAY;AACzD,UAAI,WAAW,KAAK,EAAG,QAAO,UAAU,KAAK;AAAA,IAC/C,QAAQ;AAAA,IAAe;AAGvB,QAAI;AACF,YAAM,QAAQ,QAAQ,QAAQ,yBAAyB,EAAE,MAAM;AAC/D,UAAI,MAAM,MAAM,MAAM,IAAI,GAAG;AAC3B,cAAM,OAAO,MAAM,MAAM,aAAa,MAAM;AAC5C,YAAI,KAAM,QAAO;AAAA,MACnB;AAAA,IACF,QAAQ;AAAA,IAAe;AAEvB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,cAAc,MAAsB;AAC5C,WAAO,KAAK,UAAU,cAAc,IAAI;AAAA,EAC1C;AACF;",
  "names": []
}
