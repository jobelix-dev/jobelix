{
  "version": 3,
  "sources": ["base-handler.ts"],
  "sourcesContent": ["/**\n * Base Field Handler - Abstract class for form field handlers\n * \n * All field handlers inherit from this base class.\n * Each handler is responsible for detecting and filling one type of form field.\n * \n * DESIGN PATTERN: Strategy Pattern\n * ================================\n * Each handler encapsulates a specific algorithm for handling a field type.\n * The FormHandler iterates through handlers and uses the first one that\n * says it can handle the current element.\n */\n\nimport type { Page, Locator } from 'playwright-core';\nimport type { GPTAnswerer } from '../../../ai/gpt-answerer';\nimport type { FormUtils } from '../form-utils';\nimport { normalizeText } from '../form-utils';\nimport { SmartFieldMatcher } from '../utils/smart-field-matcher';\nimport { TIMEOUTS } from '../selectors';\nimport { createLogger } from '../../../utils/logger';\n\nconst log = createLogger('BaseHandler');\n\n/** Validation retry callback signature */\ntype RetryCallback = (answer: string) => Promise<void>;\n\n/**\n * Abstract base class for all field handlers\n * \n * To create a new field handler:\n * 1. Extend this class\n * 2. Implement canHandle() to detect your field type\n * 3. Implement handle() to fill the field\n */\nexport abstract class BaseFieldHandler {\n  /**\n   * Create a new field handler\n   * \n   * @param page - Playwright Page instance for DOM interactions\n   * @param gptAnswerer - AI service for generating form responses\n   * @param formUtils - Shared utilities for form processing\n   */\n  constructor(\n    protected page: Page,\n    protected gptAnswerer: GPTAnswerer,\n    protected formUtils: FormUtils\n  ) {}\n\n  /**\n   * Check if this handler can process the given element\n   * \n   * Override this in subclasses to detect specific field types.\n   * For example, RadioButtonHandler checks for input[type=radio] elements.\n   * \n   * @param element - The form element to check\n   * @returns True if this handler can process the element\n   */\n  abstract canHandle(element: Locator): Promise<boolean>;\n\n  /**\n   * Process the form field\n   * \n   * Override this in subclasses to implement field-specific logic.\n   * This typically involves:\n   * 1. Extracting the question text\n   * 2. Getting available options (if applicable)\n   * 3. Finding a saved answer or asking GPT\n   * 4. Filling in the field\n   * \n   * @param element - The form element to process\n   * @returns True if the field was handled successfully\n   */\n  abstract handle(element: Locator): Promise<boolean>;\n\n  /**\n   * Extract question text from a form element\n   * \n   * Searches for labels, legends, aria-labels, etc.\n   * This is the text that gets sent to GPT for context.\n   * \n   * @param element - The form element to search\n   * @returns The question text, or a default value\n   */\n  protected async extractQuestionText(element: Locator): Promise<string> {\n    // Helper to deduplicate text (handles \"Code paysCode pays\" -> \"Code pays\")\n    // LinkedIn sometimes includes visually-hidden duplicate text for accessibility\n    const deduplicateText = (text: string): string => {\n      const trimmed = text.trim();\n      if (trimmed.length < 4) return trimmed;\n      \n      // Check if the text is exactly doubled\n      const half = Math.floor(trimmed.length / 2);\n      const firstHalf = trimmed.substring(0, half);\n      const secondHalf = trimmed.substring(half);\n      if (firstHalf === secondHalf) {\n        return firstHalf;\n      }\n      return trimmed;\n    };\n\n    // Helper to extract visible text only (excludes .visually-hidden elements)\n    const getVisibleText = async (locator: Locator): Promise<string | null> => {\n      try {\n        // Use evaluate to exclude visually-hidden content (matches Python approach)\n        // Note: The callback runs in browser context where DOM APIs are available\n        //\n        // IMPORTANT: LinkedIn's HTML structure:\n        // - <span aria-hidden=\"true\"> = VISIBLE text (shown on page, hidden from screen readers)\n        // - <span class=\"visually-hidden\"> = HIDDEN text (for screen readers only, CSS hidden)\n        //\n        // We must ONLY remove .visually-hidden and .sr-only elements, NOT [aria-hidden=\"true\"]!\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const text = await locator.evaluate((el: any): string | null => {\n          const clone = el.cloneNode(true);\n          // Remove ONLY screen-reader-only elements (NOT aria-hidden which contains visible text!)\n          clone.querySelectorAll('.visually-hidden, .sr-only').forEach((e: any) => e.remove());\n          return clone.textContent;\n        });\n        return text?.trim() || null;\n      } catch {\n        // Fallback to regular textContent\n        const text = await locator.textContent();\n        return text?.trim() || null;\n      }\n    };\n\n    // Try different label sources in order of preference\n    \n    // 1. Try <legend> (for fieldsets/radio groups)\n    try {\n      const legend = element.locator('legend').first();\n      if (await legend.count() > 0) {\n        const text = await getVisibleText(legend);\n        if (text) return deduplicateText(text);\n      }\n    } catch { /* ignore */ }\n\n    // 2. Try <label> element\n    try {\n      const label = element.locator('label').first();\n      if (await label.count() > 0) {\n        const text = await getVisibleText(label);\n        if (text) return deduplicateText(text);\n      }\n    } catch { /* ignore */ }\n\n    // 3. Try data-test attribute for question title (radio buttons)\n    try {\n      const title = element.locator('[data-test-form-builder-radio-button-form-component__title]').first();\n      if (await title.count() > 0) {\n        const text = await getVisibleText(title);\n        if (text) return deduplicateText(text);\n      }\n    } catch { /* ignore */ }\n\n    // 4. Try data-test attribute for checkbox form title\n    try {\n      const checkboxTitle = element.locator('[data-test-checkbox-form-title]').first();\n      if (await checkboxTitle.count() > 0) {\n        const text = await getVisibleText(checkboxTitle);\n        if (text) return deduplicateText(text);\n      }\n    } catch { /* ignore */ }\n\n    // 5. Try data-test attribute for text entity list title (dropdowns with labels)\n    try {\n      const textEntityTitle = element.locator('[data-test-text-entity-list-form-title]').first();\n      if (await textEntityTitle.count() > 0) {\n        const text = await getVisibleText(textEntityTitle);\n        if (text) return deduplicateText(text);\n      }\n    } catch { /* ignore */ }\n\n    // 6. Try aria-label attribute\n    try {\n      const ariaLabel = await element.getAttribute('aria-label');\n      if (ariaLabel?.trim()) return deduplicateText(ariaLabel.trim());\n    } catch { /* ignore */ }\n\n    // 7. Try input name attribute as fallback\n    try {\n      const input = element.locator('input, select, textarea').first();\n      if (await input.count() > 0) {\n        const name = await input.getAttribute('name');\n        if (name) return name;\n      }\n    } catch { /* ignore */ }\n\n    return 'unknown_question';\n  }\n\n  /**\n   * Normalize text for comparison (case-insensitive, accent-insensitive)\n   * \n   * This helps match user answers to options when there are minor differences\n   * in capitalization, accents, or whitespace.\n   */\n  protected normalizeText(text: string): string {\n    return normalizeText(text);\n  }\n\n  /**\n   * Create a SmartFieldMatcher instance for resume-based field matching\n   */\n  protected createSmartMatcher(): SmartFieldMatcher {\n    return new SmartFieldMatcher(this.gptAnswerer.resume ?? undefined);\n  }\n\n  /**\n   * Handle validation errors with GPT retry\n   * \n   * Consolidates the common pattern of:\n   * 1. Check for validation error message\n   * 2. If error, ask GPT for alternative answer\n   * 3. Fill with retry answer and save it\n   * \n   * @param element - Form element to check for errors\n   * @param fieldType - Type of field for answer caching\n   * @param questionText - The question being asked\n   * @param originalAnswer - The answer that failed validation\n   * @param retryFn - GPT retry function to call\n   * @param fillCallback - Callback to fill in the new answer\n   */\n  protected async handleValidationError(\n    element: Locator,\n    fieldType: string,\n    questionText: string,\n    originalAnswer: string,\n    retryFn: (question: string, answer: string, error: string) => Promise<string | undefined>,\n    fillCallback: RetryCallback\n  ): Promise<void> {\n    await this.page.waitForTimeout(TIMEOUTS.medium);\n    \n    const errorMsg = await this.formUtils.extractFieldErrors(element);\n    if (!errorMsg) return;\n\n    log.warn(`Validation error for \"${fieldType}\": ${errorMsg}`);\n\n    const retryAnswer = await retryFn(questionText, originalAnswer, errorMsg);\n    if (retryAnswer) {\n      await fillCallback(retryAnswer);\n      this.formUtils.rememberAnswer(fieldType, questionText, retryAnswer);\n      log.info(`\u2705 Retry answer applied: \"${retryAnswer.substring(0, 50)}...\"`);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
