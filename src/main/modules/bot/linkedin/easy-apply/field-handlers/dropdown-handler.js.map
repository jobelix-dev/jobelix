{
  "version": 3,
  "sources": ["dropdown-handler.ts"],
  "sourcesContent": ["/**\n * Dropdown Handler - Handles <select> elements in LinkedIn forms\n * \n * Dropdowns are used for questions like:\n * - \"Phone country code\" (+1, +44, +33, etc.)\n * - \"Years of experience\" (0-1, 2-3, 4-5, etc.)\n * - \"Education level\" (Bachelor's, Master's, etc.)\n */\n\nimport type { Locator } from 'playwright';\nimport { BaseFieldHandler } from './base-handler';\nimport { createLogger } from '../../../utils/logger';\nimport { normalizeText } from '../form-utils';\n\nconst log = createLogger('DropdownHandler');\n\nexport class DropdownHandler extends BaseFieldHandler {\n  /**\n   * Check if this element contains a select dropdown\n   */\n  async canHandle(element: Locator): Promise<boolean> {\n    try {\n      const count = await element.locator('select').count();\n      return count > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle a dropdown select field\n   * \n   * Process flow:\n   * 1. Find the select element\n   * 2. Extract question text\n   * 3. Get all options (skip placeholder)\n   * 4. Try saved answer \u2192 smart match \u2192 GPT\n   * 5. Select the matching option\n   */\n  async handle(element: Locator): Promise<boolean> {\n    try {\n      const select = element.locator('select').first();\n      if (await select.count() === 0) return false;\n\n      // Get question text\n      const questionText = await this.extractQuestionText(element);\n      log.debug(`Question: \"${questionText}\"`);\n\n      // Get all options\n      const options = await this.extractOptions(select);\n      if (options.length === 0) {\n        log.warn('No options found for dropdown');\n        return false;\n      }\n\n      log.debug(`Options: ${options.slice(0, 5).join(', ')}${options.length > 5 ? '...' : ''}`);\n\n      // Try to get answer\n      let answer: string | undefined;\n      let fromGPT = false;\n\n      // 1. Check saved answers\n      answer = this.formUtils.getSavedAnswer('dropdown', questionText);\n\n      // 2. Try smart matching (phone prefix, country, etc.)\n      if (!answer) {\n        answer = await this.smartMatch(element, questionText, options);\n      }\n\n      // 3. Ask GPT\n      if (!answer) {\n        log.debug(`Asking GPT: \"${questionText}\"`);\n        answer = await this.gptAnswerer.answerFromOptions(questionText, options);\n        fromGPT = true;\n      }\n\n      if (!answer?.trim()) {\n        log.warn('No answer available for dropdown');\n        return false;\n      }\n\n      log.info(`\u2705 Q: \"${questionText}\" \u2192 \"${answer}\"`);\n\n      // Select the option\n      const selected = await this.selectOption(select, options, answer);\n      \n      if (!selected) {\n        log.warn(`Could not find matching option for: \"${answer}\"`);\n        return false;\n      }\n\n      // Save if from smart match or GPT\n      if (fromGPT) {\n        this.formUtils.rememberAnswer('dropdown', questionText, answer);\n      }\n\n      // Check for validation errors\n      await this.page.waitForTimeout(500);\n      const errorMsg = await this.formUtils.extractFieldErrors(element);\n      \n      if (errorMsg) {\n        log.warn(`Validation error: ${errorMsg}`);\n        // Retry with error context\n        const retryAnswer = await this.gptAnswerer.answerFromOptionsWithRetry(\n          questionText, options, answer, errorMsg\n        );\n        if (retryAnswer) {\n          await this.selectOption(select, options, retryAnswer);\n          this.formUtils.rememberAnswer('dropdown', questionText, retryAnswer);\n        }\n      }\n\n      return true;\n\n    } catch (error) {\n      log.error(`Error handling dropdown: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Extract options from select element\n   * Skips placeholder options (empty value or \"Select...\")\n   */\n  private async extractOptions(select: Locator): Promise<string[]> {\n    const options: string[] = [];\n    const optionElements = await select.locator('option').all();\n\n    for (let i = 0; i < optionElements.length; i++) {\n      try {\n        const opt = optionElements[i];\n        const text = await opt.textContent();\n        const value = await opt.getAttribute('value');\n\n        // Skip placeholder options (first with empty value or \"Select...\")\n        if (i === 0 && (!value || text?.toLowerCase().includes('select'))) {\n          continue;\n        }\n\n        if (text?.trim()) {\n          options.push(text.trim());\n        }\n      } catch {\n        // Skip problematic options\n      }\n    }\n\n    return options;\n  }\n\n  /**\n   * Smart matching for common dropdown types\n   * \n   * Handles special cases where we can infer the answer from context:\n   * - Phone prefix \u2192 match user's phone number\n   * - Country \u2192 use resume country\n   */\n  private async smartMatch(\n    element: Locator,\n    questionText: string,\n    options: string[]\n  ): Promise<string | undefined> {\n    const questionLower = questionText.toLowerCase();\n\n    // Phone prefix detection\n    if (questionLower.includes('phone') || questionLower.includes('prefix') || questionLower.includes('code')) {\n      // Check if element has phone-related ID\n      const selectId = await element.locator('select').first().getAttribute('id') || '';\n      if (selectId.includes('phonePrefix') || selectId.includes('countryCode')) {\n        // Try to find common country codes\n        // This would be better with resume data, but for now use common defaults\n        const preferredPrefixes = ['+1', '+44', '+33', '+49'];\n        for (const prefix of preferredPrefixes) {\n          const match = options.find(o => o.includes(prefix));\n          if (match) {\n            log.debug(`Smart match (phone prefix): \"${match}\"`);\n            return match;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Select option by label (handles minor text differences)\n   */\n  private async selectOption(select: Locator, options: string[], answer: string): Promise<boolean> {\n    const normalizedAnswer = normalizeText(answer);\n\n    for (const option of options) {\n      const normalizedOption = normalizeText(option);\n      \n      if (normalizedOption === normalizedAnswer) {\n        try {\n          await select.selectOption({ label: option });\n          await this.page.waitForTimeout(500);\n          return true;\n        } catch (error) {\n          log.debug(`Failed to select \"${option}\": ${error}`);\n        }\n      }\n    }\n\n    // Fallback: try partial match\n    for (const option of options) {\n      if (normalizeText(option).includes(normalizedAnswer) || \n          normalizedAnswer.includes(normalizeText(option))) {\n        try {\n          await select.selectOption({ label: option });\n          await this.page.waitForTimeout(500);\n          return true;\n        } catch {\n          // Continue\n        }\n      }\n    }\n\n    return false;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
