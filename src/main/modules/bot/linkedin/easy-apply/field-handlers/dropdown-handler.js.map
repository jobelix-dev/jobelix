{
  "version": 3,
  "sources": ["dropdown-handler.ts"],
  "sourcesContent": ["/**\n * Dropdown Handler - Handles <select> elements in LinkedIn forms\n * \n * Dropdowns are used for questions like:\n * - \"Phone country code\" (+1, +44, +33, etc.)\n * - \"Years of experience\" (0-1, 2-3, 4-5, etc.)\n * - \"Education level\" (Bachelor's, Master's, etc.)\n */\n\nimport type { Locator } from 'playwright';\nimport { BaseFieldHandler } from './base-handler';\nimport { createLogger } from '../../../utils/logger';\nimport { normalizeText } from '../form-utils';\n\nconst log = createLogger('DropdownHandler');\n\nexport class DropdownHandler extends BaseFieldHandler {\n  /**\n   * Check if this element contains a select dropdown\n   */\n  async canHandle(element: Locator): Promise<boolean> {\n    try {\n      const count = await element.locator('select').count();\n      return count > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle a dropdown select field\n   * \n   * Process flow:\n   * 1. Find the select element\n   * 2. Extract question text\n   * 3. Get all options (skip placeholder)\n   * 4. Try saved answer \u2192 smart match \u2192 GPT\n   * 5. Select the matching option\n   */\n  async handle(element: Locator): Promise<boolean> {\n    try {\n      const select = element.locator('select').first();\n      if (await select.count() === 0) return false;\n\n      // Get question text\n      const questionText = await this.extractQuestionText(element);\n      log.debug(`Question: \"${questionText}\"`);\n\n      // Get all options\n      const options = await this.extractOptions(select);\n      if (options.length === 0) {\n        log.warn('No options found for dropdown');\n        return false;\n      }\n\n      log.debug(`Options: ${options.slice(0, 5).join(', ')}${options.length > 5 ? '...' : ''}`);\n\n      // Try to get answer\n      let answer: string | undefined;\n      let fromGPT = false;\n\n      // 1. Check saved answers\n      answer = this.formUtils.getSavedAnswer('dropdown', questionText);\n\n      // 2. Try smart matching (phone prefix, country, etc.)\n      if (!answer) {\n        answer = await this.smartMatch(element, questionText, options);\n      }\n\n      // 3. Ask GPT (with option truncation for large lists)\n      if (!answer) {\n        log.debug(`Asking GPT: \"${questionText}\"`);\n        \n        // For very large option lists (e.g., thousands of schools), truncate to avoid \"message too long\"\n        const MAX_OPTIONS_FOR_GPT = 100;\n        let optionsForGPT = options;\n        \n        if (options.length > MAX_OPTIONS_FOR_GPT) {\n          log.warn(`Large dropdown (${options.length} options) - truncating to ${MAX_OPTIONS_FOR_GPT} for GPT`);\n          // Keep first 100 options (they're usually sorted alphabetically)\n          optionsForGPT = options.slice(0, MAX_OPTIONS_FOR_GPT);\n          \n          // If this is a school field and we couldn't match from resume, log a warning\n          const questionLower = questionText.toLowerCase();\n          if (questionLower.includes('school') || questionLower.includes('university')) {\n            log.error(`[SCHOOL] Could not find resume school in ${options.length} options - GPT will only see first ${MAX_OPTIONS_FOR_GPT}`);\n          }\n        }\n        \n        answer = await this.gptAnswerer.answerFromOptions(questionText, optionsForGPT);\n        fromGPT = true;\n      }\n\n      if (!answer?.trim()) {\n        log.warn('No answer available for dropdown');\n        return false;\n      }\n\n      log.info(`\u2705 Q: \"${questionText}\" \u2192 \"${answer}\"`);\n\n      // Select the option\n      const selected = await this.selectOption(select, options, answer);\n      \n      if (!selected) {\n        log.warn(`Could not find matching option for: \"${answer}\"`);\n        return false;\n      }\n\n      // Save if from smart match or GPT\n      if (fromGPT) {\n        this.formUtils.rememberAnswer('dropdown', questionText, answer);\n      }\n\n      // Check for validation errors\n      await this.page.waitForTimeout(500);\n      const errorMsg = await this.formUtils.extractFieldErrors(element);\n      \n      if (errorMsg) {\n        log.warn(`Validation error: ${errorMsg}`);\n        // Retry with error context\n        const retryAnswer = await this.gptAnswerer.answerFromOptionsWithRetry(\n          questionText, options, answer, errorMsg\n        );\n        if (retryAnswer) {\n          await this.selectOption(select, options, retryAnswer);\n          this.formUtils.rememberAnswer('dropdown', questionText, retryAnswer);\n        }\n      }\n\n      return true;\n\n    } catch (error) {\n      log.error(`Error handling dropdown: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Extract options from select element\n   * Skips placeholder options (empty value or \"Select...\")\n   */\n  private async extractOptions(select: Locator): Promise<string[]> {\n    const options: string[] = [];\n    const optionElements = await select.locator('option').all();\n\n    for (let i = 0; i < optionElements.length; i++) {\n      try {\n        const opt = optionElements[i];\n        const text = await opt.textContent();\n        const value = await opt.getAttribute('value');\n\n        // Skip placeholder options (first with empty value or \"Select...\")\n        if (i === 0 && (!value || text?.toLowerCase().includes('select'))) {\n          continue;\n        }\n\n        if (text?.trim()) {\n          options.push(text.trim());\n        }\n      } catch {\n        // Skip problematic options\n      }\n    }\n\n    return options;\n  }\n\n  /**\n   * Smart matching for common dropdown types\n   * \n   * Handles special cases where we can infer the answer from context:\n   * - Phone prefix \u2192 match user's phone number\n   * - Country \u2192 use resume country\n   * - School/University \u2192 use resume education\n   */\n  private async smartMatch(\n    element: Locator,\n    questionText: string,\n    options: string[]\n  ): Promise<string | undefined> {\n    const questionLower = questionText.toLowerCase();\n    const resume = this.gptAnswerer.resume;\n\n    // School/University detection - CRITICAL for large dropdowns\n    if (questionLower.includes('school') || questionLower.includes('university') || \n        questionLower.includes('college') || questionLower.includes('institution')) {\n      log.debug('[SMART MATCH] Detected school/university field');\n      \n      // Alternative names mapping for common schools\n      // LinkedIn often uses different naming conventions\n      const alternativeNames: Record<string, string[]> = {\n        'universit\u00E9 psl': ['Paris Sciences et Lettres', 'PSL University', 'PSL Research University'],\n        'psl': ['Paris Sciences et Lettres', 'PSL University'],\n        'institut polytechnique de paris': ['IP Paris', 'Polytechnique Paris', 'Institut Polytechnique'],\n        'telecom sudparis': ['T\u00E9l\u00E9com SudParis', 'Telecom SudParis', 'TSP'],\n        'telecom paris': ['T\u00E9l\u00E9com Paris', 'ENST'],\n        'ecole polytechnique': ['Polytechnique', 'X'],\n        'hec paris': ['HEC', 'HEC School of Management'],\n        'sciences po': ['Sciences Po Paris', 'Institut d\\'\u00C9tudes Politiques'],\n        'ens': ['\u00C9cole Normale Sup\u00E9rieure', 'ENS Paris', 'Normale Sup'],\n        'centrale': ['CentraleSup\u00E9lec', '\u00C9cole Centrale'],\n        'mines': ['MINES ParisTech', '\u00C9cole des Mines'],\n        'sainte-genevi\u00E8ve': ['Ginette', 'Sainte Genevi\u00E8ve'],\n      };\n      \n      // Get schools from resume education\n      if (resume?.education && resume.education.length > 0) {\n        // Try each education institution from resume\n        for (const edu of resume.education) {\n          const institution = edu.institution || edu.school;\n          if (!institution) continue;\n          \n          const instLower = institution.toLowerCase();\n          log.debug(`[SMART MATCH] Checking resume institution: \"${institution}\"`);\n          \n          // Try exact match first\n          const exactMatch = options.find(o => \n            o.toLowerCase() === instLower\n          );\n          if (exactMatch) {\n            log.info(`[SMART MATCH] \u2705 Found exact school match: \"${exactMatch}\"`);\n            return exactMatch;\n          }\n          \n          // Try alternative names\n          for (const [key, alts] of Object.entries(alternativeNames)) {\n            if (instLower.includes(key)) {\n              for (const alt of alts) {\n                const altMatch = options.find(o => \n                  o.toLowerCase().includes(alt.toLowerCase()) ||\n                  alt.toLowerCase().includes(o.toLowerCase())\n                );\n                if (altMatch) {\n                  log.info(`[SMART MATCH] \u2705 Found alternative name match: \"${altMatch}\" (via \"${alt}\")`);\n                  return altMatch;\n                }\n              }\n            }\n          }\n          \n          // Try partial match (institution name contained in option)\n          const partialMatch = options.find(o => \n            o.toLowerCase().includes(instLower) ||\n            instLower.includes(o.toLowerCase())\n          );\n          if (partialMatch) {\n            log.info(`[SMART MATCH] \u2705 Found partial school match: \"${partialMatch}\"`);\n            return partialMatch;\n          }\n          \n          // Try word-by-word matching for significant words (>4 chars)\n          const institutionWords = instLower.split(/[\\s\\-()]+/).filter(w => w.length > 4);\n          for (const word of institutionWords) {\n            // Skip common words that would match too broadly\n            if (['university', 'institut', '\u00E9cole', 'ecole', 'paris', 'france'].includes(word)) continue;\n            const wordMatch = options.find(o => o.toLowerCase().includes(word));\n            if (wordMatch) {\n              log.info(`[SMART MATCH] \u2705 Found word-based school match: \"${wordMatch}\" (word: \"${word}\")`);\n              return wordMatch;\n            }\n          }\n        }\n        log.warn('[SMART MATCH] No school match found in options - resume schools may not be in dropdown');\n      }\n    }\n\n    // Phone prefix detection\n    if (questionLower.includes('phone') || questionLower.includes('prefix') || questionLower.includes('code')) {\n      // Check if element has phone-related ID\n      const selectId = await element.locator('select').first().getAttribute('id') || '';\n      if (selectId.includes('phonePrefix') || selectId.includes('countryCode')) {\n        // Try to find common country codes\n        // This would be better with resume data, but for now use common defaults\n        const preferredPrefixes = ['+1', '+44', '+33', '+49'];\n        for (const prefix of preferredPrefixes) {\n          const match = options.find(o => o.includes(prefix));\n          if (match) {\n            log.debug(`Smart match (phone prefix): \"${match}\"`);\n            return match;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Select option by label (handles minor text differences)\n   */\n  private async selectOption(select: Locator, options: string[], answer: string): Promise<boolean> {\n    const normalizedAnswer = normalizeText(answer);\n\n    for (const option of options) {\n      const normalizedOption = normalizeText(option);\n      \n      if (normalizedOption === normalizedAnswer) {\n        try {\n          await select.selectOption({ label: option });\n          await this.page.waitForTimeout(500);\n          return true;\n        } catch (error) {\n          log.debug(`Failed to select \"${option}\": ${error}`);\n        }\n      }\n    }\n\n    // Fallback: try partial match\n    for (const option of options) {\n      if (normalizeText(option).includes(normalizedAnswer) || \n          normalizedAnswer.includes(normalizeText(option))) {\n        try {\n          await select.selectOption({ label: option });\n          await this.page.waitForTimeout(500);\n          return true;\n        } catch {\n          // Continue\n        }\n      }\n    }\n\n    return false;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
