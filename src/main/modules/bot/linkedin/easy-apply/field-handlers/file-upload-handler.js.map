{
  "version": 3,
  "sources": ["file-upload-handler.ts"],
  "sourcesContent": ["/**\n * File Upload Handler - Handles file upload fields (resume, cover letter, etc.)\n * \n * Supports:\n * - Resume upload (with parallel tailoring support)\n * - Cover letter upload (AI-generated on-the-fly if not provided)\n * - Previously uploaded file selection\n */\n\nimport type { Locator, Page } from 'playwright';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { BaseFieldHandler } from './base-handler';\nimport { createLogger } from '../../../utils/logger';\nimport { detectDocumentType } from '../utils/document-type-detector';\nimport { generateCoverLetterPdf, cleanupGeneratedCoverLetter } from '../utils/cover-letter-generator';\nimport { TIMEOUTS } from '../selectors';\n\nconst log = createLogger('FileUploadHandler');\n\nexport class FileUploadHandler extends BaseFieldHandler {\n  private resumePath: string | null;\n  private coverLetterPath: string | null;\n  private pendingTailoredResume: Promise<string | null> | null = null;\n\n  constructor(\n    page: Page,\n    gptAnswerer: any,\n    formUtils: any,\n    resumePath: string | null = null,\n    coverLetterPath: string | null = null\n  ) {\n    super(page, gptAnswerer, formUtils);\n    this.resumePath = resumePath;\n    this.coverLetterPath = coverLetterPath;\n  }\n\n  /**\n   * Check if this element is a file upload field\n   */\n  async canHandle(element: Locator): Promise<boolean> {\n    try {\n      if (await element.locator('input[type=\"file\"]').count() > 0) return true;\n      if (await element.locator('text=/upload|attach|document/i').count() > 0) return true;\n      if (await element.locator('[data-test-document-upload]').count() > 0) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle a file upload field\n   */\n  async handle(element: Locator): Promise<boolean> {\n    try {\n      const fileInput = element.locator('input[type=\"file\"]').first();\n      const questionText = await this.extractQuestionText(element);\n      log.debug(`Question text: \"${questionText}\"`);\n\n      // Detect document type (resume vs cover letter)\n      const docType = await detectDocumentType(fileInput, questionText);\n      log.debug(`Upload type: resume=${docType.isResumeUpload}, coverLetter=${docType.isCoverLetterUpload}, by=${docType.detectedBy}`);\n\n      // Await pending tailored resume if this is a resume upload\n      if (docType.isResumeUpload) {\n        await this.awaitPendingResume();\n      }\n\n      // Check if file is already uploaded\n      if (await this.hasExistingUpload(element)) {\n        log.debug('File already uploaded');\n        if (docType.isResumeUpload && this.resumePath) {\n          await this.ensureCorrectResumeSelected(element);\n        }\n        return true;\n      }\n\n      // Try to use previously uploaded file\n      if (await this.tryUsePreviousUpload(element)) {\n        log.info('\u2705 Selected previously uploaded file');\n        if (docType.isResumeUpload && this.resumePath) {\n          await this.ensureCorrectResumeSelected(element);\n        }\n        return true;\n      }\n\n      // Determine which file to upload\n      const filePath = await this.getFileToUpload(docType);\n      if (!filePath) {\n        log.warn(`No file available for upload: \"${questionText}\"`);\n        return true; // Don't block - LinkedIn often allows skipping\n      }\n\n      // Upload the file\n      const success = await this.uploadFile(element, filePath);\n      if (success) {\n        log.info(`\u2705 Uploaded file: ${path.basename(filePath)}`);\n        if (docType.isResumeUpload) {\n          await this.ensureCorrectResumeSelected(element);\n        }\n      }\n\n      return success;\n    } catch (error) {\n      log.error(`Error handling file upload: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Get the file path to upload based on document type\n   */\n  private async getFileToUpload(docType: { isResumeUpload: boolean; isCoverLetterUpload: boolean }): Promise<string | null> {\n    if (docType.isCoverLetterUpload) {\n      if (this.coverLetterPath) return this.coverLetterPath;\n      \n      log.info('\uD83D\uDCDD No cover letter provided, generating one with AI...');\n      return generateCoverLetterPdf(this.page, (q) => this.gptAnswerer.answerTextual(q));\n    }\n\n    // Default to resume\n    return this.resumePath;\n  }\n\n  /**\n   * Check if a file is already uploaded\n   */\n  private async hasExistingUpload(element: Locator): Promise<boolean> {\n    const selectors = [\n      '.jobs-document-upload__filename',\n      '[data-test-document-upload-success]',\n      '.jobs-document-upload-redesign-card__file-name'\n    ];\n\n    for (const selector of selectors) {\n      try {\n        const el = element.locator(selector).first();\n        if (await el.count() > 0) {\n          const text = await el.textContent();\n          if (text?.trim()) return true;\n        }\n      } catch {\n        continue;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Try to use a previously uploaded file\n   */\n  private async tryUsePreviousUpload(element: Locator): Promise<boolean> {\n    const selectors = [\n      '[data-test-document-upload-file-card]',\n      'input[type=\"radio\"][data-test-resume-radio]'\n    ];\n\n    for (const selector of selectors) {\n      try {\n        const el = element.locator(selector).first();\n        if (await el.count() > 0) {\n          await el.click();\n          await this.page.waitForTimeout(TIMEOUTS.medium);\n          return true;\n        }\n      } catch {\n        continue;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Upload a file to the input\n   */\n  private async uploadFile(element: Locator, filePath: string): Promise<boolean> {\n    try {\n      const fileInput = element.locator('input[type=\"file\"]').first();\n\n      if (await fileInput.count() > 0) {\n        // Make input interactable\n        try {\n          await fileInput.evaluate((el) => (el as HTMLElement).classList.remove('hidden'));\n        } catch {\n          // May already be visible\n        }\n\n        log.info(`Uploading file: ${filePath}`);\n        await fileInput.setInputFiles(filePath);\n\n        // Dispatch events to trigger LinkedIn's UI update\n        try {\n          for (const evt of ['change', 'blur']) {\n            await fileInput.evaluate((el, e) => {\n              (el as HTMLElement).dispatchEvent(new Event(e, { bubbles: true }));\n            }, evt);\n          }\n        } catch {\n          // Ignore event dispatch errors\n        }\n\n        await this.page.waitForTimeout(TIMEOUTS.long);\n        return true;\n      }\n\n      // Fallback: Try clicking upload button and using file chooser\n      const uploadButton = element.locator('button:has-text(\"Upload\"), label:has-text(\"Upload\")').first();\n      if (await uploadButton.count() > 0) {\n        const [fileChooser] = await Promise.all([\n          this.page.waitForEvent('filechooser', { timeout: 5000 }),\n          uploadButton.click()\n        ]);\n        await fileChooser.setFiles(filePath);\n        await this.page.waitForTimeout(TIMEOUTS.long);\n        return true;\n      }\n\n      log.warn('Could not find file input or upload button');\n      return false;\n    } catch (error) {\n      log.debug(`Upload error: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Ensure the correct resume is selected in LinkedIn's UI\n   */\n  private async ensureCorrectResumeSelected(element: Locator): Promise<void> {\n    if (!this.resumePath) return;\n\n    try {\n      const expectedFilename = path.basename(this.resumePath);\n      log.debug(`Ensuring resume is selected: ${expectedFilename}`);\n\n      await this.page.waitForTimeout(TIMEOUTS.medium);\n\n      const resumeCards = await element.locator('div.jobs-document-upload-redesign-card__container').all();\n      if (resumeCards.length === 0) {\n        log.debug('No resume selection cards found');\n        return;\n      }\n\n      log.debug(`Found ${resumeCards.length} resume cards`);\n\n      // Find the card with our resume filename\n      for (const card of resumeCards) {\n        try {\n          const filenameEl = card.locator('h3.jobs-document-upload-redesign-card__file-name').first();\n          if (await filenameEl.count() === 0) continue;\n\n          const cardFilename = await filenameEl.textContent();\n          if (cardFilename?.trim() !== expectedFilename) continue;\n\n          log.info(`Found matching resume card: ${cardFilename?.trim()}`);\n\n          // Check if already selected\n          const cardClasses = await card.getAttribute('class') || '';\n          if (cardClasses.includes('--selected')) {\n            log.info('\u2705 Correct resume already selected');\n            return;\n          }\n\n          // Select the card\n          await this.selectResumeCard(card, expectedFilename);\n          return;\n        } catch {\n          continue;\n        }\n      }\n\n      log.warn(`Could not find card for ${expectedFilename}`);\n    } catch (error) {\n      log.warn(`Error ensuring correct resume selection: ${error}`);\n    }\n  }\n\n  /**\n   * Select a resume card by clicking its radio or the card itself\n   */\n  private async selectResumeCard(card: Locator, filename: string): Promise<void> {\n    try {\n      const radioLabel = card.locator('label.jobs-document-upload-redesign-card__toggle-label').first();\n      const radioInput = card.locator('input[type=\"radio\"]').first();\n\n      if (await radioLabel.count() > 0) {\n        await this.page.evaluate((el: any) => el.click(), await radioLabel.elementHandle());\n      } else if (await radioInput.count() > 0) {\n        await radioInput.click();\n      } else {\n        await this.page.evaluate((el: any) => el.click(), await card.elementHandle());\n      }\n\n      log.info(`\u2705 Selected resume: ${filename}`);\n      await this.page.waitForTimeout(TIMEOUTS.short);\n    } catch (e) {\n      log.warn(`Failed to select resume: ${e}`);\n    }\n  }\n\n  /**\n   * Await any pending tailored resume generation\n   */\n  private async awaitPendingResume(): Promise<void> {\n    if (!this.pendingTailoredResume) return;\n\n    log.info('\u23F3 Waiting for tailored resume to complete...');\n    try {\n      const tailoredPath = await this.pendingTailoredResume;\n      this.pendingTailoredResume = null;\n\n      if (tailoredPath) {\n        this.resumePath = tailoredPath;\n        log.info(`\u2705 Tailored resume ready: ${tailoredPath}`);\n      } else {\n        log.warn('Tailored resume generation failed, using original');\n      }\n    } catch (error) {\n      log.error(`Error awaiting tailored resume: ${error}`);\n      this.pendingTailoredResume = null;\n    }\n  }\n\n  // Public API for setting paths\n  setResumePath(newPath: string): void {\n    this.resumePath = newPath;\n    this.pendingTailoredResume = null;\n    log.debug(`Resume path updated: ${newPath}`);\n  }\n\n  setPendingTailoredResume(promise: Promise<string | null>): void {\n    this.pendingTailoredResume = promise;\n    log.debug('Pending tailored resume Promise set');\n  }\n\n  setCoverLetterPath(newPath: string): void {\n    this.coverLetterPath = newPath;\n  }\n\n  cleanup(): void {\n    cleanupGeneratedCoverLetter();\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
