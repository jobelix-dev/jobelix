{
  "version": 3,
  "sources": ["file-upload-handler.ts"],
  "sourcesContent": ["/**\n * File Upload Handler - Handles file upload fields (resume, cover letter, etc.)\n * \n * LinkedIn file uploads can include:\n * - Resume upload\n * - Cover letter upload (AI-generated on-the-fly if not provided)\n * - Portfolio documents\n * - Previously uploaded file selection\n */\n\nimport type { Locator } from 'playwright';\nimport type { Page } from 'playwright';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport { BaseFieldHandler } from './base-handler';\nimport { createLogger } from '../../../utils/logger';\n\nconst log = createLogger('FileUploadHandler');\n\nexport class FileUploadHandler extends BaseFieldHandler {\n  private resumePath: string | null;\n  private coverLetterPath: string | null;\n  private generatedCoverLetterPath: string | null = null;\n\n  constructor(\n    page: Page,\n    gptAnswerer: any,\n    formUtils: any,\n    resumePath: string | null = null,\n    coverLetterPath: string | null = null\n  ) {\n    super(page, gptAnswerer, formUtils);\n    this.resumePath = resumePath;\n    this.coverLetterPath = coverLetterPath;\n  }\n\n  /**\n   * Check if this element is a file upload field\n   */\n  async canHandle(element: Locator): Promise<boolean> {\n    try {\n      // Check for file input\n      const fileInput = element.locator('input[type=\"file\"]');\n      if (await fileInput.count() > 0) return true;\n\n      // Check for upload button/label\n      const uploadLabel = element.locator('text=/upload|attach|document/i');\n      if (await uploadLabel.count() > 0) return true;\n\n      // Check for resume-specific attributes\n      const resumeSection = element.locator('[data-test-document-upload]');\n      if (await resumeSection.count() > 0) return true;\n\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle a file upload field\n   */\n  async handle(element: Locator): Promise<boolean> {\n    try {\n      // Determine the type of document being requested\n      // MATCHES PYTHON: Check input id attribute first (more reliable than question text)\n      let isResumeUpload = true;\n      let isCoverLetterUpload = false;\n      \n      const fileInput = element.locator('input[type=\"file\"]').first();\n      if (await fileInput.count() > 0) {\n        try {\n          const inputId = ((await fileInput.getAttribute('id')) || '').toLowerCase();\n          log.debug(`File input id: \"${inputId}\"`);\n          \n          isCoverLetterUpload = ['cover', 'motivation'].some(k => inputId.includes(k));\n          isResumeUpload = !isCoverLetterUpload;\n        } catch {\n          // Fallback to question text detection\n        }\n      }\n      \n      // Also check question text as secondary signal\n      const questionText = await this.extractQuestionText(element);\n      const lowerQuestion = questionText.toLowerCase();\n      \n      if (lowerQuestion.includes('cover letter') || lowerQuestion.includes('coverletter') || lowerQuestion.includes('motivation')) {\n        isCoverLetterUpload = true;\n        isResumeUpload = false;\n      } else if (lowerQuestion.includes('resume') || lowerQuestion.includes('cv')) {\n        isResumeUpload = true;\n        isCoverLetterUpload = false;\n      }\n      \n      log.debug(`Upload type: resume=${isResumeUpload}, coverLetter=${isCoverLetterUpload}`);\n\n      // Check if file is already uploaded (LinkedIn shows a green checkmark or filename)\n      const hasUploadedFile = await this.checkExistingUpload(element);\n      if (hasUploadedFile) {\n        log.debug('File already uploaded');\n        // Even if already uploaded, ensure correct one is selected (CRITICAL - matches Python)\n        if (isResumeUpload && this.resumePath) {\n          await this.ensureCorrectResumeSelected(element);\n        }\n        return true;\n      }\n\n      // Check for \"Use previous resume\" option first\n      const usedPrevious = await this.tryUsePreviousUpload(element);\n      if (usedPrevious) {\n        log.info('\u2705 Selected previously uploaded file');\n        // Ensure the correct one is selected after choosing \"use previous\"\n        if (isResumeUpload && this.resumePath) {\n          await this.ensureCorrectResumeSelected(element);\n        }\n        return true;\n      }\n\n      // Determine which file to upload (uses detection from earlier)\n      let filePath: string | null = null;\n      \n      if (isResumeUpload) {\n        filePath = this.resumePath;\n        log.debug('Uploading resume');\n      } else if (isCoverLetterUpload) {\n        // Try existing cover letter first, then generate one\n        filePath = this.coverLetterPath;\n        if (!filePath) {\n          log.info('\uD83D\uDCDD No cover letter provided, generating one with AI...');\n          filePath = await this.generateCoverLetterPdf();\n        }\n        log.debug('Uploading cover letter');\n      } else {\n        // Default to resume for generic document requests\n        filePath = this.resumePath;\n        log.debug('Uploading resume (default)');\n      }\n\n      if (!filePath) {\n        log.warn(`No file available for upload: \"${questionText}\"`);\n        // Return true to not block the application - LinkedIn often allows skipping\n        return true;\n      }\n\n      // Upload the file\n      const success = await this.uploadFile(element, filePath);\n      \n      if (success) {\n        log.info(`\u2705 Uploaded file: ${filePath}`);\n        \n        // CRITICAL: Ensure the newly uploaded resume is selected (matches Python bot)\n        // LinkedIn may auto-select an older resume from the list\n        if (isResumeUpload) {\n          await this.ensureCorrectResumeSelected(element);\n        }\n      }\n\n      return success;\n\n    } catch (error) {\n      log.error(`Error handling file upload: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Check if a file is already uploaded\n   */\n  private async checkExistingUpload(element: Locator): Promise<boolean> {\n    try {\n      // LinkedIn shows uploaded files with specific classes\n      const uploadedFile = element.locator('.jobs-document-upload__filename');\n      if (await uploadedFile.count() > 0) {\n        return true;\n      }\n\n      // Check for success indicator\n      const successIndicator = element.locator('[data-test-document-upload-success]');\n      if (await successIndicator.count() > 0) {\n        return true;\n      }\n\n      // Check for file display container\n      const fileDisplay = element.locator('.jobs-document-upload-redesign-card__file-name');\n      if (await fileDisplay.count() > 0) {\n        const fileName = await fileDisplay.textContent();\n        if (fileName?.trim()) {\n          return true;\n        }\n      }\n\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Try to use a previously uploaded file\n   */\n  private async tryUsePreviousUpload(element: Locator): Promise<boolean> {\n    try {\n      // Look for \"Be sure to include...\" option with existing files\n      const previousUploadOption = element.locator('[data-test-document-upload-file-card]').first();\n      \n      if (await previousUploadOption.count() > 0) {\n        await previousUploadOption.click();\n        await this.page.waitForTimeout(500);\n        return true;\n      }\n\n      // Alternative: Radio button to select existing file\n      const existingFileRadio = element.locator('input[type=\"radio\"][data-test-resume-radio]').first();\n      if (await existingFileRadio.count() > 0) {\n        await existingFileRadio.click();\n        await this.page.waitForTimeout(500);\n        return true;\n      }\n\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Upload a file to the input\n   */\n  private async uploadFile(element: Locator, filePath: string): Promise<boolean> {\n    try {\n      // Find the file input\n      const fileInput = element.locator('input[type=\"file\"]').first();\n      \n      if (await fileInput.count() > 0) {\n        // MATCHES PYTHON: Make the input interactable by removing 'hidden' class\n        try {\n          await fileInput.evaluate((el) => el.classList.remove('hidden'));\n        } catch {\n          log.debug('Could not remove hidden class (may already be visible)');\n        }\n        \n        // Set file using Playwright's setInputFiles\n        log.info(`Uploading file: ${filePath}`);\n        await fileInput.setInputFiles(filePath);\n        \n        // MATCHES PYTHON: Dispatch change/blur events to trigger LinkedIn's UI update\n        try {\n          for (const eventType of ['change', 'blur']) {\n            await fileInput.evaluate((el, evt) => {\n              el.dispatchEvent(new Event(evt, { bubbles: true }));\n            }, eventType);\n          }\n        } catch {\n          log.debug('Could not dispatch events on file input');\n        }\n        \n        // Wait for upload to process\n        await this.page.waitForTimeout(2000);\n        \n        return true;\n      }\n\n      // If no file input, try clicking an upload button\n      const uploadButton = element.locator('button:has-text(\"Upload\"), label:has-text(\"Upload\")').first();\n      \n      if (await uploadButton.count() > 0) {\n        // This might open a file dialog - need to handle with fileChooser\n        const [fileChooser] = await Promise.all([\n          this.page.waitForEvent('filechooser', { timeout: 5000 }),\n          uploadButton.click()\n        ]);\n        \n        await fileChooser.setFiles(filePath);\n        await this.page.waitForTimeout(2000);\n        \n        return true;\n      }\n\n      log.warn('Could not find file input or upload button');\n      return false;\n\n    } catch (error) {\n      log.debug(`Upload error: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Ensure the correct (newly uploaded) resume is selected in LinkedIn's UI.\n   * \n   * LinkedIn shows a list of previously uploaded resumes and may auto-select\n   * an older one. This method finds the card matching our resume filename\n   * and clicks its radio button to select it.\n   * \n   * CRITICAL: This matches the Python bot's _ensure_correct_resume_selected() method\n   */\n  private async ensureCorrectResumeSelected(element: Locator): Promise<void> {\n    if (!this.resumePath) {\n      return;\n    }\n\n    try {\n      // Extract just the filename from the path\n      const expectedFilename = path.basename(this.resumePath);\n      log.debug(`Ensuring resume is selected: ${expectedFilename}`);\n\n      // Wait a moment for LinkedIn to update the UI after upload\n      await this.page.waitForTimeout(500);\n\n      // Find all resume cards in the document upload section\n      const resumeCards = await element.locator('div.jobs-document-upload-redesign-card__container').all();\n\n      if (resumeCards.length === 0) {\n        log.debug('No resume selection cards found, upload likely direct');\n        return;\n      }\n\n      log.debug(`Found ${resumeCards.length} resume cards`);\n\n      // Find the card with our resume filename\n      let targetCard: Locator | null = null;\n      for (const card of resumeCards) {\n        try {\n          const filenameElement = card.locator('h3.jobs-document-upload-redesign-card__file-name').first();\n          if (await filenameElement.count() === 0) continue;\n\n          const cardFilename = await filenameElement.textContent();\n          log.debug(`Checking card: ${cardFilename?.trim()}`);\n\n          if (cardFilename?.trim() === expectedFilename) {\n            targetCard = card;\n            log.info(`Found matching resume card: ${cardFilename?.trim()}`);\n            break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      if (!targetCard) {\n        log.warn(`Could not find card for ${expectedFilename}`);\n        return;\n      }\n\n      // Check if it's already selected\n      try {\n        const cardClasses = await targetCard.getAttribute('class') || '';\n        if (cardClasses.includes('jobs-document-upload-redesign-card__container--selected')) {\n          log.info('\u2705 Correct resume already selected');\n          return;\n        }\n      } catch (e) {\n        log.debug(`Could not check selection status: ${e}`);\n      }\n\n      // Find and click the radio button or the card itself to select it\n      try {\n        // Try clicking the radio label first (more reliable than hidden input)\n        const radioLabel = targetCard.locator('label.jobs-document-upload-redesign-card__toggle-label').first();\n        const radioInput = targetCard.locator('input[type=\"radio\"]').first();\n\n        if (await radioLabel.count() > 0) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          await this.page.evaluate((el: any) => el.click(), await radioLabel.elementHandle());\n          log.info(`\u2705 Selected resume: ${expectedFilename}`);\n          await this.page.waitForTimeout(300);\n        } else if (await radioInput.count() > 0) {\n          await radioInput.click();\n          log.info(`\u2705 Selected resume: ${expectedFilename}`);\n          await this.page.waitForTimeout(300);\n        } else {\n          // If no radio button, try clicking the card itself\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          await this.page.evaluate((el: any) => el.click(), await targetCard.elementHandle());\n          log.info(`\u2705 Clicked resume card: ${expectedFilename}`);\n          await this.page.waitForTimeout(300);\n        }\n      } catch (e) {\n        log.warn(`Failed to select resume: ${e}`);\n      }\n\n    } catch (error) {\n      log.warn(`Error ensuring correct resume selection: ${error}`);\n    }\n  }\n\n  /**\n   * Generate a cover letter PDF using AI\n   * \n   * MATCHES PYTHON: Creates a temporary PDF file containing an AI-generated cover letter.\n   * Uses Playwright to generate the PDF from HTML for proper formatting.\n   * \n   * @returns Path to generated PDF, or null if generation fails\n   */\n  private async generateCoverLetterPdf(): Promise<string | null> {\n    try {\n      log.debug('[COVER LETTER] Generating cover letter with GPT');\n      \n      // Generate cover letter text using GPT\n      const coverLetterText = await this.gptAnswerer.answerTextual(\n        'Write a cover letter for this job application'\n      );\n      \n      if (!coverLetterText || coverLetterText.length < 100) {\n        log.warn('[COVER LETTER] Failed to generate cover letter text');\n        return null;\n      }\n      \n      // Create temporary PDF file path\n      const tempDir = os.tmpdir();\n      const timestamp = Date.now();\n      const pdfPath = path.join(tempDir, `cover_letter_${timestamp}.pdf`);\n      \n      // Format the cover letter as HTML for PDF generation\n      const paragraphs = coverLetterText.split('\\n\\n').filter((p: string) => p.trim());\n      const htmlContent = `\n<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    body {\n      font-family: 'Times New Roman', Times, serif;\n      font-size: 12pt;\n      line-height: 1.5;\n      margin: 1in;\n      color: #333;\n    }\n    p {\n      margin-bottom: 12pt;\n      text-align: justify;\n    }\n  </style>\n</head>\n<body>\n  ${paragraphs.map((p: string) => `<p>${p.replace(/\\n/g, '<br>')}</p>`).join('\\n')}\n</body>\n</html>`;\n\n      // Use Playwright to generate PDF from HTML\n      // Create a new page to render the HTML\n      const context = this.page.context();\n      const pdfPage = await context.newPage();\n      \n      try {\n        await pdfPage.setContent(htmlContent, { waitUntil: 'networkidle' });\n        await pdfPage.pdf({\n          path: pdfPath,\n          format: 'Letter',\n          margin: { top: '1in', right: '1in', bottom: '1in', left: '1in' },\n          printBackground: true,\n        });\n        \n        log.info(`[COVER LETTER] \u2705 Created PDF at: ${pdfPath}`);\n        this.generatedCoverLetterPath = pdfPath;\n        \n        return pdfPath;\n      } finally {\n        await pdfPage.close();\n      }\n      \n    } catch (error) {\n      log.error(`[COVER LETTER] Failed to generate PDF: ${error}`);\n      return null;\n    }\n  }\n\n  /**\n   * Clean up generated cover letter file\n   */\n  cleanup(): void {\n    if (this.generatedCoverLetterPath && fs.existsSync(this.generatedCoverLetterPath)) {\n      try {\n        fs.unlinkSync(this.generatedCoverLetterPath);\n        log.debug(`Cleaned up generated cover letter: ${this.generatedCoverLetterPath}`);\n      } catch {\n        // Ignore cleanup errors\n      }\n      this.generatedCoverLetterPath = null;\n    }\n  }\n\n  /**\n   * Set the resume path for uploads\n   */\n  setResumePath(newPath: string): void {\n    this.resumePath = newPath;\n    log.debug(`Resume path updated: ${newPath}`);\n  }\n\n  /**\n   * Set the cover letter path for uploads\n   */\n  setCoverLetterPath(path: string): void {\n    this.coverLetterPath = path;\n  }\n}\n"],
  "mappings": "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",
  "names": ["path"]
}
