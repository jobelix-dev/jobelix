{
  "version": 3,
  "sources": ["checkbox-handler.ts"],
  "sourcesContent": ["/**\n * Checkbox Handler - Handles checkbox fields (terms acceptance, preferences, etc.)\n * \n * LinkedIn uses checkboxes for:\n * - Terms and conditions acceptance\n * - Data sharing consent\n * - Job preferences (remote, willing to relocate, etc.)\n * - Multiple choice questions\n */\n\nimport type { Locator } from 'playwright';\nimport { BaseFieldHandler } from './base-handler';\nimport { createLogger } from '../../../utils/logger';\nimport { normalizeText } from '../form-utils';\n\nconst log = createLogger('CheckboxHandler');\n\nexport class CheckboxHandler extends BaseFieldHandler {\n  /**\n   * Check if this element is a checkbox field\n   */\n  async canHandle(element: Locator): Promise<boolean> {\n    try {\n      // Check for checkbox inputs\n      const checkboxes = element.locator('input[type=\"checkbox\"]');\n      return await checkboxes.count() > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle a checkbox field\n   * \n   * For single checkboxes (terms/consent), auto-check them\n   * For multiple checkboxes (preferences), ask GPT which to select\n   */\n  async handle(element: Locator): Promise<boolean> {\n    try {\n      const checkboxes = await element.locator('input[type=\"checkbox\"]').all();\n      const questionText = await this.extractQuestionText(element);\n      \n      log.debug(`Question: \"${questionText}\" (${checkboxes.length} checkbox(es))`);\n\n      // Single checkbox - likely a consent/agreement\n      if (checkboxes.length === 1) {\n        return await this.handleSingleCheckbox(element, checkboxes[0], questionText);\n      }\n\n      // Multiple checkboxes - need to decide which to check\n      return await this.handleMultipleCheckboxes(element, checkboxes, questionText);\n\n    } catch (error) {\n      log.error(`Error handling checkbox: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Handle a single checkbox (typically consent/agreement)\n   */\n  private async handleSingleCheckbox(\n    element: Locator, \n    checkbox: Locator, \n    questionText: string\n  ): Promise<boolean> {\n    try {\n      // Check if already checked\n      const isChecked = await checkbox.isChecked();\n      if (isChecked) {\n        log.debug('Checkbox already checked');\n        return true;\n      }\n\n      // Get label text to understand what we're agreeing to\n      const labelText = await this.getCheckboxLabel(element, checkbox);\n      const lowerLabel = labelText.toLowerCase();\n\n      // Auto-check consent/agreement checkboxes (multi-language support)\n      const autoCheckKeywords = [\n        'agree', 'accept', 'consent', 'acknowledge', 'confirm',\n        'terms', 'privacy', 'policy', 'understand', 'certify',\n        // French\n        'accepte', 'accepter', 'j\\'accepte', 'consentement', 'confirme',\n        'conditions', 'confidentialit\u00E9', 'politique', 'comprends',\n        // German\n        'akzeptiere', 'zustimme', 'einverstanden', 'best\u00E4tige',\n        // Spanish\n        'acepto', 'aceptar', 'consiento', 'confirmo'\n      ];\n\n      const shouldAutoCheck = autoCheckKeywords.some(keyword => \n        lowerLabel.includes(keyword) || questionText.toLowerCase().includes(keyword)\n      );\n\n      if (shouldAutoCheck) {\n        // Click the label instead of the checkbox to avoid \"label intercepts pointer events\" error\n        const label = await this.getCheckboxLabelElement(element, checkbox);\n        if (label) {\n          await label.click();\n        } else {\n          // Fallback: force click on checkbox\n          await checkbox.click({ force: true });\n        }\n        log.info(`\u2705 Auto-checked consent: \"${labelText.substring(0, 50)}...\"`)\n        return true;\n      }\n\n      // For other single checkboxes, ask GPT directly (no section routing)\n      const prompt = `Should I check this checkbox? \"${labelText}\" (Answer: yes or no)`;\n      const answer = await this.gptAnswerer.answerCheckboxQuestion(prompt);\n      \n      if (answer?.toLowerCase().includes('yes')) {\n        // Click the label instead of the checkbox to avoid \"label intercepts pointer events\" error\n        const label = await this.getCheckboxLabelElement(element, checkbox);\n        if (label) {\n          await label.click();\n        } else {\n          await checkbox.click({ force: true });\n        }\n        log.info(`\u2705 Checked: \"${labelText.substring(0, 50)}...\"`);\n      } else {\n        log.debug(`Left unchecked: \"${labelText.substring(0, 50)}...\"`);\n      }\n\n      return true;\n\n    } catch (error) {\n      log.debug(`Error with single checkbox: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Handle multiple checkboxes (e.g., preferences, skills)\n   */\n  private async handleMultipleCheckboxes(\n    element: Locator,\n    checkboxes: Locator[],\n    questionText: string\n  ): Promise<boolean> {\n    try {\n      // Collect all options\n      const options: { checkbox: Locator; label: string }[] = [];\n      \n      for (const checkbox of checkboxes) {\n        const label = await this.getCheckboxLabel(element, checkbox);\n        options.push({ checkbox, label });\n      }\n\n      // Format options for GPT (MATCHES PYTHON APPROACH)\n      const optionsList = options.map((o, i) => `${i + 1}. ${o.label}`).join('\\n');\n      \n      // Ask GPT directly which options to select (no section routing!)\n      // This is critical for questions like \"How did you hear about us?\" which are\n      // NOT based on resume content\n      const prompt = `Question: \"${questionText}\"\\n\\nOptions:\\n${optionsList}\\n\\nWhich options should I select? List the numbers separated by commas, or say \"none\". If the question asks how you heard about a company and \"LinkedIn\" or \"Job Board\" is an option, select that.`;\n      \n      const answer = await this.gptAnswerer.answerCheckboxQuestion(prompt);\n      \n      if (!answer || answer.toLowerCase().trim() === 'none') {\n        log.debug('No checkboxes selected');\n        return true;\n      }\n\n      // Parse selected numbers\n      const selectedNumbers = this.parseSelectedNumbers(answer, options.length);\n      \n      if (selectedNumbers.length === 0) {\n        log.warn(`Could not parse checkbox selection from: \"${answer}\"`);\n        // Try to find \"linkedin\" or \"job board\" as fallback for \"how did you hear\" questions\n        if (questionText.toLowerCase().includes('hear about') || questionText.toLowerCase().includes('how did you')) {\n          for (let i = 0; i < options.length; i++) {\n            const label = options[i].label.toLowerCase();\n            if (label.includes('linkedin') || label.includes('job board') || label.includes('job site')) {\n              selectedNumbers.push(i + 1);\n              log.info(`Fallback: selecting \"${options[i].label}\" for referral question`);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Check the selected options\n      for (const num of selectedNumbers) {\n        const option = options[num - 1];\n        if (option && !(await option.checkbox.isChecked())) {\n          // Click the label instead of the checkbox to avoid \"label intercepts pointer events\" error\n          const label = await this.getCheckboxLabelElement(element, option.checkbox);\n          if (label) {\n            await label.click();\n          } else {\n            await option.checkbox.click({ force: true });\n          }\n          log.info(`\u2705 Checked: \"${option.label}\"`);\n          await this.page.waitForTimeout(100);\n        }\n      }\n\n      return true;\n\n    } catch (error) {\n      log.debug(`Error with multiple checkboxes: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Get the label element for a checkbox (for clicking)\n   */\n  private async getCheckboxLabelElement(container: Locator, checkbox: Locator): Promise<Locator | null> {\n    try {\n      // Try to get associated label by 'for' attribute\n      const checkboxId = await checkbox.getAttribute('id');\n      if (checkboxId) {\n        const label = container.locator(`label[for=\"${checkboxId}\"]`);\n        if (await label.count() > 0) {\n          return label.first();\n        }\n      }\n\n      // Try parent label\n      const parentLabel = checkbox.locator('xpath=ancestor::label');\n      if (await parentLabel.count() > 0) {\n        return parentLabel.first();\n      }\n\n      return null;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Get the label text for a checkbox\n   */\n  private async getCheckboxLabel(container: Locator, checkbox: Locator): Promise<string> {\n    try {\n      // Try to get associated label by 'for' attribute\n      const checkboxId = await checkbox.getAttribute('id');\n      if (checkboxId) {\n        const label = container.locator(`label[for=\"${checkboxId}\"]`);\n        if (await label.count() > 0) {\n          const text = await label.textContent();\n          if (text?.trim()) return normalizeText(text);\n        }\n      }\n\n      // Try parent label\n      const parentLabel = checkbox.locator('xpath=ancestor::label');\n      if (await parentLabel.count() > 0) {\n        const text = await parentLabel.textContent();\n        if (text?.trim()) return normalizeText(text);\n      }\n\n      // Try sibling text\n      const parent = checkbox.locator('xpath=..');\n      const text = await parent.textContent();\n      return normalizeText(text || '');\n\n    } catch {\n      return '';\n    }\n  }\n\n  /**\n   * Parse GPT's answer for selected checkbox numbers\n   */\n  private parseSelectedNumbers(answer: string, maxNum: number): number[] {\n    const numbers: number[] = [];\n    \n    // Extract all numbers from the answer\n    const matches = answer.match(/\\d+/g);\n    if (!matches) return numbers;\n\n    for (const match of matches) {\n      const num = parseInt(match);\n      if (num >= 1 && num <= maxNum && !numbers.includes(num)) {\n        numbers.push(num);\n      }\n    }\n\n    return numbers;\n  }\n}\n"],
  "mappings": "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",
  "names": ["text"]
}
