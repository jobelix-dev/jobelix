{
  "version": 3,
  "sources": ["date-handler.ts"],
  "sourcesContent": ["/**\n * Date Handler - Handles date input fields\n * \n * LinkedIn date fields can appear as:\n * - Standard date inputs (type=\"date\")\n * - Multiple dropdowns (month/day/year)\n * - Text input that accepts date strings\n */\n\nimport type { Locator } from 'playwright';\nimport { BaseFieldHandler } from './base-handler';\nimport { createLogger } from '../../../utils/logger';\n\nconst log = createLogger('DateHandler');\n\nexport class DateHandler extends BaseFieldHandler {\n  /**\n   * Check if this element is a date field\n   */\n  async canHandle(element: Locator): Promise<boolean> {\n    try {\n      // Check for date input type\n      const dateInput = element.locator('input[type=\"date\"]');\n      if (await dateInput.count() > 0) return true;\n\n      // Check for month/year dropdowns (LinkedIn style)\n      const monthSelect = element.locator('select[id*=\"month\"], select[name*=\"month\"]');\n      const yearSelect = element.locator('select[id*=\"year\"], select[name*=\"year\"]');\n      if (await monthSelect.count() > 0 || await yearSelect.count() > 0) return true;\n\n      // Check for aria-describedby or labels mentioning date\n      const label = element.locator('label');\n      if (await label.count() > 0) {\n        const labelText = await label.textContent() || '';\n        const lowerLabel = labelText.toLowerCase();\n        if (lowerLabel.includes('date') || \n            lowerLabel.includes('when') ||\n            lowerLabel.includes('start') ||\n            lowerLabel.includes('end')) {\n          // Also verify there's an input\n          const input = element.locator('input, select');\n          if (await input.count() > 0) return true;\n        }\n      }\n\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle a date field\n   */\n  async handle(element: Locator): Promise<boolean> {\n    try {\n      // Get question text\n      const questionText = await this.extractQuestionText(element);\n      log.debug(`Question: \"${questionText}\"`);\n\n      // Try different date input types\n      let success = false;\n\n      // Type 1: Standard date input\n      success = await this.handleDateInput(element, questionText);\n      if (success) return true;\n\n      // Type 2: Month/Year dropdowns\n      success = await this.handleMonthYearDropdowns(element, questionText);\n      if (success) return true;\n\n      // Type 3: Text input for date\n      success = await this.handleTextDateInput(element, questionText);\n      if (success) return true;\n\n      log.warn(`Could not handle date field: \"${questionText}\"`);\n      return false;\n\n    } catch (error) {\n      log.error(`Error handling date field: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Handle standard HTML5 date input\n   */\n  private async handleDateInput(element: Locator, questionText: string): Promise<boolean> {\n    try {\n      const dateInput = element.locator('input[type=\"date\"]').first();\n      if (await dateInput.count() === 0) return false;\n\n      // Check if already filled\n      const existingValue = await dateInput.inputValue();\n      if (existingValue?.trim()) {\n        log.debug(`Already filled: \"${existingValue}\"`);\n        return true;\n      }\n\n      // Get answer from GPT\n      const answer = await this.getDateAnswer(questionText);\n      if (!answer) return false;\n\n      // Format as YYYY-MM-DD for date input\n      const formattedDate = this.formatDateForInput(answer);\n      if (!formattedDate) {\n        log.warn(`Could not format date: \"${answer}\"`);\n        return false;\n      }\n\n      await dateInput.fill(formattedDate);\n      log.info(`\u2705 Q: \"${questionText}\" \u2192 \"${formattedDate}\"`);\n      return true;\n\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle LinkedIn-style month/year dropdowns\n   */\n  private async handleMonthYearDropdowns(element: Locator, questionText: string): Promise<boolean> {\n    try {\n      // Look for month dropdown\n      const monthSelect = element.locator('select[id*=\"month\"], select[name*=\"month\"]').first();\n      const hasMonth = await monthSelect.count() > 0;\n\n      // Look for year dropdown\n      const yearSelect = element.locator('select[id*=\"year\"], select[name*=\"year\"]').first();\n      const hasYear = await yearSelect.count() > 0;\n\n      if (!hasMonth && !hasYear) return false;\n\n      // Get answer\n      const answer = await this.getDateAnswer(questionText);\n      if (!answer) return false;\n\n      // Parse month and year from answer\n      const dateInfo = this.parseDateAnswer(answer);\n      \n      // Fill month if available\n      if (hasMonth && dateInfo.month) {\n        const monthValue = dateInfo.month.toString().padStart(2, '0');\n        await monthSelect.selectOption({ value: monthValue });\n        log.debug(`Selected month: ${dateInfo.month}`);\n      }\n\n      // Fill year if available\n      if (hasYear && dateInfo.year) {\n        await yearSelect.selectOption({ value: dateInfo.year.toString() });\n        log.debug(`Selected year: ${dateInfo.year}`);\n      }\n\n      log.info(`\u2705 Q: \"${questionText}\" \u2192 month: ${dateInfo.month}, year: ${dateInfo.year}`);\n      return true;\n\n    } catch (error) {\n      log.debug(`Error with month/year dropdowns: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Handle text input that accepts date strings\n   */\n  private async handleTextDateInput(element: Locator, questionText: string): Promise<boolean> {\n    try {\n      const input = element.locator('input[type=\"text\"]').first();\n      if (await input.count() === 0) return false;\n\n      // Check if already filled\n      const existingValue = await input.inputValue();\n      if (existingValue?.trim()) {\n        log.debug(`Already filled: \"${existingValue}\"`);\n        return true;\n      }\n\n      // Get answer\n      const answer = await this.getDateAnswer(questionText);\n      if (!answer) return false;\n\n      await input.fill(answer);\n      log.info(`\u2705 Q: \"${questionText}\" \u2192 \"${answer}\"`);\n      return true;\n\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get date answer from saved answers or GPT\n   */\n  private async getDateAnswer(questionText: string): Promise<string | null> {\n    // Check saved answers first\n    let answer = this.formUtils.getSavedAnswer('date', questionText);\n    \n    if (!answer) {\n      // Ask GPT with specific prompt for dates\n      const prompt = `${questionText} (Please provide a date. Common formats: YYYY-MM-DD, MM/DD/YYYY, or just month/year like \"January 2024\")`;\n      answer = await this.gptAnswerer.answerTextual(prompt);\n    }\n\n    if (answer) {\n      this.formUtils.rememberAnswer('date', questionText, answer);\n    }\n\n    return answer;\n  }\n\n  /**\n   * Parse date answer into components\n   */\n  private parseDateAnswer(answer: string): { month?: number; year?: number; day?: number } {\n    const result: { month?: number; year?: number; day?: number } = {};\n\n    // Try YYYY-MM-DD format\n    const isoMatch = answer.match(/(\\d{4})-(\\d{1,2})-(\\d{1,2})/);\n    if (isoMatch) {\n      result.year = parseInt(isoMatch[1]);\n      result.month = parseInt(isoMatch[2]);\n      result.day = parseInt(isoMatch[3]);\n      return result;\n    }\n\n    // Try MM/DD/YYYY format\n    const usMatch = answer.match(/(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/);\n    if (usMatch) {\n      result.month = parseInt(usMatch[1]);\n      result.day = parseInt(usMatch[2]);\n      result.year = parseInt(usMatch[3]);\n      return result;\n    }\n\n    // Try \"Month Year\" format (e.g., \"January 2024\")\n    const monthNames = [\n      'january', 'february', 'march', 'april', 'may', 'june',\n      'july', 'august', 'september', 'october', 'november', 'december'\n    ];\n    const lower = answer.toLowerCase();\n    for (let i = 0; i < monthNames.length; i++) {\n      if (lower.includes(monthNames[i])) {\n        result.month = i + 1;\n        break;\n      }\n    }\n\n    // Extract year\n    const yearMatch = answer.match(/\\b(19|20)\\d{2}\\b/);\n    if (yearMatch) {\n      result.year = parseInt(yearMatch[0]);\n    }\n\n    return result;\n  }\n\n  /**\n   * Format date for HTML5 date input (YYYY-MM-DD)\n   */\n  private formatDateForInput(answer: string): string | null {\n    const parsed = this.parseDateAnswer(answer);\n    \n    if (!parsed.year) return null;\n    \n    const year = parsed.year;\n    const month = (parsed.month || 1).toString().padStart(2, '0');\n    const day = (parsed.day || 1).toString().padStart(2, '0');\n    \n    return `${year}-${month}-${day}`;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
