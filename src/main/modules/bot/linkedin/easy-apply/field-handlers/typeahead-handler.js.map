{
  "version": 3,
  "sources": ["typeahead-handler.ts"],
  "sourcesContent": ["/**\n * Typeahead Handler - Handles autocomplete/typeahead fields\n * \n * LinkedIn uses typeahead for fields like:\n * - Location (city)\n * - Schools/Universities\n * - Company names\n * - Skills\n * \n * These fields require typing text, waiting for suggestions,\n * then selecting from the dropdown.\n */\n\nimport type { Locator } from 'playwright';\nimport { BaseFieldHandler } from './base-handler';\nimport { createLogger } from '../../../utils/logger';\nimport { normalizeText } from '../form-utils';\nimport type { Resume } from '../../../types';\n\nconst log = createLogger('TypeaheadHandler');\n\nexport class TypeaheadHandler extends BaseFieldHandler {\n  /**\n   * Check if this element is a typeahead field\n   * \n   * Typeahead fields typically have:\n   * - An input with autocomplete attributes\n   * - Data attributes like data-test-single-typeahead\n   * - Associated listbox for suggestions\n   */\n  async canHandle(element: Locator): Promise<boolean> {\n    try {\n      // Check for typeahead-specific attributes\n      const typeaheadInput = element.locator('[data-test-single-typeahead-input]');\n      if (await typeaheadInput.count() > 0) return true;\n\n      // Check for combobox role\n      const combobox = element.locator('[role=\"combobox\"]');\n      if (await combobox.count() > 0) return true;\n\n      // Check for autocomplete attribute\n      const input = element.locator('input').first();\n      if (await input.count() > 0) {\n        const autocomplete = await input.getAttribute('autocomplete');\n        const ariaAutocomplete = await input.getAttribute('aria-autocomplete');\n        if (autocomplete === 'off' && ariaAutocomplete === 'list') {\n          return true;\n        }\n      }\n\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle a typeahead field\n   * \n   * Process:\n   * 1. Get the question text\n   * 2. Get answer from saved answers or GPT\n   * 3. Type the answer into the input\n   * 4. Wait for suggestions to appear\n   * 5. Select the first matching suggestion\n   */\n  async handle(element: Locator): Promise<boolean> {\n    try {\n      // Find the input element\n      const input = element.locator('input').first();\n      if (await input.count() === 0) return false;\n\n      // Get question text\n      const questionText = await this.extractQuestionText(element);\n      log.debug(`Question: \"${questionText}\"`);\n\n      // Check if already filled\n      const existingValue = await input.inputValue();\n      if (existingValue?.trim()) {\n        log.debug(`Already filled: \"${existingValue}\"`);\n        return true;\n      }\n\n      // Get answer - first try smart match (checks HTML structure like Python)\n      let answer = await this.smartTextMatch(element);\n      \n      if (answer) {\n        log.debug(`Smart match found: \"${answer}\"`);\n      } else {\n        // Try saved answers\n        answer = this.formUtils.getSavedAnswer('typeahead', questionText);\n      }\n      \n      if (!answer) {\n        log.debug(`Asking GPT: \"${questionText}\"`);\n        answer = await this.gptAnswerer.answerTextual(questionText);\n      }\n\n      if (!answer?.trim()) {\n        log.warn('No answer available for typeahead');\n        return false;\n      }\n\n      log.info(`\u2705 Q: \"${questionText}\" \u2192 \"${answer}\"`);\n\n      // Type the answer\n      await input.click();\n      await input.fill(''); // Clear first\n      \n      // Type slowly to trigger autocomplete\n      await input.pressSequentially(answer, { delay: 50 });\n      \n      // Wait for suggestions to appear\n      await this.page.waitForTimeout(1000);\n\n      // Try to select from dropdown\n      const selected = await this.selectSuggestion(element, answer);\n      \n      if (!selected) {\n        log.debug('No matching suggestion found, keeping typed value');\n      }\n\n      // Remember answer\n      this.formUtils.rememberAnswer('typeahead', questionText, answer);\n\n      return true;\n\n    } catch (error) {\n      log.error(`Error handling typeahead: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Smart text matching for common typeahead fields\n   * \n   * Uses language-independent HTML patterns to identify field types like:\n   * - Location/City fields (geo-location pattern in element ID)\n   * - Phone number fields\n   * \n   * This matches the Python smart_text_match() logic in playwright_form_utils.py\n   */\n  private async smartTextMatch(element: Locator): Promise<string | undefined> {\n    try {\n      const resume = this.gptAnswerer.resume as Resume | undefined;\n      if (!resume?.personalInformation) {\n        log.debug('[SMART TEXT] No resume or personal info available');\n        return undefined;\n      }\n      \n      const personalInfo = resume.personalInformation;\n      \n      // Find the input element and check its ID\n      const input = element.locator('input').first();\n      if (await input.count() === 0) {\n        return undefined;\n      }\n      \n      const elementId = (await input.getAttribute('id') || '').toLowerCase();\n      const elementName = (await input.getAttribute('name') || '').toLowerCase();\n      \n      log.debug(`[SMART TEXT] Element ID: ${elementId}`);\n      \n      // Location/City detection (HTML structure-based)\n      // Pattern: id contains \"geo-location\" or \"location-geo\" (matches Python exactly)\n      if (elementId.includes('geo-location') || elementId.includes('location-geo')) {\n        log.debug('[SMART TEXT] Detected location/city field (by HTML structure)');\n        const city = personalInfo.city;\n        if (city) {\n          log.info(`[SMART TEXT] \u2705 Using city from resume: ${city}`);\n          return city;\n        } else {\n          log.warn('[SMART TEXT] No city in resume');\n        }\n        return undefined;\n      }\n      \n      // Phone number detection (HTML structure-based)\n      // Pattern: id contains \"phonenumber-nationalnumber\" or \"phone-national\" (matches Python)\n      if (elementId.includes('phonenumber-nationalnumber') || elementId.includes('phone-national')) {\n        log.debug('[SMART TEXT] Detected phone number field (by HTML structure)');\n        const phone = personalInfo.phonePrefix && personalInfo.phone \n          ? `${personalInfo.phonePrefix}${personalInfo.phone}`\n          : personalInfo.phone;\n        if (phone) {\n          log.info(`[SMART TEXT] \u2705 Using phone from resume: ${phone}`);\n          return phone;\n        } else {\n          log.warn('[SMART TEXT] No phone in resume');\n        }\n        return undefined;\n      }\n      \n      log.debug('[SMART TEXT] No pattern matched');\n      return undefined;\n      \n    } catch (error) {\n      log.debug(`[SMART TEXT] Error analyzing element: ${error}`);\n      return undefined;\n    }\n  }\n\n  /**\n   * Select a suggestion from the dropdown\n   */\n  private async selectSuggestion(element: Locator, answer: string): Promise<boolean> {\n    try {\n      // LinkedIn typeahead suggestions are typically in a listbox\n      const listbox = this.page.locator('[role=\"listbox\"]').first();\n      \n      // Wait for listbox to appear\n      try {\n        await listbox.waitFor({ state: 'visible', timeout: 3000 });\n      } catch {\n        log.debug('No listbox appeared');\n        return false;\n      }\n\n      // Find all options\n      const options = await listbox.locator('[role=\"option\"]').all();\n      if (options.length === 0) {\n        log.debug('No options in listbox');\n        return false;\n      }\n\n      const normalizedAnswer = normalizeText(answer);\n\n      // Try to find exact or close match\n      for (const option of options) {\n        const text = await option.textContent();\n        if (!text) continue;\n\n        const normalizedOption = normalizeText(text);\n        \n        // Check for exact match or if answer is contained in option\n        if (normalizedOption === normalizedAnswer || \n            normalizedOption.includes(normalizedAnswer) ||\n            normalizedAnswer.includes(normalizedOption)) {\n          await option.click();\n          await this.page.waitForTimeout(500);\n          log.debug(`Selected suggestion: \"${text}\"`);\n          return true;\n        }\n      }\n\n      // If no match, click first option (often the best match for what was typed)\n      if (options.length > 0) {\n        const firstText = await options[0].textContent();\n        await options[0].click();\n        await this.page.waitForTimeout(500);\n        log.debug(`Selected first suggestion: \"${firstText}\"`);\n        return true;\n      }\n\n      return false;\n    } catch (error) {\n      log.debug(`Error selecting suggestion: ${error}`);\n      return false;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
