{
  "version": 3,
  "sources": ["typeahead-handler.ts"],
  "sourcesContent": ["/**\n * Typeahead Handler - Handles autocomplete/typeahead fields\n * \n * LinkedIn uses typeahead for: Location, Schools, Companies, Skills\n * These fields require typing text, waiting for suggestions, then selecting.\n */\n\nimport type { Locator } from 'playwright';\nimport { BaseFieldHandler } from './base-handler';\nimport { createLogger } from '../../../utils/logger';\nimport { TIMEOUTS } from '../selectors';\n\nconst log = createLogger('TypeaheadHandler');\n\nexport class TypeaheadHandler extends BaseFieldHandler {\n  /**\n   * Check if this element is a typeahead field\n   */\n  async canHandle(element: Locator): Promise<boolean> {\n    try {\n      // Check for typeahead-specific attributes\n      if (await element.locator('[data-test-single-typeahead-input]').count() > 0) return true;\n      if (await element.locator('[role=\"combobox\"]').count() > 0) return true;\n\n      // Check for autocomplete attribute pattern\n      const input = element.locator('input').first();\n      if (await input.count() > 0) {\n        const autocomplete = await input.getAttribute('autocomplete');\n        const ariaAutocomplete = await input.getAttribute('aria-autocomplete');\n        if (autocomplete === 'off' && ariaAutocomplete === 'list') return true;\n      }\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle a typeahead field\n   */\n  async handle(element: Locator): Promise<boolean> {\n    try {\n      const input = element.locator('input').first();\n      if (await input.count() === 0) return false;\n\n      const questionText = await this.extractQuestionText(element);\n      log.debug(`Question: \"${questionText}\"`);\n\n      // Always clear and get fresh answer from GPT (don't trust prefill)\n      const existingValue = await input.inputValue();\n      if (existingValue?.trim()) {\n        log.debug(`Clearing LinkedIn prefill: \"${existingValue}\"`);\n      }\n\n      // Get answer from GPT\n      log.debug(`Asking GPT: \"${questionText}\"`);\n      const answer = await this.gptAnswerer.answerTextual(questionText);\n      if (!answer?.trim()) {\n        log.warn('No answer available for typeahead');\n        return false;\n      }\n\n      log.info(`\u2705 Q: \"${questionText}\" \u2192 \"${answer}\"`);\n\n      // Type the answer to trigger autocomplete\n      await input.click();\n      await input.fill('');\n      await input.pressSequentially(answer, { delay: TIMEOUTS.typing });\n      await this.page.waitForTimeout(TIMEOUTS.long);\n\n      // Try to select from dropdown\n      await this.selectSuggestion(answer);\n      \n      this.formUtils.rememberAnswer('typeahead', questionText, answer);\n      return true;\n    } catch (error) {\n      log.error(`Error handling typeahead: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Select a suggestion from the dropdown\n   */\n  private async selectSuggestion(answer: string): Promise<boolean> {\n    try {\n      const listbox = this.page.locator('[role=\"listbox\"]').first();\n      \n      try {\n        await listbox.waitFor({ state: 'visible', timeout: 3000 });\n      } catch {\n        log.debug('No listbox appeared');\n        return false;\n      }\n\n      const options = await listbox.locator('[role=\"option\"]').all();\n      if (options.length === 0) {\n        log.debug('No options in listbox');\n        return false;\n      }\n\n      const normalizedAnswer = this.normalizeText(answer);\n\n      // Find matching option\n      for (const option of options) {\n        const text = await option.textContent();\n        if (!text) continue;\n\n        const normalizedOption = this.normalizeText(text);\n        if (this.isMatch(normalizedAnswer, normalizedOption)) {\n          await option.click();\n          await this.page.waitForTimeout(TIMEOUTS.medium);\n          log.debug(`Selected suggestion: \"${text}\"`);\n          return true;\n        }\n      }\n\n      // Select first option as fallback\n      if (options.length > 0) {\n        const firstText = await options[0].textContent();\n        await options[0].click();\n        await this.page.waitForTimeout(TIMEOUTS.medium);\n        log.debug(`Selected first suggestion: \"${firstText}\"`);\n        return true;\n      }\n\n      return false;\n    } catch (error) {\n      log.debug(`Error selecting suggestion: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Check if two normalized strings match (exact or contains)\n   */\n  private isMatch(a: string, b: string): boolean {\n    return a === b || a.includes(b) || b.includes(a);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
