{
  "version": 3,
  "sources": ["text-handler.ts"],
  "sourcesContent": ["/**\n * Text Input Handler - Handles single-line text inputs\n * \n * Used for fields like:\n * - Name, email, phone number\n * - Years of experience (numeric)\n * - City, company name\n */\n\nimport type { Locator } from 'playwright';\nimport { BaseFieldHandler } from './base-handler';\nimport { createLogger } from '../../../utils/logger';\n\nconst log = createLogger('TextHandler');\n\nexport class TextInputHandler extends BaseFieldHandler {\n  /**\n   * Check if this element contains a text input\n   * Excludes radio, checkbox, file, and button inputs\n   */\n  async canHandle(element: Locator): Promise<boolean> {\n    try {\n      const inputs = await element.locator('input').all();\n      \n      for (const input of inputs) {\n        const type = await input.getAttribute('type') || 'text';\n        // Accept text-like inputs, exclude special types\n        if (!['button', 'submit', 'checkbox', 'radio', 'file', 'hidden'].includes(type)) {\n          return true;\n        }\n      }\n      \n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Handle a text input field\n   */\n  async handle(element: Locator): Promise<boolean> {\n    try {\n      const input = element.locator('input').first();\n      if (await input.count() === 0) return false;\n\n      const inputType = await input.getAttribute('type') || 'text';\n      \n      // Skip non-text inputs\n      if (['button', 'submit', 'checkbox', 'radio', 'file', 'hidden'].includes(inputType)) {\n        return false;\n      }\n\n      // Get question text\n      const questionText = await this.extractQuestionText(element);\n      log.debug(`Question: \"${questionText}\"`);\n\n      // Check if already filled by LinkedIn\n      const existingValue = await input.inputValue();\n      if (existingValue?.trim()) {\n        log.debug(`LinkedIn pre-filled: \"${existingValue}\" - checking if we should override`);\n        // Only override if it looks like a placeholder\n        if (!existingValue.toLowerCase().includes('select') && \n            !existingValue.toLowerCase().includes('enter')) {\n          log.debug('Keeping pre-filled value');\n          return true;\n        }\n      }\n\n      // Determine if numeric\n      const isNumeric = await this.isNumericField(input);\n      \n      // Get answer\n      let answer: string | undefined;\n\n      // Check saved answers\n      answer = this.formUtils.getSavedAnswer('text', questionText);\n\n      // Try smart matching\n      if (!answer) {\n        answer = await this.smartMatch(element, questionText);\n      }\n\n      // Ask GPT\n      if (!answer) {\n        if (isNumeric) {\n          log.debug(`Asking GPT (numeric): \"${questionText}\"`);\n          const numAnswer = await this.gptAnswerer.answerNumeric(questionText);\n          answer = String(numAnswer);\n        } else {\n          log.debug(`Asking GPT (textual): \"${questionText}\"`);\n          answer = await this.gptAnswerer.answerTextual(questionText);\n        }\n      }\n\n      if (!answer?.trim()) {\n        log.warn('No answer available for text input');\n        return false;\n      }\n\n      log.info(`\u2705 Q: \"${questionText}\" \u2192 \"${answer.substring(0, 50)}${answer.length > 50 ? '...' : ''}\"`);\n\n      // Fill the input\n      await input.click();\n      await input.fill(''); // Clear first\n      await input.fill(answer);\n      await this.page.waitForTimeout(300);\n\n      // Remember answer\n      this.formUtils.rememberAnswer('text', questionText, answer);\n\n      // Check for validation errors\n      const errorMsg = await this.formUtils.extractFieldErrors(element);\n      if (errorMsg) {\n        log.warn(`Validation error: ${errorMsg}`);\n        \n        // Retry with error context\n        const retryAnswer = await this.gptAnswerer.answerTextualWithRetry(\n          questionText, answer, errorMsg\n        );\n        \n        if (retryAnswer) {\n          await input.fill('');\n          await input.fill(retryAnswer);\n          this.formUtils.rememberAnswer('text', questionText, retryAnswer);\n        }\n      }\n\n      return true;\n\n    } catch (error) {\n      log.error(`Error handling text input: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Check if this is a numeric field\n   */\n  private async isNumericField(input: Locator): Promise<boolean> {\n    try {\n      const type = await input.getAttribute('type');\n      if (type === 'number') return true;\n\n      const inputmode = await input.getAttribute('inputmode');\n      if (inputmode && ['numeric', 'decimal'].includes(inputmode)) return true;\n\n      const id = await input.getAttribute('id') || '';\n      const name = await input.getAttribute('name') || '';\n      \n      return (\n        id.includes('numeric') ||\n        id.includes('number') ||\n        name.includes('numeric') ||\n        name.includes('number')\n      );\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Smart matching for common text fields\n   */\n  private async smartMatch(element: Locator, questionText: string): Promise<string | undefined> {\n    const questionLower = questionText.toLowerCase();\n\n    // Phone number detection\n    if (questionLower.includes('phone') && !questionLower.includes('prefix')) {\n      // Would get from resume, return undefined to use GPT\n      return undefined;\n    }\n\n    return undefined;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
