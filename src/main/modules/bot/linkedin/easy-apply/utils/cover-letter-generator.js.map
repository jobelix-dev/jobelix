{
  "version": 3,
  "sources": ["cover-letter-generator.ts"],
  "sourcesContent": ["/**\n * Cover Letter Generator - Generates PDF cover letters using AI\n */\n\nimport type { Page } from 'playwright';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport { createLogger } from '../../../utils/logger';\n\nconst log = createLogger('CoverLetterGenerator');\n\n/** Minimum cover letter length to be valid */\nconst MIN_COVER_LETTER_LENGTH = 100;\n\n/** Path to the most recently generated cover letter (for cleanup) */\nlet generatedPath: string | null = null;\n\n/**\n * Generate a cover letter PDF using AI\n * \n * Creates a temporary PDF file containing an AI-generated cover letter.\n * Uses Playwright to generate the PDF from HTML for proper formatting.\n * \n * @param page - Playwright page for PDF generation\n * @param answerFn - Function to generate cover letter text\n * @returns Path to generated PDF, or null if generation fails\n */\nexport async function generateCoverLetterPdf(\n  page: Page,\n  answerFn: (question: string) => Promise<string | undefined>\n): Promise<string | null> {\n  try {\n    log.debug('[COVER LETTER] Generating cover letter with GPT');\n\n    // Generate cover letter text using GPT\n    const coverLetterText = await answerFn('Write a cover letter for this job application');\n\n    if (!coverLetterText || coverLetterText.length < MIN_COVER_LETTER_LENGTH) {\n      log.warn('[COVER LETTER] Failed to generate cover letter text');\n      return null;\n    }\n\n    // Create temporary PDF file path\n    const tempDir = os.tmpdir();\n    const timestamp = Date.now();\n    const pdfPath = path.join(tempDir, `cover_letter_${timestamp}.pdf`);\n\n    // Format the cover letter as HTML\n    const htmlContent = formatCoverLetterHtml(coverLetterText);\n\n    // Use Playwright to generate PDF from HTML\n    const context = page.context();\n    const pdfPage = await context.newPage();\n\n    try {\n      await pdfPage.setContent(htmlContent, { waitUntil: 'networkidle' });\n      await pdfPage.pdf({\n        path: pdfPath,\n        format: 'Letter',\n        margin: { top: '1in', right: '1in', bottom: '1in', left: '1in' },\n        printBackground: true,\n      });\n\n      log.info(`[COVER LETTER] \u2705 Created PDF at: ${pdfPath}`);\n      generatedPath = pdfPath;\n\n      return pdfPath;\n    } finally {\n      await pdfPage.close();\n    }\n  } catch (error) {\n    log.error(`[COVER LETTER] Failed to generate PDF: ${error}`);\n    return null;\n  }\n}\n\n/**\n * Format cover letter text as HTML for PDF generation\n */\nfunction formatCoverLetterHtml(text: string): string {\n  const paragraphs = text.split('\\n\\n').filter(p => p.trim());\n  \n  return `<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    body {\n      font-family: 'Times New Roman', Times, serif;\n      font-size: 12pt;\n      line-height: 1.5;\n      margin: 1in;\n      color: #333;\n    }\n    p {\n      margin-bottom: 12pt;\n      text-align: justify;\n    }\n  </style>\n</head>\n<body>\n  ${paragraphs.map(p => `<p>${p.replace(/\\n/g, '<br>')}</p>`).join('\\n')}\n</body>\n</html>`;\n}\n\n/**\n * Clean up any generated cover letter file\n */\nexport function cleanupGeneratedCoverLetter(): void {\n  if (generatedPath && fs.existsSync(generatedPath)) {\n    try {\n      fs.unlinkSync(generatedPath);\n      log.debug(`Cleaned up generated cover letter: ${generatedPath}`);\n    } catch {\n      // Ignore cleanup errors\n    }\n    generatedPath = null;\n  }\n}\n\n/**\n * Get the path of the last generated cover letter\n */\nexport function getGeneratedCoverLetterPath(): string | null {\n  return generatedPath;\n}\n"],
  "mappings": "AAKA,YAAY,UAAU;AACtB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,SAAS,oBAAoB;AAE7B,MAAM,MAAM,aAAa,sBAAsB;AAG/C,MAAM,0BAA0B;AAGhC,IAAI,gBAA+B;AAYnC,eAAsB,uBACpB,MACA,UACwB;AACxB,MAAI;AACF,QAAI,MAAM,iDAAiD;AAG3D,UAAM,kBAAkB,MAAM,SAAS,+CAA+C;AAEtF,QAAI,CAAC,mBAAmB,gBAAgB,SAAS,yBAAyB;AACxE,UAAI,KAAK,qDAAqD;AAC9D,aAAO;AAAA,IACT;AAGA,UAAM,UAAU,GAAG,OAAO;AAC1B,UAAM,YAAY,KAAK,IAAI;AAC3B,UAAM,UAAU,KAAK,KAAK,SAAS,gBAAgB,SAAS,MAAM;AAGlE,UAAM,cAAc,sBAAsB,eAAe;AAGzD,UAAM,UAAU,KAAK,QAAQ;AAC7B,UAAM,UAAU,MAAM,QAAQ,QAAQ;AAEtC,QAAI;AACF,YAAM,QAAQ,WAAW,aAAa,EAAE,WAAW,cAAc,CAAC;AAClE,YAAM,QAAQ,IAAI;AAAA,QAChB,MAAM;AAAA,QACN,QAAQ;AAAA,QACR,QAAQ,EAAE,KAAK,OAAO,OAAO,OAAO,QAAQ,OAAO,MAAM,MAAM;AAAA,QAC/D,iBAAiB;AAAA,MACnB,CAAC;AAED,UAAI,KAAK,yCAAoC,OAAO,EAAE;AACtD,sBAAgB;AAEhB,aAAO;AAAA,IACT,UAAE;AACA,YAAM,QAAQ,MAAM;AAAA,IACtB;AAAA,EACF,SAAS,OAAO;AACd,QAAI,MAAM,0CAA0C,KAAK,EAAE;AAC3D,WAAO;AAAA,EACT;AACF;AAKA,SAAS,sBAAsB,MAAsB;AACnD,QAAM,aAAa,KAAK,MAAM,MAAM,EAAE,OAAO,OAAK,EAAE,KAAK,CAAC;AAE1D,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkBL,WAAW,IAAI,OAAK,MAAM,EAAE,QAAQ,OAAO,MAAM,CAAC,MAAM,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA;AAGxE;AAKO,SAAS,8BAAoC;AAClD,MAAI,iBAAiB,GAAG,WAAW,aAAa,GAAG;AACjD,QAAI;AACF,SAAG,WAAW,aAAa;AAC3B,UAAI,MAAM,sCAAsC,aAAa,EAAE;AAAA,IACjE,QAAQ;AAAA,IAER;AACA,oBAAgB;AAAA,EAClB;AACF;AAKO,SAAS,8BAA6C;AAC3D,SAAO;AACT;",
  "names": []
}
