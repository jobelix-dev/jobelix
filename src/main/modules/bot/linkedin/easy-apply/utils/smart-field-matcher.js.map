{
  "version": 3,
  "sources": ["smart-field-matcher.ts"],
  "sourcesContent": ["/**\n * Smart Field Matcher - Language-independent field detection and value matching\n * \n * Consolidates duplicate smart matching logic from handlers.\n * Uses HTML element attributes (IDs, names, data-* attributes) to detect field types\n * and extract appropriate values from the resume.\n * \n * This matches the Python smart_text_match() logic in playwright_form_utils.py\n */\n\nimport type { Locator } from 'playwright-core';\nimport type { Resume, PersonalInformation, Education } from '../../../types';\nimport { createLogger } from '../../../utils/logger';\n\nconst log = createLogger('SmartFieldMatcher');\n\n/** Result of a smart field match */\nexport interface FieldMatchResult {\n  /** Field type that was detected */\n  fieldType: string;\n  /** Value to use for the field */\n  value: string;\n  /** How the match was made (for logging) */\n  matchedBy: 'element-id' | 'question-text' | 'option-match';\n}\n\n/**\n * Smart field matcher that uses HTML structure instead of keyword detection\n */\nexport class SmartFieldMatcher {\n  private personalInfo: PersonalInformation | undefined;\n  private educationDetails: Education[] | undefined;\n\n  constructor(resume?: Resume) {\n    this.personalInfo = resume?.personalInformation;\n    this.educationDetails = resume?.educationDetails;\n  }\n\n  /**\n   * Update resume data (e.g., when a new resume is loaded)\n   */\n  updateResume(resume: Resume): void {\n    this.personalInfo = resume.personalInformation;\n    this.educationDetails = resume.educationDetails;\n  }\n\n  /**\n   * Match a text/typeahead field by examining HTML element attributes\n   * \n   * Detects:\n   * - Location/City fields (geo-location pattern in ID)\n   * - Phone number fields (phonenumber-nationalnumber pattern)\n   * - Email fields\n   * - Name fields\n   */\n  async matchByElementId(input: Locator): Promise<FieldMatchResult | null> {\n    if (!this.personalInfo) {\n      log.debug('[SMART MATCH] No personal info available');\n      return null;\n    }\n\n    try {\n      if (await input.count() === 0) return null;\n\n      const elementId = (await input.getAttribute('id') || '').toLowerCase();\n      const elementName = (await input.getAttribute('name') || '').toLowerCase();\n      \n      log.debug(`[SMART MATCH] Element ID: ${elementId}, Name: ${elementName}`);\n\n      // Location/City detection\n      // Pattern: id contains \"geo-location\" or \"location-geo\"\n      if (elementId.includes('geo-location') || elementId.includes('location-geo') ||\n          elementName.includes('location')) {\n        const city = this.personalInfo.city;\n        if (city) {\n          log.info(`[SMART MATCH] \u2705 City field detected: ${city}`);\n          return { fieldType: 'city', value: city, matchedBy: 'element-id' };\n        }\n      }\n\n      // Phone number detection\n      // Pattern: id contains \"phonenumber-nationalnumber\" or \"phone-national\"\n      if (elementId.includes('phonenumber-nationalnumber') || \n          elementId.includes('phone-national') ||\n          elementName.includes('phone')) {\n        const phone = this.formatPhone();\n        if (phone) {\n          log.info(`[SMART MATCH] \u2705 Phone field detected: ${phone}`);\n          return { fieldType: 'phone', value: phone, matchedBy: 'element-id' };\n        }\n      }\n\n      // Email detection\n      if (elementId.includes('email') || elementName.includes('email')) {\n        const email = this.personalInfo.email;\n        if (email) {\n          log.info(`[SMART MATCH] \u2705 Email field detected: ${email}`);\n          return { fieldType: 'email', value: email, matchedBy: 'element-id' };\n        }\n      }\n\n      return null;\n    } catch (error) {\n      log.debug(`[SMART MATCH] Error: ${error}`);\n      return null;\n    }\n  }\n\n  /**\n   * Match a field by analyzing the question text\n   * \n   * Fallback when HTML structure doesn't help.\n   * Detects URLs, phone numbers, city, etc. by keywords.\n   */\n  matchByQuestionText(questionText: string): FieldMatchResult | null {\n    if (!this.personalInfo) return null;\n\n    const questionLower = questionText.toLowerCase();\n\n    // Website/URL detection\n    if (this.isUrlField(questionLower)) {\n      const url = this.getUrlForQuestion(questionLower);\n      if (url) {\n        return { fieldType: 'url', value: url, matchedBy: 'question-text' };\n      }\n    }\n\n    // Phone number by question text\n    if (questionLower.includes('phone') && !questionLower.includes('prefix')) {\n      const phone = this.formatPhone();\n      if (phone) {\n        log.info(`[SMART MATCH] \u2705 Phone (by question): ${phone}`);\n        return { fieldType: 'phone', value: phone, matchedBy: 'question-text' };\n      }\n    }\n\n    // City by question text\n    if (questionLower.includes('city') || questionLower.includes('location')) {\n      const city = this.personalInfo.city;\n      if (city) {\n        log.info(`[SMART MATCH] \u2705 City (by question): ${city}`);\n        return { fieldType: 'city', value: city, matchedBy: 'question-text' };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Match a school/university from dropdown options\n   * \n   * Uses resume education data to find matching institution\n   */\n  matchSchool(options: string[]): string | null {\n    if (!this.educationDetails || this.educationDetails.length === 0) {\n      return null;\n    }\n\n    log.debug('[SMART MATCH] Attempting school match');\n\n    // Alternative names mapping for common schools\n    const alternativeNames: Record<string, string[]> = {\n      'universit\u00E9 psl': ['Paris Sciences et Lettres', 'PSL University', 'PSL Research University'],\n      'psl': ['Paris Sciences et Lettres', 'PSL University'],\n      'institut polytechnique de paris': ['IP Paris', 'Polytechnique Paris'],\n      'telecom sudparis': ['T\u00E9l\u00E9com SudParis', 'Telecom SudParis', 'TSP'],\n      'telecom paris': ['T\u00E9l\u00E9com Paris', 'ENST'],\n      'ecole polytechnique': ['Polytechnique', 'X'],\n      'hec paris': ['HEC', 'HEC School of Management'],\n      'sciences po': ['Sciences Po Paris', 'Institut d\\'\u00C9tudes Politiques'],\n      'ens': ['\u00C9cole Normale Sup\u00E9rieure', 'ENS Paris', 'Normale Sup'],\n      'centrale': ['CentraleSup\u00E9lec', '\u00C9cole Centrale'],\n      'mines': ['MINES ParisTech', '\u00C9cole des Mines'],\n      'sainte-genevi\u00E8ve': ['Ginette', 'Sainte Genevi\u00E8ve'],\n    };\n\n    for (const edu of this.educationDetails) {\n      const institution = edu.university;\n      if (!institution) continue;\n\n      const instLower = institution.toLowerCase();\n      log.debug(`[SMART MATCH] Checking: \"${institution}\"`);\n\n      // Try exact match\n      const exactMatch = options.find(o => o.toLowerCase() === instLower);\n      if (exactMatch) {\n        log.info(`[SMART MATCH] \u2705 Exact school match: \"${exactMatch}\"`);\n        return exactMatch;\n      }\n\n      // Try alternative names\n      for (const [key, alts] of Object.entries(alternativeNames)) {\n        if (instLower.includes(key)) {\n          for (const alt of alts) {\n            const altMatch = options.find(o =>\n              o.toLowerCase().includes(alt.toLowerCase()) ||\n              alt.toLowerCase().includes(o.toLowerCase())\n            );\n            if (altMatch) {\n              log.info(`[SMART MATCH] \u2705 Alternative name match: \"${altMatch}\"`);\n              return altMatch;\n            }\n          }\n        }\n      }\n\n      // Try partial match\n      const partialMatch = options.find(o =>\n        o.toLowerCase().includes(instLower) ||\n        instLower.includes(o.toLowerCase())\n      );\n      if (partialMatch) {\n        log.info(`[SMART MATCH] \u2705 Partial school match: \"${partialMatch}\"`);\n        return partialMatch;\n      }\n\n      // Try significant word matching (>4 chars, excluding common words)\n      const skipWords = ['university', 'institut', '\u00E9cole', 'ecole', 'paris', 'france', 'college'];\n      const institutionWords = instLower.split(/[\\s\\-()]+/).filter(w => \n        w.length > 4 && !skipWords.includes(w)\n      );\n      \n      for (const word of institutionWords) {\n        const wordMatch = options.find(o => o.toLowerCase().includes(word));\n        if (wordMatch) {\n          log.info(`[SMART MATCH] \u2705 Word-based school match: \"${wordMatch}\" (word: \"${word}\")`);\n          return wordMatch;\n        }\n      }\n    }\n\n    log.warn('[SMART MATCH] No school match found');\n    return null;\n  }\n\n  /**\n   * Match phone prefix from dropdown options\n   */\n  matchPhonePrefix(options: string[]): string | null {\n    const phonePrefix = this.personalInfo?.phonePrefix;\n    \n    // Try exact prefix match\n    if (phonePrefix) {\n      const match = options.find(o => o.includes(phonePrefix));\n      if (match) {\n        log.info(`[SMART MATCH] \u2705 Phone prefix match: \"${match}\"`);\n        return match;\n      }\n    }\n\n    // Fallback to common prefixes\n    const commonPrefixes = ['+1', '+44', '+33', '+49', '+39', '+34'];\n    for (const prefix of commonPrefixes) {\n      const match = options.find(o => o.includes(prefix));\n      if (match) {\n        log.debug(`[SMART MATCH] Using common prefix: \"${match}\"`);\n        return match;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if a question is asking for a URL field\n   */\n  private isUrlField(questionLower: string): boolean {\n    return (\n      questionLower.includes('website') ||\n      questionLower.includes('url') ||\n      questionLower.includes('portfolio') ||\n      questionLower.includes('personal site') ||\n      questionLower.includes('github') ||\n      questionLower.includes('linkedin')\n    );\n  }\n\n  /**\n   * Get appropriate URL based on question context\n   */\n  private getUrlForQuestion(questionLower: string): string | null {\n    if (!this.personalInfo) return null;\n\n    // Specific platform requested\n    if (questionLower.includes('github') && this.personalInfo.github) {\n      log.info(`[SMART MATCH] \u2705 GitHub URL: ${this.personalInfo.github}`);\n      return this.personalInfo.github;\n    }\n\n    if (questionLower.includes('linkedin') && this.personalInfo.linkedin) {\n      log.info(`[SMART MATCH] \u2705 LinkedIn URL: ${this.personalInfo.linkedin}`);\n      return this.personalInfo.linkedin;\n    }\n\n    // Generic website - try github first (common for dev jobs)\n    if (this.personalInfo.github) {\n      log.info(`[SMART MATCH] \u2705 Website (GitHub): ${this.personalInfo.github}`);\n      return this.personalInfo.github;\n    }\n\n    if (this.personalInfo.linkedin) {\n      log.info(`[SMART MATCH] \u2705 Website (LinkedIn): ${this.personalInfo.linkedin}`);\n      return this.personalInfo.linkedin;\n    }\n\n    return null;\n  }\n\n  /**\n   * Format phone number with prefix\n   */\n  private formatPhone(): string | null {\n    if (!this.personalInfo?.phone) return null;\n    \n    return this.personalInfo.phonePrefix\n      ? `${this.personalInfo.phonePrefix}${this.personalInfo.phone}`\n      : this.personalInfo.phone;\n  }\n}\n"],
  "mappings": "AAYA,SAAS,oBAAoB;AAE7B,MAAM,MAAM,aAAa,mBAAmB;AAerC,MAAM,kBAAkB;AAAA,EAI7B,YAAY,QAAiB;AAC3B,SAAK,eAAe,QAAQ;AAC5B,SAAK,mBAAmB,QAAQ;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,QAAsB;AACjC,SAAK,eAAe,OAAO;AAC3B,SAAK,mBAAmB,OAAO;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,iBAAiB,OAAkD;AACvE,QAAI,CAAC,KAAK,cAAc;AACtB,UAAI,MAAM,0CAA0C;AACpD,aAAO;AAAA,IACT;AAEA,QAAI;AACF,UAAI,MAAM,MAAM,MAAM,MAAM,EAAG,QAAO;AAEtC,YAAM,aAAa,MAAM,MAAM,aAAa,IAAI,KAAK,IAAI,YAAY;AACrE,YAAM,eAAe,MAAM,MAAM,aAAa,MAAM,KAAK,IAAI,YAAY;AAEzE,UAAI,MAAM,6BAA6B,SAAS,WAAW,WAAW,EAAE;AAIxE,UAAI,UAAU,SAAS,cAAc,KAAK,UAAU,SAAS,cAAc,KACvE,YAAY,SAAS,UAAU,GAAG;AACpC,cAAM,OAAO,KAAK,aAAa;AAC/B,YAAI,MAAM;AACR,cAAI,KAAK,6CAAwC,IAAI,EAAE;AACvD,iBAAO,EAAE,WAAW,QAAQ,OAAO,MAAM,WAAW,aAAa;AAAA,QACnE;AAAA,MACF;AAIA,UAAI,UAAU,SAAS,4BAA4B,KAC/C,UAAU,SAAS,gBAAgB,KACnC,YAAY,SAAS,OAAO,GAAG;AACjC,cAAM,QAAQ,KAAK,YAAY;AAC/B,YAAI,OAAO;AACT,cAAI,KAAK,8CAAyC,KAAK,EAAE;AACzD,iBAAO,EAAE,WAAW,SAAS,OAAO,OAAO,WAAW,aAAa;AAAA,QACrE;AAAA,MACF;AAGA,UAAI,UAAU,SAAS,OAAO,KAAK,YAAY,SAAS,OAAO,GAAG;AAChE,cAAM,QAAQ,KAAK,aAAa;AAChC,YAAI,OAAO;AACT,cAAI,KAAK,8CAAyC,KAAK,EAAE;AACzD,iBAAO,EAAE,WAAW,SAAS,OAAO,OAAO,WAAW,aAAa;AAAA,QACrE;AAAA,MACF;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,MAAM,wBAAwB,KAAK,EAAE;AACzC,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,oBAAoB,cAA+C;AACjE,QAAI,CAAC,KAAK,aAAc,QAAO;AAE/B,UAAM,gBAAgB,aAAa,YAAY;AAG/C,QAAI,KAAK,WAAW,aAAa,GAAG;AAClC,YAAM,MAAM,KAAK,kBAAkB,aAAa;AAChD,UAAI,KAAK;AACP,eAAO,EAAE,WAAW,OAAO,OAAO,KAAK,WAAW,gBAAgB;AAAA,MACpE;AAAA,IACF;AAGA,QAAI,cAAc,SAAS,OAAO,KAAK,CAAC,cAAc,SAAS,QAAQ,GAAG;AACxE,YAAM,QAAQ,KAAK,YAAY;AAC/B,UAAI,OAAO;AACT,YAAI,KAAK,6CAAwC,KAAK,EAAE;AACxD,eAAO,EAAE,WAAW,SAAS,OAAO,OAAO,WAAW,gBAAgB;AAAA,MACxE;AAAA,IACF;AAGA,QAAI,cAAc,SAAS,MAAM,KAAK,cAAc,SAAS,UAAU,GAAG;AACxE,YAAM,OAAO,KAAK,aAAa;AAC/B,UAAI,MAAM;AACR,YAAI,KAAK,4CAAuC,IAAI,EAAE;AACtD,eAAO,EAAE,WAAW,QAAQ,OAAO,MAAM,WAAW,gBAAgB;AAAA,MACtE;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,SAAkC;AAC5C,QAAI,CAAC,KAAK,oBAAoB,KAAK,iBAAiB,WAAW,GAAG;AAChE,aAAO;AAAA,IACT;AAEA,QAAI,MAAM,uCAAuC;AAGjD,UAAM,mBAA6C;AAAA,MACjD,qBAAkB,CAAC,6BAA6B,kBAAkB,yBAAyB;AAAA,MAC3F,OAAO,CAAC,6BAA6B,gBAAgB;AAAA,MACrD,mCAAmC,CAAC,YAAY,qBAAqB;AAAA,MACrE,oBAAoB,CAAC,0BAAoB,oBAAoB,KAAK;AAAA,MAClE,iBAAiB,CAAC,uBAAiB,MAAM;AAAA,MACzC,uBAAuB,CAAC,iBAAiB,GAAG;AAAA,MAC5C,aAAa,CAAC,OAAO,0BAA0B;AAAA,MAC/C,eAAe,CAAC,qBAAqB,iCAA+B;AAAA,MACpE,OAAO,CAAC,kCAA4B,aAAa,aAAa;AAAA,MAC9D,YAAY,CAAC,sBAAmB,mBAAgB;AAAA,MAChD,SAAS,CAAC,mBAAmB,oBAAiB;AAAA,MAC9C,uBAAoB,CAAC,WAAW,qBAAkB;AAAA,IACpD;AAEA,eAAW,OAAO,KAAK,kBAAkB;AACvC,YAAM,cAAc,IAAI;AACxB,UAAI,CAAC,YAAa;AAElB,YAAM,YAAY,YAAY,YAAY;AAC1C,UAAI,MAAM,4BAA4B,WAAW,GAAG;AAGpD,YAAM,aAAa,QAAQ,KAAK,OAAK,EAAE,YAAY,MAAM,SAAS;AAClE,UAAI,YAAY;AACd,YAAI,KAAK,6CAAwC,UAAU,GAAG;AAC9D,eAAO;AAAA,MACT;AAGA,iBAAW,CAAC,KAAK,IAAI,KAAK,OAAO,QAAQ,gBAAgB,GAAG;AAC1D,YAAI,UAAU,SAAS,GAAG,GAAG;AAC3B,qBAAW,OAAO,MAAM;AACtB,kBAAM,WAAW,QAAQ;AAAA,cAAK,OAC5B,EAAE,YAAY,EAAE,SAAS,IAAI,YAAY,CAAC,KAC1C,IAAI,YAAY,EAAE,SAAS,EAAE,YAAY,CAAC;AAAA,YAC5C;AACA,gBAAI,UAAU;AACZ,kBAAI,KAAK,iDAA4C,QAAQ,GAAG;AAChE,qBAAO;AAAA,YACT;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAGA,YAAM,eAAe,QAAQ;AAAA,QAAK,OAChC,EAAE,YAAY,EAAE,SAAS,SAAS,KAClC,UAAU,SAAS,EAAE,YAAY,CAAC;AAAA,MACpC;AACA,UAAI,cAAc;AAChB,YAAI,KAAK,+CAA0C,YAAY,GAAG;AAClE,eAAO;AAAA,MACT;AAGA,YAAM,YAAY,CAAC,cAAc,YAAY,YAAS,SAAS,SAAS,UAAU,SAAS;AAC3F,YAAM,mBAAmB,UAAU,MAAM,WAAW,EAAE;AAAA,QAAO,OAC3D,EAAE,SAAS,KAAK,CAAC,UAAU,SAAS,CAAC;AAAA,MACvC;AAEA,iBAAW,QAAQ,kBAAkB;AACnC,cAAM,YAAY,QAAQ,KAAK,OAAK,EAAE,YAAY,EAAE,SAAS,IAAI,CAAC;AAClE,YAAI,WAAW;AACb,cAAI,KAAK,kDAA6C,SAAS,aAAa,IAAI,IAAI;AACpF,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK,qCAAqC;AAC9C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiB,SAAkC;AACjD,UAAM,cAAc,KAAK,cAAc;AAGvC,QAAI,aAAa;AACf,YAAM,QAAQ,QAAQ,KAAK,OAAK,EAAE,SAAS,WAAW,CAAC;AACvD,UAAI,OAAO;AACT,YAAI,KAAK,6CAAwC,KAAK,GAAG;AACzD,eAAO;AAAA,MACT;AAAA,IACF;AAGA,UAAM,iBAAiB,CAAC,MAAM,OAAO,OAAO,OAAO,OAAO,KAAK;AAC/D,eAAW,UAAU,gBAAgB;AACnC,YAAM,QAAQ,QAAQ,KAAK,OAAK,EAAE,SAAS,MAAM,CAAC;AAClD,UAAI,OAAO;AACT,YAAI,MAAM,uCAAuC,KAAK,GAAG;AACzD,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,WAAW,eAAgC;AACjD,WACE,cAAc,SAAS,SAAS,KAChC,cAAc,SAAS,KAAK,KAC5B,cAAc,SAAS,WAAW,KAClC,cAAc,SAAS,eAAe,KACtC,cAAc,SAAS,QAAQ,KAC/B,cAAc,SAAS,UAAU;AAAA,EAErC;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkB,eAAsC;AAC9D,QAAI,CAAC,KAAK,aAAc,QAAO;AAG/B,QAAI,cAAc,SAAS,QAAQ,KAAK,KAAK,aAAa,QAAQ;AAChE,UAAI,KAAK,oCAA+B,KAAK,aAAa,MAAM,EAAE;AAClE,aAAO,KAAK,aAAa;AAAA,IAC3B;AAEA,QAAI,cAAc,SAAS,UAAU,KAAK,KAAK,aAAa,UAAU;AACpE,UAAI,KAAK,sCAAiC,KAAK,aAAa,QAAQ,EAAE;AACtE,aAAO,KAAK,aAAa;AAAA,IAC3B;AAGA,QAAI,KAAK,aAAa,QAAQ;AAC5B,UAAI,KAAK,0CAAqC,KAAK,aAAa,MAAM,EAAE;AACxE,aAAO,KAAK,aAAa;AAAA,IAC3B;AAEA,QAAI,KAAK,aAAa,UAAU;AAC9B,UAAI,KAAK,4CAAuC,KAAK,aAAa,QAAQ,EAAE;AAC5E,aAAO,KAAK,aAAa;AAAA,IAC3B;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,cAA6B;AACnC,QAAI,CAAC,KAAK,cAAc,MAAO,QAAO;AAEtC,WAAO,KAAK,aAAa,cACrB,GAAG,KAAK,aAAa,WAAW,GAAG,KAAK,aAAa,KAAK,KAC1D,KAAK,aAAa;AAAA,EACxB;AACF;",
  "names": []
}
