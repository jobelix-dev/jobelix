{
  "version": 3,
  "sources": ["form-utils.ts"],
  "sourcesContent": ["/**\n * Form Utilities - Shared helpers for form processing\n * \n * Contains utility functions used across multiple field handlers:\n * - Text normalization for comparison\n * - Answer caching/retrieval\n * - Safe click operations\n * - Error detection\n */\n\nimport type { Page, Locator } from 'playwright-core';\nimport type { SavedAnswer } from '../../types';\nimport { createLogger } from '../../utils/logger';\n\nconst log = createLogger('FormUtils');\n\n/**\n * Normalize text for comparison\n * \n * Handles case differences, accents, and extra whitespace.\n * Essential for matching GPT responses to actual form options.\n * \n * @param text - Text to normalize\n * @returns Normalized lowercase text without accents\n */\nexport function normalizeText(text: string): string {\n  return text\n    .toLowerCase()\n    .normalize('NFD')                    // Decompose accents\n    .replace(/[\\u0300-\\u036f]/g, '')    // Remove accent marks\n    .replace(/\\s+/g, ' ')               // Normalize whitespace\n    .trim();\n}\n\n/**\n * FormUtils - Shared utilities for form processing\n */\nexport class FormUtils {\n  private answers: Map<string, string>;\n  private recordCallback?: (type: string, question: string, answer: string) => void;\n\n  constructor(\n    private page: Page,\n    savedAnswers: SavedAnswer[],\n    recordCallback?: (type: string, question: string, answer: string) => void\n  ) {\n    this.recordCallback = recordCallback;\n    \n    // Build answer lookup map from saved answers\n    // Key format: \"type:question_text_lowercase\"\n    this.answers = new Map();\n    for (const { questionType, questionText, answer } of savedAnswers) {\n      const key = `${questionType.toLowerCase()}:${questionText.toLowerCase()}`;\n      this.answers.set(key, answer);\n    }\n    \n    log.info(`Loaded ${this.answers.size} saved answers`);\n  }\n\n  /**\n   * Get a saved answer for a question\n   * \n   * Looks up answers using substring matching, so \"years of experience\"\n   * will match questions like \"How many years of experience do you have?\"\n   * \n   * @param fieldType - Type of field (radio, dropdown, text, etc.)\n   * @param questionText - The question being asked\n   * @returns Saved answer or undefined if not found\n   */\n  getSavedAnswer(fieldType: string, questionText: string): string | undefined {\n    // Don't return cached answers for unknown/empty questions - they'd be wrong\n    if (!questionText || questionText.toLowerCase().includes('unknown')) {\n      log.warn(`[GET_SAVED] Refusing to lookup answer for unknown/empty question: \"${questionText}\"`);\n      return undefined;\n    }\n    \n    const normalizedQuestion = questionText.toLowerCase();\n    const typePrefix = fieldType.toLowerCase() + ':';\n    \n    // Look for exact match first\n    const exactKey = typePrefix + normalizedQuestion;\n    if (this.answers.has(exactKey)) {\n      const answer = this.answers.get(exactKey)!;\n      log.debug(`Found exact answer for \"${questionText}\": \"${answer}\"`);\n      return answer;\n    }\n    \n    // Try substring matching\n    for (const [key, answer] of this.answers) {\n      if (!key.startsWith(typePrefix)) continue;\n      \n      const savedQuestion = key.substring(typePrefix.length);\n      if (normalizedQuestion.includes(savedQuestion) || savedQuestion.includes(normalizedQuestion)) {\n        log.debug(`Found fuzzy answer for \"${questionText}\": \"${answer}\"`);\n        return answer;\n      }\n    }\n    \n    return undefined;\n  }\n\n  /**\n   * Remember an answer for future use\n   * \n   * Saves the answer to the in-memory cache and calls the record callback\n   * to persist it to disk (old_Questions.csv).\n   * \n   * MATCHES PYTHON: Validates answer is not a placeholder before saving.\n   * \n   * @param fieldType - Type of field\n   * @param questionText - The question\n   * @param answer - The answer to save\n   */\n  rememberAnswer(fieldType: string, questionText: string, answer: string): void {\n    // === VALIDATION (MATCHES PYTHON) ===\n    \n    // Don't save answers for unknown questions - they would collide with other fields\n    if (!questionText || questionText.toLowerCase().includes('unknown')) {\n      log.warn(`[REMEMBER] Refusing to cache answer for unknown/empty question: \"${questionText}\"`);\n      return;\n    }\n    \n    // Don't save completely empty answers\n    if (!answer || !answer.trim()) {\n      log.warn(`[REMEMBER] Refusing to save empty answer for question: \"${questionText}\"`);\n      return;\n    }\n    \n    const answerStripped = answer.trim();\n    const answerLower = answerStripped.toLowerCase();\n    \n    // Allow numeric answers (including \"0\", \"1\", etc.) - valid for experience years, ratings, etc.\n    const isNumeric = /^[\\d.\\-]+$/.test(answerStripped);\n    \n    // Allow common valid short answers: Yes, No, Si, Oui, etc.\n    const validShortAnswers = ['yes', 'no', 'si', 's\u00ED', 'oui', 'non', 'ja', 'nein'];\n    const isValidShort = validShortAnswers.includes(answerLower);\n    \n    // Reject very short non-numeric answers that are NOT valid short answers (likely placeholders)\n    if (!isNumeric && !isValidShort && answerStripped.length <= 2) {\n      log.warn(`[REMEMBER] Refusing to save too short answer: \"${answer}\" for question: \"${questionText}\"`);\n      return;\n    }\n    \n    // Pattern 1: Starts with \"select\" or \"choose\" in any language (word boundary)\n    const selectPatterns = ['select', 's\u00E9lect', 'selecciona', 'seleccione', 'seleziona', 'escolh'];\n    const choosePatterns = ['choose', 'choisir', 'choisissez', 'elegir', 'scegli'];\n    if ([...selectPatterns, ...choosePatterns].some(pattern => answerLower.startsWith(pattern))) {\n      log.warn(`[REMEMBER] Refusing to save selection prompt: \"${answer}\" for question: \"${questionText}\"`);\n      return;\n    }\n    \n    // Pattern 2: Contains \"option\" as a standalone word\n    const optionPatterns = ['option', 'opci\u00F3n', 'opzione', 'an option', 'una opci\u00F3n'];\n    if (optionPatterns.includes(answerLower)) {\n      log.warn(`[REMEMBER] Refusing to save 'option' placeholder: \"${answer}\" for question: \"${questionText}\"`);\n      return;\n    }\n    \n    // Pattern 3: Generic null/placeholder values\n    const nullValues = ['n/a', 'none', 'null', 'nil', 'undefined', '---', '...', '\u2013'];\n    if (nullValues.includes(answerLower) || nullValues.includes(answerStripped)) {\n      log.warn(`[REMEMBER] Refusing to save null/placeholder value: \"${answer}\" for question: \"${questionText}\"`);\n      return;\n    }\n    \n    // === SAVE ANSWER ===\n    const key = `${fieldType.toLowerCase()}:${questionText.toLowerCase()}`;\n    this.answers.set(key, answer);\n    \n    // Persist to disk via callback\n    if (this.recordCallback) {\n      try {\n        this.recordCallback(fieldType, questionText, answer);\n        log.debug(`Recorded answer: \"${questionText}\" \u2192 \"${answer}\"`);\n      } catch (error) {\n        log.error('Failed to record answer', error as Error);\n      }\n    }\n  }\n\n  /**\n   * Safe click operation with retry\n   * \n   * LinkedIn forms can be finicky - this adds stability by:\n   * 1. Scrolling element into view\n   * 2. Waiting for element to be visible\n   * 3. Retrying on failure\n   * \n   * @param element - Element to click\n   * @param retries - Number of retry attempts\n   */\n  async safeClick(element: Locator, retries = 3): Promise<void> {\n    for (let attempt = 1; attempt <= retries; attempt++) {\n      try {\n        await element.scrollIntoViewIfNeeded();\n        await element.waitFor({ state: 'visible', timeout: 5000 });\n        await element.click();\n        return;\n      } catch (error) {\n        if (attempt === retries) {\n          throw error;\n        }\n        log.debug(`Click attempt ${attempt} failed, retrying...`);\n        await this.page.waitForTimeout(500);\n      }\n    }\n  }\n\n  /**\n   * Extract validation error messages from a form element\n   * \n   * LinkedIn shows error messages in specific elements when validation fails.\n   * This helps us detect and retry with better answers.\n   * \n   * @param element - Form element to check for errors\n   * @returns Error message or undefined if no errors\n   */\n  async extractFieldErrors(element: Locator): Promise<string | undefined> {\n    try {\n      // LinkedIn error messages typically use these patterns\n      const errorSelectors = [\n        '[data-test-form-element-error-message]',\n        '.artdeco-inline-feedback--error',\n        '.fb-form-element__error-text',\n        '[role=\"alert\"]',\n      ];\n\n      for (const selector of errorSelectors) {\n        const errorElement = element.locator(selector).first();\n        if (await errorElement.count() > 0) {\n          const text = await errorElement.textContent();\n          if (text?.trim()) {\n            return text.trim();\n          }\n        }\n      }\n    } catch {\n      // Ignore errors in error detection\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Generate a stable key for tracking processed elements\n   * \n   * Used to avoid processing the same element twice during form scrolling.\n   * \n   * @param element - Element to generate key for\n   * @returns Unique identifier string\n   */\n  async stableKey(element: Locator): Promise<string> {\n    try {\n      // Try to get a unique identifier from the element\n      const id = await element.getAttribute('id');\n      if (id) return `id:${id}`;\n      \n      const name = await element.locator('input, select, textarea').first().getAttribute('name');\n      if (name) return `name:${name}`;\n      \n      // Fall back to text content hash\n      const text = await element.textContent();\n      return `text:${text?.substring(0, 100)}`;\n    } catch {\n      return `fallback:${Date.now()}`;\n    }\n  }\n}\n"],
  "mappings": "AAYA,SAAS,oBAAoB;AAE7B,MAAM,MAAM,aAAa,WAAW;AAW7B,SAAS,cAAc,MAAsB;AAClD,SAAO,KACJ,YAAY,EACZ,UAAU,KAAK,EACf,QAAQ,oBAAoB,EAAE,EAC9B,QAAQ,QAAQ,GAAG,EACnB,KAAK;AACV;AAKO,MAAM,UAAU;AAAA,EAIrB,YACU,MACR,cACA,gBACA;AAHQ;AAIR,SAAK,iBAAiB;AAItB,SAAK,UAAU,oBAAI,IAAI;AACvB,eAAW,EAAE,cAAc,cAAc,OAAO,KAAK,cAAc;AACjE,YAAM,MAAM,GAAG,aAAa,YAAY,CAAC,IAAI,aAAa,YAAY,CAAC;AACvE,WAAK,QAAQ,IAAI,KAAK,MAAM;AAAA,IAC9B;AAEA,QAAI,KAAK,UAAU,KAAK,QAAQ,IAAI,gBAAgB;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,eAAe,WAAmB,cAA0C;AAE1E,QAAI,CAAC,gBAAgB,aAAa,YAAY,EAAE,SAAS,SAAS,GAAG;AACnE,UAAI,KAAK,sEAAsE,YAAY,GAAG;AAC9F,aAAO;AAAA,IACT;AAEA,UAAM,qBAAqB,aAAa,YAAY;AACpD,UAAM,aAAa,UAAU,YAAY,IAAI;AAG7C,UAAM,WAAW,aAAa;AAC9B,QAAI,KAAK,QAAQ,IAAI,QAAQ,GAAG;AAC9B,YAAM,SAAS,KAAK,QAAQ,IAAI,QAAQ;AACxC,UAAI,MAAM,2BAA2B,YAAY,OAAO,MAAM,GAAG;AACjE,aAAO;AAAA,IACT;AAGA,eAAW,CAAC,KAAK,MAAM,KAAK,KAAK,SAAS;AACxC,UAAI,CAAC,IAAI,WAAW,UAAU,EAAG;AAEjC,YAAM,gBAAgB,IAAI,UAAU,WAAW,MAAM;AACrD,UAAI,mBAAmB,SAAS,aAAa,KAAK,cAAc,SAAS,kBAAkB,GAAG;AAC5F,YAAI,MAAM,2BAA2B,YAAY,OAAO,MAAM,GAAG;AACjE,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,eAAe,WAAmB,cAAsB,QAAsB;AAI5E,QAAI,CAAC,gBAAgB,aAAa,YAAY,EAAE,SAAS,SAAS,GAAG;AACnE,UAAI,KAAK,oEAAoE,YAAY,GAAG;AAC5F;AAAA,IACF;AAGA,QAAI,CAAC,UAAU,CAAC,OAAO,KAAK,GAAG;AAC7B,UAAI,KAAK,2DAA2D,YAAY,GAAG;AACnF;AAAA,IACF;AAEA,UAAM,iBAAiB,OAAO,KAAK;AACnC,UAAM,cAAc,eAAe,YAAY;AAG/C,UAAM,YAAY,aAAa,KAAK,cAAc;AAGlD,UAAM,oBAAoB,CAAC,OAAO,MAAM,MAAM,SAAM,OAAO,OAAO,MAAM,MAAM;AAC9E,UAAM,eAAe,kBAAkB,SAAS,WAAW;AAG3D,QAAI,CAAC,aAAa,CAAC,gBAAgB,eAAe,UAAU,GAAG;AAC7D,UAAI,KAAK,kDAAkD,MAAM,oBAAoB,YAAY,GAAG;AACpG;AAAA,IACF;AAGA,UAAM,iBAAiB,CAAC,UAAU,aAAU,cAAc,cAAc,aAAa,QAAQ;AAC7F,UAAM,iBAAiB,CAAC,UAAU,WAAW,cAAc,UAAU,QAAQ;AAC7E,QAAI,CAAC,GAAG,gBAAgB,GAAG,cAAc,EAAE,KAAK,aAAW,YAAY,WAAW,OAAO,CAAC,GAAG;AAC3F,UAAI,KAAK,kDAAkD,MAAM,oBAAoB,YAAY,GAAG;AACpG;AAAA,IACF;AAGA,UAAM,iBAAiB,CAAC,UAAU,aAAU,WAAW,aAAa,eAAY;AAChF,QAAI,eAAe,SAAS,WAAW,GAAG;AACxC,UAAI,KAAK,sDAAsD,MAAM,oBAAoB,YAAY,GAAG;AACxG;AAAA,IACF;AAGA,UAAM,aAAa,CAAC,OAAO,QAAQ,QAAQ,OAAO,aAAa,OAAO,OAAO,QAAG;AAChF,QAAI,WAAW,SAAS,WAAW,KAAK,WAAW,SAAS,cAAc,GAAG;AAC3E,UAAI,KAAK,wDAAwD,MAAM,oBAAoB,YAAY,GAAG;AAC1G;AAAA,IACF;AAGA,UAAM,MAAM,GAAG,UAAU,YAAY,CAAC,IAAI,aAAa,YAAY,CAAC;AACpE,SAAK,QAAQ,IAAI,KAAK,MAAM;AAG5B,QAAI,KAAK,gBAAgB;AACvB,UAAI;AACF,aAAK,eAAe,WAAW,cAAc,MAAM;AACnD,YAAI,MAAM,qBAAqB,YAAY,aAAQ,MAAM,GAAG;AAAA,MAC9D,SAAS,OAAO;AACd,YAAI,MAAM,2BAA2B,KAAc;AAAA,MACrD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAM,UAAU,SAAkB,UAAU,GAAkB;AAC5D,aAAS,UAAU,GAAG,WAAW,SAAS,WAAW;AACnD,UAAI;AACF,cAAM,QAAQ,uBAAuB;AACrC,cAAM,QAAQ,QAAQ,EAAE,OAAO,WAAW,SAAS,IAAK,CAAC;AACzD,cAAM,QAAQ,MAAM;AACpB;AAAA,MACF,SAAS,OAAO;AACd,YAAI,YAAY,SAAS;AACvB,gBAAM;AAAA,QACR;AACA,YAAI,MAAM,iBAAiB,OAAO,sBAAsB;AACxD,cAAM,KAAK,KAAK,eAAe,GAAG;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,mBAAmB,SAA+C;AACtE,QAAI;AAEF,YAAM,iBAAiB;AAAA,QACrB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,iBAAW,YAAY,gBAAgB;AACrC,cAAM,eAAe,QAAQ,QAAQ,QAAQ,EAAE,MAAM;AACrD,YAAI,MAAM,aAAa,MAAM,IAAI,GAAG;AAClC,gBAAM,OAAO,MAAM,aAAa,YAAY;AAC5C,cAAI,MAAM,KAAK,GAAG;AAChB,mBAAO,KAAK,KAAK;AAAA,UACnB;AAAA,QACF;AAAA,MACF;AAAA,IACF,QAAQ;AAAA,IAER;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,UAAU,SAAmC;AACjD,QAAI;AAEF,YAAM,KAAK,MAAM,QAAQ,aAAa,IAAI;AAC1C,UAAI,GAAI,QAAO,MAAM,EAAE;AAEvB,YAAM,OAAO,MAAM,QAAQ,QAAQ,yBAAyB,EAAE,MAAM,EAAE,aAAa,MAAM;AACzF,UAAI,KAAM,QAAO,QAAQ,IAAI;AAG7B,YAAM,OAAO,MAAM,QAAQ,YAAY;AACvC,aAAO,QAAQ,MAAM,UAAU,GAAG,GAAG,CAAC;AAAA,IACxC,QAAQ;AACN,aAAO,YAAY,KAAK,IAAI,CAAC;AAAA,IAC/B;AAAA,EACF;AACF;",
  "names": []
}
