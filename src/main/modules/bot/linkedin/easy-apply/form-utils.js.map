{
  "version": 3,
  "sources": ["form-utils.ts"],
  "sourcesContent": ["/**\n * Form Utilities - Shared helpers for form processing\n * \n * Contains utility functions used across multiple field handlers:\n * - Text normalization for comparison\n * - Answer caching/retrieval\n * - Safe click operations\n * - Error detection\n */\n\nimport type { Page, Locator } from 'playwright';\nimport type { SavedAnswer } from '../../types';\nimport { createLogger } from '../../utils/logger';\n\nconst log = createLogger('FormUtils');\n\n/**\n * Normalize text for comparison\n * \n * Handles case differences, accents, and extra whitespace.\n * Essential for matching GPT responses to actual form options.\n * \n * @param text - Text to normalize\n * @returns Normalized lowercase text without accents\n */\nexport function normalizeText(text: string): string {\n  return text\n    .toLowerCase()\n    .normalize('NFD')                    // Decompose accents\n    .replace(/[\\u0300-\\u036f]/g, '')    // Remove accent marks\n    .replace(/\\s+/g, ' ')               // Normalize whitespace\n    .trim();\n}\n\n/**\n * FormUtils - Shared utilities for form processing\n */\nexport class FormUtils {\n  private answers: Map<string, string>;\n  private recordCallback?: (type: string, question: string, answer: string) => void;\n\n  constructor(\n    private page: Page,\n    savedAnswers: SavedAnswer[],\n    recordCallback?: (type: string, question: string, answer: string) => void\n  ) {\n    this.recordCallback = recordCallback;\n    \n    // Build answer lookup map from saved answers\n    // Key format: \"type:question_text_lowercase\"\n    this.answers = new Map();\n    for (const { questionType, questionText, answer } of savedAnswers) {\n      const key = `${questionType.toLowerCase()}:${questionText.toLowerCase()}`;\n      this.answers.set(key, answer);\n    }\n    \n    log.info(`Loaded ${this.answers.size} saved answers`);\n  }\n\n  /**\n   * Normalize text for comparison\n   */\n  normalizeText(text: string): string {\n    return normalizeText(text);\n  }\n\n  /**\n   * Get a saved answer for a question\n   * \n   * Looks up answers using substring matching, so \"years of experience\"\n   * will match questions like \"How many years of experience do you have?\"\n   * \n   * @param fieldType - Type of field (radio, dropdown, text, etc.)\n   * @param questionText - The question being asked\n   * @returns Saved answer or undefined if not found\n   */\n  getSavedAnswer(fieldType: string, questionText: string): string | undefined {\n    const normalizedQuestion = questionText.toLowerCase();\n    const typePrefix = fieldType.toLowerCase() + ':';\n    \n    // Look for exact match first\n    const exactKey = typePrefix + normalizedQuestion;\n    if (this.answers.has(exactKey)) {\n      const answer = this.answers.get(exactKey)!;\n      log.debug(`Found exact answer for \"${questionText}\": \"${answer}\"`);\n      return answer;\n    }\n    \n    // Try substring matching\n    for (const [key, answer] of this.answers) {\n      if (!key.startsWith(typePrefix)) continue;\n      \n      const savedQuestion = key.substring(typePrefix.length);\n      if (normalizedQuestion.includes(savedQuestion) || savedQuestion.includes(normalizedQuestion)) {\n        log.debug(`Found fuzzy answer for \"${questionText}\": \"${answer}\"`);\n        return answer;\n      }\n    }\n    \n    return undefined;\n  }\n\n  /**\n   * Remember an answer for future use\n   * \n   * Saves the answer to the in-memory cache and calls the record callback\n   * to persist it to disk (old_Questions.csv).\n   * \n   * @param fieldType - Type of field\n   * @param questionText - The question\n   * @param answer - The answer to save\n   */\n  rememberAnswer(fieldType: string, questionText: string, answer: string): void {\n    const key = `${fieldType.toLowerCase()}:${questionText.toLowerCase()}`;\n    this.answers.set(key, answer);\n    \n    // Persist to disk via callback\n    if (this.recordCallback) {\n      try {\n        this.recordCallback(fieldType, questionText, answer);\n        log.debug(`Recorded answer: \"${questionText}\" \u2192 \"${answer}\"`);\n      } catch (error) {\n        log.error('Failed to record answer', error as Error);\n      }\n    }\n  }\n\n  /**\n   * Safe click operation with retry\n   * \n   * LinkedIn forms can be finicky - this adds stability by:\n   * 1. Scrolling element into view\n   * 2. Waiting for element to be visible\n   * 3. Retrying on failure\n   * \n   * @param element - Element to click\n   * @param retries - Number of retry attempts\n   */\n  async safeClick(element: Locator, retries = 3): Promise<void> {\n    for (let attempt = 1; attempt <= retries; attempt++) {\n      try {\n        await element.scrollIntoViewIfNeeded();\n        await element.waitFor({ state: 'visible', timeout: 5000 });\n        await element.click();\n        return;\n      } catch (error) {\n        if (attempt === retries) {\n          throw error;\n        }\n        log.debug(`Click attempt ${attempt} failed, retrying...`);\n        await this.page.waitForTimeout(500);\n      }\n    }\n  }\n\n  /**\n   * Extract validation error messages from a form element\n   * \n   * LinkedIn shows error messages in specific elements when validation fails.\n   * This helps us detect and retry with better answers.\n   * \n   * @param element - Form element to check for errors\n   * @returns Error message or undefined if no errors\n   */\n  async extractFieldErrors(element: Locator): Promise<string | undefined> {\n    try {\n      // LinkedIn error messages typically use these patterns\n      const errorSelectors = [\n        '[data-test-form-element-error-message]',\n        '.artdeco-inline-feedback--error',\n        '.fb-form-element__error-text',\n        '[role=\"alert\"]',\n      ];\n\n      for (const selector of errorSelectors) {\n        const errorElement = element.locator(selector).first();\n        if (await errorElement.count() > 0) {\n          const text = await errorElement.textContent();\n          if (text?.trim()) {\n            return text.trim();\n          }\n        }\n      }\n    } catch {\n      // Ignore errors in error detection\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Generate a stable key for tracking processed elements\n   * \n   * Used to avoid processing the same element twice during form scrolling.\n   * \n   * @param element - Element to generate key for\n   * @returns Unique identifier string\n   */\n  async stableKey(element: Locator): Promise<string> {\n    try {\n      // Try to get a unique identifier from the element\n      const id = await element.getAttribute('id');\n      if (id) return `id:${id}`;\n      \n      const name = await element.locator('input, select, textarea').first().getAttribute('name');\n      if (name) return `name:${name}`;\n      \n      // Fall back to text content hash\n      const text = await element.textContent();\n      return `text:${text?.substring(0, 100)}`;\n    } catch {\n      return `fallback:${Date.now()}`;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
