{
  "version": 3,
  "sources": ["csv-utils.ts"],
  "sourcesContent": ["/**\n * CSV Utilities - CSV parsing and writing functions\n * \n * Used for persisting saved answers and job application results.\n */\n\nimport * as fs from 'fs';\nimport { createLogger } from './logger';\n\nconst log = createLogger('CSVUtils');\n\n/**\n * A saved Q&A pair from previous applications\n */\nexport interface SavedAnswer {\n  questionType: string;\n  questionText: string;\n  answer: string;\n}\n\n/**\n * Parse a CSV line into parts, handling quoted fields\n * \n * @param line - CSV line to parse\n * @returns Array of field values\n */\nexport function parseCSVLine(line: string): string[] {\n  const result: string[] = [];\n  let current = '';\n  let inQuotes = false;\n\n  for (const char of line) {\n    if (char === '\"') {\n      inQuotes = !inQuotes;\n    } else if (char === ',' && !inQuotes) {\n      result.push(current);\n      current = '';\n    } else {\n      current += char;\n    }\n  }\n  result.push(current);\n\n  return result.map(s => s.trim());\n}\n\n/**\n * Escape a value for CSV output\n * \n * @param value - Value to escape\n * @returns Escaped value with quotes if needed\n */\nexport function escapeCSVValue(value: string): string {\n  // Always wrap in quotes and escape any inner quotes\n  return `\"${value.replace(/\"/g, '\"\"')}\"`;\n}\n\n/**\n * Format a row for CSV output\n * \n * @param values - Array of values to format\n * @returns CSV-formatted line with newline\n */\nexport function formatCSVLine(values: string[]): string {\n  return values.map(escapeCSVValue).join(',') + '\\n';\n}\n\n/**\n * Load saved answers from a CSV file\n * \n * File format: questionType,questionText,answer\n * \n * @param filePath - Path to CSV file\n * @returns Array of saved answers\n */\nexport function loadSavedAnswers(filePath: string): SavedAnswer[] {\n  const answers: SavedAnswer[] = [];\n  \n  if (!fs.existsSync(filePath)) {\n    log.debug(`No saved answers file found: ${filePath}`);\n    return answers;\n  }\n\n  try {\n    const content = fs.readFileSync(filePath, 'utf-8');\n    const lines = content.split('\\n').filter(line => line.trim());\n\n    for (const line of lines) {\n      const parts = parseCSVLine(line);\n      if (parts.length >= 3) {\n        const [questionType, questionText, answer] = parts;\n        \n        // Skip invalid placeholder answers\n        if (!answer || answer.length <= 2) continue;\n        const answerLower = answer.toLowerCase();\n        if (answerLower.startsWith('select') || answerLower.startsWith('choose')) continue;\n        if (['option', 'n/a', 'none', 'null'].includes(answerLower)) continue;\n\n        answers.push({ questionType, questionText, answer });\n      }\n    }\n\n    log.info(`Loaded ${answers.length} saved answers`);\n  } catch (error) {\n    log.error(`Failed to load saved answers: ${error}`);\n  }\n\n  return answers;\n}\n\n/**\n * Save a new answer to a CSV file\n * \n * Checks for duplicates before appending.\n * \n * @param filePath - Path to CSV file\n * @param existing - Array of existing answers (for duplicate check)\n * @param questionType - Type of question\n * @param questionText - Question text\n * @param answer - Answer text\n * @returns true if saved, false if duplicate\n */\nexport function saveAnswer(\n  filePath: string,\n  existing: SavedAnswer[],\n  questionType: string,\n  questionText: string,\n  answer: string\n): boolean {\n  // Check for duplicates\n  const exists = existing.some(\n    a => a.questionType.toLowerCase() === questionType.toLowerCase() &&\n         a.questionText.toLowerCase() === questionText.toLowerCase()\n  );\n\n  if (exists) {\n    return false;\n  }\n\n  // Append to CSV\n  const line = formatCSVLine([questionType, questionText, answer]);\n  fs.appendFileSync(filePath, line, 'utf-8');\n  \n  return true;\n}\n\n/**\n * Append a job result to a CSV file\n * \n * @param filePath - Path to CSV file\n * @param company - Company name\n * @param title - Job title\n * @param link - Job URL\n * @param location - Job location\n */\nexport function appendJobResult(\n  filePath: string,\n  company: string,\n  title: string,\n  link: string,\n  location: string\n): void {\n  const line = formatCSVLine([company, title, link, location]);\n  fs.appendFileSync(filePath, line, 'utf-8');\n}\n"],
  "mappings": "AAMA,YAAY,QAAQ;AACpB,SAAS,oBAAoB;AAE7B,MAAM,MAAM,aAAa,UAAU;AAiB5B,SAAS,aAAa,MAAwB;AACnD,QAAM,SAAmB,CAAC;AAC1B,MAAI,UAAU;AACd,MAAI,WAAW;AAEf,aAAW,QAAQ,MAAM;AACvB,QAAI,SAAS,KAAK;AAChB,iBAAW,CAAC;AAAA,IACd,WAAW,SAAS,OAAO,CAAC,UAAU;AACpC,aAAO,KAAK,OAAO;AACnB,gBAAU;AAAA,IACZ,OAAO;AACL,iBAAW;AAAA,IACb;AAAA,EACF;AACA,SAAO,KAAK,OAAO;AAEnB,SAAO,OAAO,IAAI,OAAK,EAAE,KAAK,CAAC;AACjC;AAQO,SAAS,eAAe,OAAuB;AAEpD,SAAO,IAAI,MAAM,QAAQ,MAAM,IAAI,CAAC;AACtC;AAQO,SAAS,cAAc,QAA0B;AACtD,SAAO,OAAO,IAAI,cAAc,EAAE,KAAK,GAAG,IAAI;AAChD;AAUO,SAAS,iBAAiB,UAAiC;AAChE,QAAM,UAAyB,CAAC;AAEhC,MAAI,CAAC,GAAG,WAAW,QAAQ,GAAG;AAC5B,QAAI,MAAM,gCAAgC,QAAQ,EAAE;AACpD,WAAO;AAAA,EACT;AAEA,MAAI;AACF,UAAM,UAAU,GAAG,aAAa,UAAU,OAAO;AACjD,UAAM,QAAQ,QAAQ,MAAM,IAAI,EAAE,OAAO,UAAQ,KAAK,KAAK,CAAC;AAE5D,eAAW,QAAQ,OAAO;AACxB,YAAM,QAAQ,aAAa,IAAI;AAC/B,UAAI,MAAM,UAAU,GAAG;AACrB,cAAM,CAAC,cAAc,cAAc,MAAM,IAAI;AAG7C,YAAI,CAAC,UAAU,OAAO,UAAU,EAAG;AACnC,cAAM,cAAc,OAAO,YAAY;AACvC,YAAI,YAAY,WAAW,QAAQ,KAAK,YAAY,WAAW,QAAQ,EAAG;AAC1E,YAAI,CAAC,UAAU,OAAO,QAAQ,MAAM,EAAE,SAAS,WAAW,EAAG;AAE7D,gBAAQ,KAAK,EAAE,cAAc,cAAc,OAAO,CAAC;AAAA,MACrD;AAAA,IACF;AAEA,QAAI,KAAK,UAAU,QAAQ,MAAM,gBAAgB;AAAA,EACnD,SAAS,OAAO;AACd,QAAI,MAAM,iCAAiC,KAAK,EAAE;AAAA,EACpD;AAEA,SAAO;AACT;AAcO,SAAS,WACd,UACA,UACA,cACA,cACA,QACS;AAET,QAAM,SAAS,SAAS;AAAA,IACtB,OAAK,EAAE,aAAa,YAAY,MAAM,aAAa,YAAY,KAC1D,EAAE,aAAa,YAAY,MAAM,aAAa,YAAY;AAAA,EACjE;AAEA,MAAI,QAAQ;AACV,WAAO;AAAA,EACT;AAGA,QAAM,OAAO,cAAc,CAAC,cAAc,cAAc,MAAM,CAAC;AAC/D,KAAG,eAAe,UAAU,MAAM,OAAO;AAEzC,SAAO;AACT;AAWO,SAAS,gBACd,UACA,SACA,OACA,MACA,UACM;AACN,QAAM,OAAO,cAAc,CAAC,SAAS,OAAO,MAAM,QAAQ,CAAC;AAC3D,KAAG,eAAe,UAAU,MAAM,OAAO;AAC3C;",
  "names": []
}
